import { Connection, ConnectionConfig, PublicKey } from '@solana/web3.js';
import { Buffer } from 'buffer';
import { ValidityProofWithContext, CompressedTransaction, CompressionApiInterface, GetCompressedTokenAccountsByOwnerOrDelegateOptions, HexInputsForProver, ParsedTokenAccount, SignatureWithMetadata, LatestNonVotingSignatures, LatestNonVotingSignaturesPaginated, WithContext, GetCompressedAccountsByOwnerConfig, WithCursor, AddressWithTree, HashWithTree, CompressedMintTokenHolders, TokenBalance, PaginatedOptions } from './rpc-interface';
import { MerkleContextWithMerkleProof, BN254, CompressedAccountWithMerkleContext, ValidityProof, AddressTreeInfo } from './state';
import BN from 'bn.js';
import { LightWasm } from './test-helpers';
import { TreeInfo } from './state/types';
/** @internal */
export declare function parseAccountData({ discriminator, data, dataHash, }: {
    discriminator: BN;
    data: string;
    dataHash: BN;
}): {
    discriminator: number[];
    data: Buffer;
    dataHash: number[];
};
/**
 * Establish a Compression-compatible JSON RPC connection
 *
 * @param endpointOrWeb3JsConnection    endpoint to the solana cluster or
 *                                      Connection object
 * @param compressionApiEndpoint        Endpoint to the compression server
 * @param proverEndpoint                Endpoint to the prover server. defaults
 *                                      to endpoint
 * @param connectionConfig              Optional connection config
 */
export declare function createRpc(endpointOrWeb3JsConnection?: string | Connection, compressionApiEndpoint?: string, proverEndpoint?: string, config?: ConnectionConfig): Rpc;
/**
 * Helper function to preprocess the response to wrap numbers as strings
 * @param {string} text - The JSON string to preprocess
 * @returns {string} - The preprocessed JSON string with numbers wrapped as strings
 */
export declare function wrapBigNumbersAsStrings(text: string): string;
/** @internal */
export declare const rpcRequest: (rpcEndpoint: string, method: string, params?: any, convertToCamelCase?: boolean, debug?: boolean) => Promise<any>;
/** @internal */
export declare const proverRequest: (proverEndpoint: string, method: "inclusion" | "new-address" | "combined", params?: any, log?: boolean, _publicInputHash?: BN | undefined) => Promise<ValidityProof>;
export type NonInclusionMerkleProofInputs = {
    root: BN;
    value: BN;
    leaf_lower_range_value: BN;
    leaf_higher_range_value: BN;
    nextIndex: BN;
    merkle_proof_hashed_indexed_element_leaf: BN[];
    index_hashed_indexed_element_leaf: BN;
};
export type MerkleContextWithNewAddressProof = {
    root: BN;
    rootIndex: number;
    value: BN;
    leafLowerRangeValue: BN;
    leafHigherRangeValue: BN;
    nextIndex: BN;
    merkleProofHashedIndexedElementLeaf: BN[];
    indexHashedIndexedElementLeaf: BN;
    treeInfo: AddressTreeInfo;
};
export type NonInclusionJsonStruct = {
    root: string;
    value: string;
    pathIndex: number;
    pathElements: string[];
    leafLowerRangeValue: string;
    leafHigherRangeValue: string;
    nextIndex: number;
};
export declare function convertMerkleProofsWithContextToHex(merkleProofsWithContext: MerkleContextWithMerkleProof[]): HexInputsForProver[];
export declare function convertNonInclusionMerkleProofInputsToHex(nonInclusionMerkleProofInputs: MerkleContextWithNewAddressProof[]): NonInclusionJsonStruct[];
export declare function getPublicInputHash(accountProofs: MerkleContextWithMerkleProof[], accountHashes: BN254[], newAddressProofs: MerkleContextWithNewAddressProof[], lightWasm: LightWasm): BN;
export interface NullifierMetadata {
    nullifier: BN254;
    txHash: BN254;
}
/**
 *
 */
export declare class Rpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    allStateTreeInfos: TreeInfo[] | null;
    lastStateTreeFetchTime: number | null;
    CACHE_TTL: number;
    fetchPromise: Promise<TreeInfo[]> | null;
    constructor(endpoint: string, compressionApiEndpoint: string, proverEndpoint: string, config?: ConnectionConfig);
    /**
     * @deprecated Use {@link getStateTreeInfos} instead
     */
    getCachedActiveStateTreeInfo(): Promise<void>;
    /**
     * @deprecated Use {@link getStateTreeInfos} instead
     */
    getCachedActiveStateTreeInfos(): Promise<void>;
    /**
     * Get a list of all state tree infos. If not already cached, fetches from
     * the cluster.
     */
    getStateTreeInfos(): Promise<TreeInfo[]>;
    /**
     * @internal
     */
    doFetch(): Promise<TreeInfo[]>;
    /**
     * Fetch the compressed account for the specified account address or hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account address or hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig | undefined): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2} instead.
     *
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Returns without context.
     */
    getCompressedTokenBalancesByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    /**
     * Fetch the compressed token balances owned by the specified public
     * key. Paginated. Can filter by mint. Returns with context.
     */
    getCompressedTokenBalancesByOwnerV2(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed compression signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(slot: number): Promise<boolean>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch all the compressed token holders for a given mint. Paginated.
     */
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch all non-voting signatures
     */
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in
     * respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    /**
     * @deprecated use {@link getValidityProofV0} instead.
     *
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<ValidityProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of { hash: BN254, tree: PublicKey, queue: PublicKey }.
     * @param newAddresses  Array of { address: BN254, tree: PublicKey, queue: PublicKey }.
     * @returns             validity proof with context
     */
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<ValidityProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses. Returns with context slot.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses. Optionally specify the
     *                      tree and queue for each address. Default to public
     *                      state tree/queue.
     * @returns             validity proof with context
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<ValidityProofWithContext>>;
}
