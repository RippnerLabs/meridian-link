"use strict";var e=require("@solana/web3.js"),t=require("buffer"),r="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function o(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var n={},s={};class i{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}decode(e,t){throw new Error("Layout is abstract")}encode(e,t,r){throw new Error("Layout is abstract")}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function a(e,t){return t.property?e+"["+t.property+"]":e}s.Layout=i,s.nameWithProperty=a,s.bindConstructorLayout=function(e,t){if("function"!=typeof e)throw new TypeError("Class must be constructor");if(e.hasOwnProperty("layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof i))throw new TypeError("layout must be a Layout");if(t.hasOwnProperty("boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value:function(e,r){return t.encode(this,e,r)},writable:1}),Object.defineProperty(e,"decode",{value:function(e,r){return t.decode(e,r)},writable:1})};class u extends i{isCount(){throw new Error("ExternalLayout is abstract")}}class c extends u{constructor(e,t){if(void 0===e&&(e=1),!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return 1}decode(e,t){void 0===t&&(t=0);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}class l extends u{constructor(e,t,r){if(!(e instanceof i))throw new TypeError("layout must be a Layout");if(void 0===t)t=0;else if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof d||this.layout instanceof h}decode(e,t){return void 0===t&&(t=0),this.layout.decode(e,t+this.offset)}encode(e,t,r){return void 0===r&&(r=0),this.layout.encode(e,t,r+this.offset)}}class d extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readUIntLE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeUIntLE(e,r,this.span),this.span}}class h extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readUIntBE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeUIntBE(e,r,this.span),this.span}}class p extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readIntLE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeIntLE(e,r,this.span),this.span}}class m extends i{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readIntBE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeIntBE(e,r,this.span),this.span}}const f=Math.pow(2,32);function y(e){const t=Math.floor(e/f);return{hi32:t,lo32:e-t*f}}function g(e,t){return e*f+t}class w extends i{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);const r=e.readUInt32LE(t);return g(e.readUInt32LE(t+4),r)}encode(e,t,r){void 0===r&&(r=0);const o=y(e);return t.writeUInt32LE(o.lo32,r),t.writeUInt32LE(o.hi32,r+4),8}}class v extends i{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),g(e.readUInt32BE(t),e.readUInt32BE(t+4))}encode(e,t,r){void 0===r&&(r=0);const o=y(e);return t.writeUInt32BE(o.hi32,r),t.writeUInt32BE(o.lo32,r+4),8}}class x extends i{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);const r=e.readUInt32LE(t);return g(e.readInt32LE(t+4),r)}encode(e,t,r){void 0===r&&(r=0);const o=y(e);return t.writeUInt32LE(o.lo32,r),t.writeInt32LE(o.hi32,r+4),8}}class b extends i{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),g(e.readInt32BE(t),e.readUInt32BE(t+4))}encode(e,t,r){void 0===r&&(r=0);const o=y(e);return t.writeInt32BE(o.hi32,r),t.writeUInt32BE(o.lo32,r+4),8}}class I extends i{constructor(e){super(4,e)}decode(e,t){return void 0===t&&(t=0),e.readFloatLE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeFloatLE(e,r),4}}class E extends i{constructor(e){super(4,e)}decode(e,t){return void 0===t&&(t=0),e.readFloatBE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeFloatBE(e,r),4}}class M extends i{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),e.readDoubleLE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeDoubleLE(e,r),8}}class A extends i{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),e.readDoubleBE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeDoubleBE(e,r),8}}class T extends i{constructor(e,t,r){if(!(e instanceof i))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof u&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let o=-1;!(t instanceof u)&&0<e.span&&(o=t*e.span),super(o,r),this.elementLayout=e,this.count=t}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let r=0,o=this.count;if(o instanceof u&&(o=o.decode(e,t)),0<this.elementLayout.span)r=o*this.elementLayout.span;else{let n=0;for(;n<o;)r+=this.elementLayout.getSpan(e,t+r),++n}return r}decode(e,t){void 0===t&&(t=0);const r=[];let o=0,n=this.count;for(n instanceof u&&(n=n.decode(e,t));o<n;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),o+=1;return r}encode(e,t,r){void 0===r&&(r=0);const o=this.elementLayout,n=e.reduce(((e,n)=>e+o.encode(n,t,r+e)),0);return this.count instanceof u&&this.count.encode(e.length,t,r),n}}class _ extends i{constructor(e,t,r){if(!Array.isArray(e)||!e.reduce(((e,t)=>e&&t instanceof i),1))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof t&&void 0===r&&(r=t,t=void 0);for(const t of e)if(0>t.span&&void 0===t.property)throw new Error("fields cannot contain unnamed variable-length layout");let o=-1;try{o=e.reduce(((e,t)=>e+t.getSpan()),0)}catch(e){}super(o,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let r=0;try{r=this.fields.reduce(((r,o)=>{const n=o.getSpan(e,t);return t+=n,r+n}),0)}catch(e){throw new RangeError("indeterminate span")}return r}decode(e,t){void 0===t&&(t=0);const r=this.makeDestinationObject();for(const o of this.fields)if(void 0!==o.property&&(r[o.property]=o.decode(e,t)),t+=o.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r){void 0===r&&(r=0);const o=r;let n=0,s=0;for(const o of this.fields){let i=o.span;if(s=0<i?i:0,void 0!==o.property){const n=e[o.property];void 0!==n&&(s=o.encode(n,t,r),0>i&&(i=o.getSpan(t,r)))}n=r,r+=i}return n+s-o}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)void 0!==r.property&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!=typeof e)throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}class S{constructor(e){this.property=e}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class k extends S{constructor(e,t){if(!(e instanceof u&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}class C extends i{constructor(e,t,r){const o=e instanceof d||e instanceof h;if(o)e=new k(new l(e));else if(e instanceof u&&e.isCount())e=new k(e);else if(!(e instanceof S))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(void 0===t&&(t=null),!(null===t||t instanceof i))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let n=-1;t&&(n=t.span,0<=n&&o&&(n+=e.layout.span)),super(n,r),this.discriminator=e,this.usesPrefixDiscriminator=o,this.defaultLayout=t,this.registry={};let s=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return s(e)},this.configGetSourceVariant=function(e){s=e.bind(this)}}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(e.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&e.hasOwnProperty(this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||e.hasOwnProperty(t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(e.hasOwnProperty(r.property))return r}throw new Error("unable to infer src variant")}decode(e,t){let r;void 0===t&&(t=0);const o=this.discriminator,n=o.decode(e,t);let s=this.registry[n];if(void 0===s){let i=0;s=this.defaultLayout,this.usesPrefixDiscriminator&&(i=o.layout.span),r=this.makeDestinationObject(),r[o.property]=n,r[s.property]=this.defaultLayout.decode(e,t+i)}else r=s.decode(e,t);return r}encode(e,t,r){void 0===r&&(r=0);const o=this.getSourceVariant(e);if(void 0===o){const o=this.discriminator,n=this.defaultLayout;let s=0;return this.usesPrefixDiscriminator&&(s=o.layout.span),o.encode(e[o.property],t,r),s+n.encode(e[n.property],t,r+s)}return o.encode(e,t,r)}addVariant(e,t,r){const o=new P(this,e,t,r);return this.registry[e]=o,o}getVariant(e,t){let r=e;return Buffer.isBuffer(e)&&(void 0===t&&(t=0),r=this.discriminator.decode(e,t)),this.registry[r]}}class P extends i{constructor(e,t,r,o){if(!(e instanceof C))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof r&&void 0===o&&(o=r,r=null),r){if(!(r instanceof i))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof o)throw new TypeError("variant must have a String property")}let n=e.span;0>e.span&&(n=r?r.span:0,0<=n&&e.usesPrefixDiscriminator&&(n+=e.discriminator.layout.span)),super(n,o),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),r+this.layout.getSpan(e,t+r)}decode(e,t){const r=this.makeDestinationObject();if(void 0===t&&(t=0),this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let o=0;return this.union.usesPrefixDiscriminator&&(o=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+o):this.property?r[this.property]=1:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r){void 0===r&&(r=0);let o=0;if(this.union.usesPrefixDiscriminator&&(o=this.union.discriminator.layout.span),this.layout&&!e.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let n=o;if(this.layout&&(this.layout.encode(e[this.property],t,r+o),n+=this.layout.getSpan(t,r+o),0<=this.union.span&&n>this.union.span))throw new Error("encoded variant overruns containing union");return n}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function L(e){return 0>e&&(e+=4294967296),e}class N extends i{constructor(e,t,r){if(!(e instanceof d||e instanceof h))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof t&&void 0===r&&(r=t,t=void 0),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let o=0;this._packedSetValue=function(e){return o=L(e),this},this._packedGetValue=function(){return o}}decode(e,t){const r=this.makeDestinationObject();void 0===t&&(t=0);const o=this.word.decode(e,t);this._packedSetValue(o);for(const e of this.fields)void 0!==e.property&&(r[e.property]=e.decode(o));return r}encode(e,t,r){void 0===r&&(r=0);const o=this.word.decode(t,r);this._packedSetValue(o);for(const t of this.fields)if(void 0!==t.property){const r=e[t.property];void 0!==r&&t.encode(r)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new O(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new B(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}class O{constructor(e,t,r){if(!(e instanceof N))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const o=8*e.span,n=e.fields.reduce(((e,t)=>e+t.bits),0);if(t+n>o)throw new Error("bits too long for span remainder ("+(o-n)+" of "+o+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=n,this.container.msb&&(this.start=o-n-t),this.wordMask=L(this.valueMask<<this.start),this.property=r}decode(){return L(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(e){if(!Number.isInteger(e)||e!==L(e&this.valueMask))throw new TypeError(a("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=L(e<<this.start);this.container._packedSetValue(L(t&~this.wordMask)|r)}}class B extends O{constructor(e,t){super(e,1,t)}decode(e,t){return!!O.prototype.decode.call(this,e,t)}encode(e){return"boolean"==typeof e&&(e=+e),O.prototype.encode.call(this,e)}}class R extends i{constructor(e,t){if(!(e instanceof u&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof u||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t){void 0===t&&(t=0);let r=this.span;return 0>r&&(r=this.length.decode(e,t)),e.slice(t,t+r)}encode(e,t,r){let o=this.length;if(this.length instanceof u&&(o=e.length),!Buffer.isBuffer(e)||o!==e.length)throw new TypeError(a("Blob.encode",this)+" requires (length "+o+") Buffer as src");if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return t.write(e.toString("hex"),r,o,"hex"),this.length instanceof u&&this.length.encode(o,t,r),o}}class D extends i{constructor(e){super(-1,e)}getSpan(e,t){if(!Buffer.isBuffer(e))throw new TypeError("b must be a Buffer");void 0===t&&(t=0);let r=t;for(;r<e.length&&0!==e[r];)r+=1;return 1+r-t}decode(e,t,r){void 0===t&&(t=0);let o=this.getSpan(e,t);return e.slice(t,t+o-1).toString("utf-8")}encode(e,t,r){void 0===r&&(r=0),"string"!=typeof e&&(e=e.toString());const o=new Buffer(e,"utf8"),n=o.length;if(r+n>t.length)throw new RangeError("encoding overruns Buffer");return o.copy(t,r),t[r+n]=0,n+1}}class U extends i{constructor(e,t){if("string"==typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t){if(!Buffer.isBuffer(e))throw new TypeError("b must be a Buffer");return void 0===t&&(t=0),e.length-t}decode(e,t,r){void 0===t&&(t=0);let o=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");return e.slice(t,t+o).toString("utf-8")}encode(e,t,r){void 0===r&&(r=0),"string"!=typeof e&&(e=e.toString());const o=new Buffer(e,"utf8"),n=o.length;if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");if(r+n>t.length)throw new RangeError("encoding overruns Buffer");return o.copy(t,r),n}}class V extends i{constructor(e,t){super(0,t),this.value=e}decode(e,t,r){return this.value}encode(e,t,r){return 0}}s.ExternalLayout=u,s.GreedyCount=c,s.OffsetLayout=l,s.UInt=d,s.UIntBE=h,s.Int=p,s.IntBE=m,s.Float=I,s.FloatBE=E,s.Double=M,s.DoubleBE=A,s.Sequence=T,s.Structure=_,s.UnionDiscriminator=S,s.UnionLayoutDiscriminator=k,s.Union=C,s.VariantLayout=P,s.BitStructure=N,s.BitField=O,s.Boolean=B,s.Blob=R,s.CString=D,s.UTF8=U,s.Constant=V,s.greedy=(e,t)=>new c(e,t),s.offset=(e,t,r)=>new l(e,t,r),s.u8=e=>new d(1,e),s.u16=e=>new d(2,e),s.u24=e=>new d(3,e),s.u32=e=>new d(4,e),s.u40=e=>new d(5,e),s.u48=e=>new d(6,e),s.nu64=e=>new w(e),s.u16be=e=>new h(2,e),s.u24be=e=>new h(3,e),s.u32be=e=>new h(4,e),s.u40be=e=>new h(5,e),s.u48be=e=>new h(6,e),s.nu64be=e=>new v(e),s.s8=e=>new p(1,e),s.s16=e=>new p(2,e),s.s24=e=>new p(3,e),s.s32=e=>new p(4,e),s.s40=e=>new p(5,e),s.s48=e=>new p(6,e),s.ns64=e=>new x(e),s.s16be=e=>new m(2,e),s.s24be=e=>new m(3,e),s.s32be=e=>new m(4,e),s.s40be=e=>new m(5,e),s.s48be=e=>new m(6,e),s.ns64be=e=>new b(e),s.f32=e=>new I(e),s.f32be=e=>new E(e),s.f64=e=>new M(e),s.f64be=e=>new A(e),s.struct=(e,t,r)=>new _(e,t,r),s.bits=(e,t,r)=>new N(e,t,r),s.seq=(e,t,r)=>new T(e,t,r),s.union=(e,t,r)=>new C(e,t,r),s.unionLayoutDiscriminator=(e,t)=>new k(e,t),s.blob=(e,t)=>new R(e,t),s.cstr=e=>new D(e),s.utf8=(e,t)=>new U(e,t),s.const=(e,t)=>new V(e,t);var F={exports:{}};!function(e,t){function r(e,t){if(!e)throw new Error(t||"Assertion failed")}function o(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}function n(e,t,r){if(n.isBN(e))return e;this.negative=0,this.words=null,this.length=0,this.red=null,null!==e&&("le"!==t&&"be"!==t||(r=t,t=10),this._init(e||0,t||10,r||"be"))}var s;"object"==typeof F?F.exports=n:t.BN=n,n.BN=n,n.wordSize=26;try{s="undefined"!=typeof window&&void 0!==window.Buffer?window.Buffer:require("buffer").Buffer}catch(e){}function i(e,t){var o=e.charCodeAt(t);return o>=48&&o<=57?o-48:o>=65&&o<=70?o-55:o>=97&&o<=102?o-87:void r(0,"Invalid character in "+e)}function a(e,t,r){var o=i(e,r);return r-1>=t&&(o|=i(e,r-1)<<4),o}function u(e,t,o,n){for(var s=0,i=0,a=Math.min(e.length,o),u=t;u<a;u++){var c=e.charCodeAt(u)-48;s*=n,i=c>=49?c-49+10:c>=17?c-17+10:c,r(c>=0&&i<n,"Invalid character"),s+=i}return s}function c(e,t){e.words=t.words,e.length=t.length,e.negative=t.negative,e.red=t.red}if(n.isBN=function(e){return e instanceof n?1:null!==e&&"object"==typeof e&&e.constructor.wordSize===n.wordSize&&Array.isArray(e.words)},n.max=function(e,t){return e.cmp(t)>0?e:t},n.min=function(e,t){return e.cmp(t)<0?e:t},n.prototype._init=function(e,t,o){if("number"==typeof e)return this._initNumber(e,t,o);if("object"==typeof e)return this._initArray(e,t,o);"hex"===t&&(t=16),r(t===(0|t)&&t>=2&&t<=36);var n=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&(n++,this.negative=1),n<e.length&&(16===t?this._parseHex(e,n,o):(this._parseBase(e,t,n),"le"===o&&this._initArray(this.toArray(),t,o)))},n.prototype._initNumber=function(e,t,o){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(r(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===o&&this._initArray(this.toArray(),t,o)},n.prototype._initArray=function(e,t,o){if(r("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var n=0;n<this.length;n++)this.words[n]=0;var s,i,a=0;if("be"===o)for(n=e.length-1,s=0;n>=0;n-=3)i=e[n]|e[n-1]<<8|e[n-2]<<16,this.words[s]|=i<<a&67108863,this.words[s+1]=i>>>26-a&67108863,(a+=24)>=26&&(a-=26,s++);else if("le"===o)for(n=0,s=0;n<e.length;n+=3)i=e[n]|e[n+1]<<8|e[n+2]<<16,this.words[s]|=i<<a&67108863,this.words[s+1]=i>>>26-a&67108863,(a+=24)>=26&&(a-=26,s++);return this._strip()},n.prototype._parseHex=function(e,t,r){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var o=0;o<this.length;o++)this.words[o]=0;var n,s=0,i=0;if("be"===r)for(o=e.length-1;o>=t;o-=2)n=a(e,t,o)<<s,this.words[i]|=67108863&n,s>=18?(s-=18,i+=1,this.words[i]|=n>>>26):s+=8;else for(o=(e.length-t)%2==0?t+1:t;o<e.length;o+=2)n=a(e,t,o)<<s,this.words[i]|=67108863&n,s>=18?(s-=18,i+=1,this.words[i]|=n>>>26):s+=8;this._strip()},n.prototype._parseBase=function(e,t,r){this.words=[0],this.length=1;for(var o=0,n=1;n<=67108863;n*=t)o++;o--,n=n/t|0;for(var s=e.length-r,i=s%o,a=Math.min(s,s-i)+r,c=0,l=r;l<a;l+=o)c=u(e,l,l+o,t),this.imuln(n),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c);if(0!==i){var d=1;for(c=u(e,l,e.length,t),l=0;l<i;l++)d*=t;this.imuln(d),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c)}this._strip()},n.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},n.prototype._move=function(e){c(e,this)},n.prototype.clone=function(){var e=new n(null);return this.copy(e),e},n.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},n.prototype._strip=function(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this._normSign()},n.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},"undefined"!=typeof Symbol&&"function"==typeof Symbol.for)try{n.prototype[Symbol.for("nodejs.util.inspect.custom")]=l}catch(e){n.prototype.inspect=l}else n.prototype.inspect=l;function l(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var d=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],h=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],p=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function m(e,t,r){r.negative=t.negative^e.negative;var o=e.length+t.length|0;r.length=o,o=o-1|0;var n=0|e.words[0],s=0|t.words[0],i=n*s,a=67108863&i,u=i/67108864|0;r.words[0]=a;for(var c=1;c<o;c++){for(var l=u>>>26,d=67108863&u,h=Math.min(c,t.length-1),p=Math.max(0,c-e.length+1);p<=h;p++){var m=c-p|0;l+=(i=(n=0|e.words[m])*(s=0|t.words[p])+d)/67108864|0,d=67108863&i}r.words[c]=0|d,u=0|l}return 0!==u?r.words[c]=0|u:r.length--,r._strip()}n.prototype.toString=function(e,t){var o;if(t=0|t||1,16===(e=e||10)||"hex"===e){o="";for(var n=0,s=0,i=0;i<this.length;i++){var a=this.words[i],u=(16777215&(a<<n|s)).toString(16);s=a>>>24-n&16777215,(n+=2)>=26&&(n-=26,i--),o=0!==s||i!==this.length-1?d[6-u.length]+u+o:u+o}for(0!==s&&(o=s.toString(16)+o);o.length%t!=0;)o="0"+o;return 0!==this.negative&&(o="-"+o),o}if(e===(0|e)&&e>=2&&e<=36){var c=h[e],l=p[e];o="";var m=this.clone();for(m.negative=0;!m.isZero();){var f=m.modrn(l).toString(e);o=(m=m.idivn(l)).isZero()?f+o:d[c-f.length]+f+o}for(this.isZero()&&(o="0"+o);o.length%t!=0;)o="0"+o;return 0!==this.negative&&(o="-"+o),o}r(0,"Base should be between 2 and 36")},n.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:this.length>2&&r(0,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},n.prototype.toJSON=function(){return this.toString(16,2)},s&&(n.prototype.toBuffer=function(e,t){return this.toArrayLike(s,e,t)}),n.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},n.prototype.toArrayLike=function(e,t,o){this._strip();var n=this.byteLength(),s=o||Math.max(1,n);r(n<=s,"byte array longer than desired length"),r(s>0,"Requested array length <= 0");var i=function(e,t){return e.allocUnsafe?e.allocUnsafe(t):new e(t)}(e,s);return this["_toArrayLike"+("le"===t?"LE":"BE")](i,n),i},n.prototype._toArrayLikeLE=function(e){for(var t=0,r=0,o=0,n=0;o<this.length;o++){var s=this.words[o]<<n|r;e[t++]=255&s,t<e.length&&(e[t++]=s>>8&255),t<e.length&&(e[t++]=s>>16&255),6===n?(t<e.length&&(e[t++]=s>>24&255),r=0,n=0):(r=s>>>24,n+=2)}if(t<e.length)for(e[t++]=r;t<e.length;)e[t++]=0},n.prototype._toArrayLikeBE=function(e){for(var t=e.length-1,r=0,o=0,n=0;o<this.length;o++){var s=this.words[o]<<n|r;e[t--]=255&s,t>=0&&(e[t--]=s>>8&255),t>=0&&(e[t--]=s>>16&255),6===n?(t>=0&&(e[t--]=s>>24&255),r=0,n=0):(r=s>>>24,n+=2)}if(t>=0)for(e[t--]=r;t>=0;)e[t--]=0},Math.clz32?n.prototype._countBits=function(e){return 32-Math.clz32(e)}:n.prototype._countBits=function(e){var t=e,r=0;return t>=4096&&(r+=13,t>>>=13),t>=64&&(r+=7,t>>>=7),t>=8&&(r+=4,t>>>=4),t>=2&&(r+=2,t>>>=2),r+t},n.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,r=0;return 0==(8191&t)&&(r+=13,t>>>=13),0==(127&t)&&(r+=7,t>>>=7),0==(15&t)&&(r+=4,t>>>=4),0==(3&t)&&(r+=2,t>>>=2),0==(1&t)&&r++,r},n.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},n.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var r=this._zeroBits(this.words[t]);if(e+=r,26!==r)break}return e},n.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},n.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},n.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},n.prototype.isNeg=function(){return 0!==this.negative},n.prototype.neg=function(){return this.clone().ineg()},n.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},n.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this._strip()},n.prototype.ior=function(e){return r(0==(this.negative|e.negative)),this.iuor(e)},n.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},n.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},n.prototype.iuand=function(e){var t;t=this.length>e.length?e:this;for(var r=0;r<t.length;r++)this.words[r]=this.words[r]&e.words[r];return this.length=t.length,this._strip()},n.prototype.iand=function(e){return r(0==(this.negative|e.negative)),this.iuand(e)},n.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},n.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},n.prototype.iuxor=function(e){var t,r;this.length>e.length?(t=this,r=e):(t=e,r=this);for(var o=0;o<r.length;o++)this.words[o]=t.words[o]^r.words[o];if(this!==t)for(;o<t.length;o++)this.words[o]=t.words[o];return this.length=t.length,this._strip()},n.prototype.ixor=function(e){return r(0==(this.negative|e.negative)),this.iuxor(e)},n.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},n.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},n.prototype.inotn=function(e){r("number"==typeof e&&e>=0);var t=0|Math.ceil(e/26),o=e%26;this._expand(t),o>0&&t--;for(var n=0;n<t;n++)this.words[n]=67108863&~this.words[n];return o>0&&(this.words[n]=~this.words[n]&67108863>>26-o),this._strip()},n.prototype.notn=function(e){return this.clone().inotn(e)},n.prototype.setn=function(e,t){r("number"==typeof e&&e>=0);var o=e/26|0,n=e%26;return this._expand(o+1),this.words[o]=t?this.words[o]|1<<n:this.words[o]&~(1<<n),this._strip()},n.prototype.iadd=function(e){var t,r,o;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();this.length>e.length?(r=this,o=e):(r=e,o=this);for(var n=0,s=0;s<o.length;s++)t=(0|r.words[s])+(0|o.words[s])+n,this.words[s]=67108863&t,n=t>>>26;for(;0!==n&&s<r.length;s++)t=(0|r.words[s])+n,this.words[s]=67108863&t,n=t>>>26;if(this.length=r.length,0!==n)this.words[this.length]=n,this.length++;else if(r!==this)for(;s<r.length;s++)this.words[s]=r.words[s];return this},n.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},n.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var r,o,n=this.cmp(e);if(0===n)return this.negative=0,this.length=1,this.words[0]=0,this;n>0?(r=this,o=e):(r=e,o=this);for(var s=0,i=0;i<o.length;i++)s=(t=(0|r.words[i])-(0|o.words[i])+s)>>26,this.words[i]=67108863&t;for(;0!==s&&i<r.length;i++)s=(t=(0|r.words[i])+s)>>26,this.words[i]=67108863&t;if(0===s&&i<r.length&&r!==this)for(;i<r.length;i++)this.words[i]=r.words[i];return this.length=Math.max(this.length,i),r!==this&&(this.negative=1),this._strip()},n.prototype.sub=function(e){return this.clone().isub(e)};var f=function(e,t,r){var o,n,s,i=e.words,a=t.words,u=r.words,c=0,l=0|i[0],d=8191&l,h=l>>>13,p=0|i[1],m=8191&p,f=p>>>13,y=0|i[2],g=8191&y,w=y>>>13,v=0|i[3],x=8191&v,b=v>>>13,I=0|i[4],E=8191&I,M=I>>>13,A=0|i[5],T=8191&A,_=A>>>13,S=0|i[6],k=8191&S,C=S>>>13,P=0|i[7],L=8191&P,N=P>>>13,O=0|i[8],B=8191&O,R=O>>>13,D=0|i[9],U=8191&D,V=D>>>13,F=0|a[0],q=8191&F,K=F>>>13,H=0|a[1],$=8191&H,j=H>>>13,z=0|a[2],W=8191&z,Z=z>>>13,J=0|a[3],Q=8191&J,G=J>>>13,X=0|a[4],Y=8191&X,ee=X>>>13,te=0|a[5],re=8191&te,oe=te>>>13,ne=0|a[6],se=8191&ne,ie=ne>>>13,ae=0|a[7],ue=8191&ae,ce=ae>>>13,le=0|a[8],de=8191&le,he=le>>>13,pe=0|a[9],me=8191&pe,fe=pe>>>13;r.negative=e.negative^t.negative,r.length=19;var ye=(c+(o=Math.imul(d,q))|0)+((8191&(n=(n=Math.imul(d,K))+Math.imul(h,q)|0))<<13)|0;c=((s=Math.imul(h,K))+(n>>>13)|0)+(ye>>>26)|0,ye&=67108863,o=Math.imul(m,q),n=(n=Math.imul(m,K))+Math.imul(f,q)|0,s=Math.imul(f,K);var ge=(c+(o=o+Math.imul(d,$)|0)|0)+((8191&(n=(n=n+Math.imul(d,j)|0)+Math.imul(h,$)|0))<<13)|0;c=((s=s+Math.imul(h,j)|0)+(n>>>13)|0)+(ge>>>26)|0,ge&=67108863,o=Math.imul(g,q),n=(n=Math.imul(g,K))+Math.imul(w,q)|0,s=Math.imul(w,K),o=o+Math.imul(m,$)|0,n=(n=n+Math.imul(m,j)|0)+Math.imul(f,$)|0,s=s+Math.imul(f,j)|0;var we=(c+(o=o+Math.imul(d,W)|0)|0)+((8191&(n=(n=n+Math.imul(d,Z)|0)+Math.imul(h,W)|0))<<13)|0;c=((s=s+Math.imul(h,Z)|0)+(n>>>13)|0)+(we>>>26)|0,we&=67108863,o=Math.imul(x,q),n=(n=Math.imul(x,K))+Math.imul(b,q)|0,s=Math.imul(b,K),o=o+Math.imul(g,$)|0,n=(n=n+Math.imul(g,j)|0)+Math.imul(w,$)|0,s=s+Math.imul(w,j)|0,o=o+Math.imul(m,W)|0,n=(n=n+Math.imul(m,Z)|0)+Math.imul(f,W)|0,s=s+Math.imul(f,Z)|0;var ve=(c+(o=o+Math.imul(d,Q)|0)|0)+((8191&(n=(n=n+Math.imul(d,G)|0)+Math.imul(h,Q)|0))<<13)|0;c=((s=s+Math.imul(h,G)|0)+(n>>>13)|0)+(ve>>>26)|0,ve&=67108863,o=Math.imul(E,q),n=(n=Math.imul(E,K))+Math.imul(M,q)|0,s=Math.imul(M,K),o=o+Math.imul(x,$)|0,n=(n=n+Math.imul(x,j)|0)+Math.imul(b,$)|0,s=s+Math.imul(b,j)|0,o=o+Math.imul(g,W)|0,n=(n=n+Math.imul(g,Z)|0)+Math.imul(w,W)|0,s=s+Math.imul(w,Z)|0,o=o+Math.imul(m,Q)|0,n=(n=n+Math.imul(m,G)|0)+Math.imul(f,Q)|0,s=s+Math.imul(f,G)|0;var xe=(c+(o=o+Math.imul(d,Y)|0)|0)+((8191&(n=(n=n+Math.imul(d,ee)|0)+Math.imul(h,Y)|0))<<13)|0;c=((s=s+Math.imul(h,ee)|0)+(n>>>13)|0)+(xe>>>26)|0,xe&=67108863,o=Math.imul(T,q),n=(n=Math.imul(T,K))+Math.imul(_,q)|0,s=Math.imul(_,K),o=o+Math.imul(E,$)|0,n=(n=n+Math.imul(E,j)|0)+Math.imul(M,$)|0,s=s+Math.imul(M,j)|0,o=o+Math.imul(x,W)|0,n=(n=n+Math.imul(x,Z)|0)+Math.imul(b,W)|0,s=s+Math.imul(b,Z)|0,o=o+Math.imul(g,Q)|0,n=(n=n+Math.imul(g,G)|0)+Math.imul(w,Q)|0,s=s+Math.imul(w,G)|0,o=o+Math.imul(m,Y)|0,n=(n=n+Math.imul(m,ee)|0)+Math.imul(f,Y)|0,s=s+Math.imul(f,ee)|0;var be=(c+(o=o+Math.imul(d,re)|0)|0)+((8191&(n=(n=n+Math.imul(d,oe)|0)+Math.imul(h,re)|0))<<13)|0;c=((s=s+Math.imul(h,oe)|0)+(n>>>13)|0)+(be>>>26)|0,be&=67108863,o=Math.imul(k,q),n=(n=Math.imul(k,K))+Math.imul(C,q)|0,s=Math.imul(C,K),o=o+Math.imul(T,$)|0,n=(n=n+Math.imul(T,j)|0)+Math.imul(_,$)|0,s=s+Math.imul(_,j)|0,o=o+Math.imul(E,W)|0,n=(n=n+Math.imul(E,Z)|0)+Math.imul(M,W)|0,s=s+Math.imul(M,Z)|0,o=o+Math.imul(x,Q)|0,n=(n=n+Math.imul(x,G)|0)+Math.imul(b,Q)|0,s=s+Math.imul(b,G)|0,o=o+Math.imul(g,Y)|0,n=(n=n+Math.imul(g,ee)|0)+Math.imul(w,Y)|0,s=s+Math.imul(w,ee)|0,o=o+Math.imul(m,re)|0,n=(n=n+Math.imul(m,oe)|0)+Math.imul(f,re)|0,s=s+Math.imul(f,oe)|0;var Ie=(c+(o=o+Math.imul(d,se)|0)|0)+((8191&(n=(n=n+Math.imul(d,ie)|0)+Math.imul(h,se)|0))<<13)|0;c=((s=s+Math.imul(h,ie)|0)+(n>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,o=Math.imul(L,q),n=(n=Math.imul(L,K))+Math.imul(N,q)|0,s=Math.imul(N,K),o=o+Math.imul(k,$)|0,n=(n=n+Math.imul(k,j)|0)+Math.imul(C,$)|0,s=s+Math.imul(C,j)|0,o=o+Math.imul(T,W)|0,n=(n=n+Math.imul(T,Z)|0)+Math.imul(_,W)|0,s=s+Math.imul(_,Z)|0,o=o+Math.imul(E,Q)|0,n=(n=n+Math.imul(E,G)|0)+Math.imul(M,Q)|0,s=s+Math.imul(M,G)|0,o=o+Math.imul(x,Y)|0,n=(n=n+Math.imul(x,ee)|0)+Math.imul(b,Y)|0,s=s+Math.imul(b,ee)|0,o=o+Math.imul(g,re)|0,n=(n=n+Math.imul(g,oe)|0)+Math.imul(w,re)|0,s=s+Math.imul(w,oe)|0,o=o+Math.imul(m,se)|0,n=(n=n+Math.imul(m,ie)|0)+Math.imul(f,se)|0,s=s+Math.imul(f,ie)|0;var Ee=(c+(o=o+Math.imul(d,ue)|0)|0)+((8191&(n=(n=n+Math.imul(d,ce)|0)+Math.imul(h,ue)|0))<<13)|0;c=((s=s+Math.imul(h,ce)|0)+(n>>>13)|0)+(Ee>>>26)|0,Ee&=67108863,o=Math.imul(B,q),n=(n=Math.imul(B,K))+Math.imul(R,q)|0,s=Math.imul(R,K),o=o+Math.imul(L,$)|0,n=(n=n+Math.imul(L,j)|0)+Math.imul(N,$)|0,s=s+Math.imul(N,j)|0,o=o+Math.imul(k,W)|0,n=(n=n+Math.imul(k,Z)|0)+Math.imul(C,W)|0,s=s+Math.imul(C,Z)|0,o=o+Math.imul(T,Q)|0,n=(n=n+Math.imul(T,G)|0)+Math.imul(_,Q)|0,s=s+Math.imul(_,G)|0,o=o+Math.imul(E,Y)|0,n=(n=n+Math.imul(E,ee)|0)+Math.imul(M,Y)|0,s=s+Math.imul(M,ee)|0,o=o+Math.imul(x,re)|0,n=(n=n+Math.imul(x,oe)|0)+Math.imul(b,re)|0,s=s+Math.imul(b,oe)|0,o=o+Math.imul(g,se)|0,n=(n=n+Math.imul(g,ie)|0)+Math.imul(w,se)|0,s=s+Math.imul(w,ie)|0,o=o+Math.imul(m,ue)|0,n=(n=n+Math.imul(m,ce)|0)+Math.imul(f,ue)|0,s=s+Math.imul(f,ce)|0;var Me=(c+(o=o+Math.imul(d,de)|0)|0)+((8191&(n=(n=n+Math.imul(d,he)|0)+Math.imul(h,de)|0))<<13)|0;c=((s=s+Math.imul(h,he)|0)+(n>>>13)|0)+(Me>>>26)|0,Me&=67108863,o=Math.imul(U,q),n=(n=Math.imul(U,K))+Math.imul(V,q)|0,s=Math.imul(V,K),o=o+Math.imul(B,$)|0,n=(n=n+Math.imul(B,j)|0)+Math.imul(R,$)|0,s=s+Math.imul(R,j)|0,o=o+Math.imul(L,W)|0,n=(n=n+Math.imul(L,Z)|0)+Math.imul(N,W)|0,s=s+Math.imul(N,Z)|0,o=o+Math.imul(k,Q)|0,n=(n=n+Math.imul(k,G)|0)+Math.imul(C,Q)|0,s=s+Math.imul(C,G)|0,o=o+Math.imul(T,Y)|0,n=(n=n+Math.imul(T,ee)|0)+Math.imul(_,Y)|0,s=s+Math.imul(_,ee)|0,o=o+Math.imul(E,re)|0,n=(n=n+Math.imul(E,oe)|0)+Math.imul(M,re)|0,s=s+Math.imul(M,oe)|0,o=o+Math.imul(x,se)|0,n=(n=n+Math.imul(x,ie)|0)+Math.imul(b,se)|0,s=s+Math.imul(b,ie)|0,o=o+Math.imul(g,ue)|0,n=(n=n+Math.imul(g,ce)|0)+Math.imul(w,ue)|0,s=s+Math.imul(w,ce)|0,o=o+Math.imul(m,de)|0,n=(n=n+Math.imul(m,he)|0)+Math.imul(f,de)|0,s=s+Math.imul(f,he)|0;var Ae=(c+(o=o+Math.imul(d,me)|0)|0)+((8191&(n=(n=n+Math.imul(d,fe)|0)+Math.imul(h,me)|0))<<13)|0;c=((s=s+Math.imul(h,fe)|0)+(n>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,o=Math.imul(U,$),n=(n=Math.imul(U,j))+Math.imul(V,$)|0,s=Math.imul(V,j),o=o+Math.imul(B,W)|0,n=(n=n+Math.imul(B,Z)|0)+Math.imul(R,W)|0,s=s+Math.imul(R,Z)|0,o=o+Math.imul(L,Q)|0,n=(n=n+Math.imul(L,G)|0)+Math.imul(N,Q)|0,s=s+Math.imul(N,G)|0,o=o+Math.imul(k,Y)|0,n=(n=n+Math.imul(k,ee)|0)+Math.imul(C,Y)|0,s=s+Math.imul(C,ee)|0,o=o+Math.imul(T,re)|0,n=(n=n+Math.imul(T,oe)|0)+Math.imul(_,re)|0,s=s+Math.imul(_,oe)|0,o=o+Math.imul(E,se)|0,n=(n=n+Math.imul(E,ie)|0)+Math.imul(M,se)|0,s=s+Math.imul(M,ie)|0,o=o+Math.imul(x,ue)|0,n=(n=n+Math.imul(x,ce)|0)+Math.imul(b,ue)|0,s=s+Math.imul(b,ce)|0,o=o+Math.imul(g,de)|0,n=(n=n+Math.imul(g,he)|0)+Math.imul(w,de)|0,s=s+Math.imul(w,he)|0;var Te=(c+(o=o+Math.imul(m,me)|0)|0)+((8191&(n=(n=n+Math.imul(m,fe)|0)+Math.imul(f,me)|0))<<13)|0;c=((s=s+Math.imul(f,fe)|0)+(n>>>13)|0)+(Te>>>26)|0,Te&=67108863,o=Math.imul(U,W),n=(n=Math.imul(U,Z))+Math.imul(V,W)|0,s=Math.imul(V,Z),o=o+Math.imul(B,Q)|0,n=(n=n+Math.imul(B,G)|0)+Math.imul(R,Q)|0,s=s+Math.imul(R,G)|0,o=o+Math.imul(L,Y)|0,n=(n=n+Math.imul(L,ee)|0)+Math.imul(N,Y)|0,s=s+Math.imul(N,ee)|0,o=o+Math.imul(k,re)|0,n=(n=n+Math.imul(k,oe)|0)+Math.imul(C,re)|0,s=s+Math.imul(C,oe)|0,o=o+Math.imul(T,se)|0,n=(n=n+Math.imul(T,ie)|0)+Math.imul(_,se)|0,s=s+Math.imul(_,ie)|0,o=o+Math.imul(E,ue)|0,n=(n=n+Math.imul(E,ce)|0)+Math.imul(M,ue)|0,s=s+Math.imul(M,ce)|0,o=o+Math.imul(x,de)|0,n=(n=n+Math.imul(x,he)|0)+Math.imul(b,de)|0,s=s+Math.imul(b,he)|0;var _e=(c+(o=o+Math.imul(g,me)|0)|0)+((8191&(n=(n=n+Math.imul(g,fe)|0)+Math.imul(w,me)|0))<<13)|0;c=((s=s+Math.imul(w,fe)|0)+(n>>>13)|0)+(_e>>>26)|0,_e&=67108863,o=Math.imul(U,Q),n=(n=Math.imul(U,G))+Math.imul(V,Q)|0,s=Math.imul(V,G),o=o+Math.imul(B,Y)|0,n=(n=n+Math.imul(B,ee)|0)+Math.imul(R,Y)|0,s=s+Math.imul(R,ee)|0,o=o+Math.imul(L,re)|0,n=(n=n+Math.imul(L,oe)|0)+Math.imul(N,re)|0,s=s+Math.imul(N,oe)|0,o=o+Math.imul(k,se)|0,n=(n=n+Math.imul(k,ie)|0)+Math.imul(C,se)|0,s=s+Math.imul(C,ie)|0,o=o+Math.imul(T,ue)|0,n=(n=n+Math.imul(T,ce)|0)+Math.imul(_,ue)|0,s=s+Math.imul(_,ce)|0,o=o+Math.imul(E,de)|0,n=(n=n+Math.imul(E,he)|0)+Math.imul(M,de)|0,s=s+Math.imul(M,he)|0;var Se=(c+(o=o+Math.imul(x,me)|0)|0)+((8191&(n=(n=n+Math.imul(x,fe)|0)+Math.imul(b,me)|0))<<13)|0;c=((s=s+Math.imul(b,fe)|0)+(n>>>13)|0)+(Se>>>26)|0,Se&=67108863,o=Math.imul(U,Y),n=(n=Math.imul(U,ee))+Math.imul(V,Y)|0,s=Math.imul(V,ee),o=o+Math.imul(B,re)|0,n=(n=n+Math.imul(B,oe)|0)+Math.imul(R,re)|0,s=s+Math.imul(R,oe)|0,o=o+Math.imul(L,se)|0,n=(n=n+Math.imul(L,ie)|0)+Math.imul(N,se)|0,s=s+Math.imul(N,ie)|0,o=o+Math.imul(k,ue)|0,n=(n=n+Math.imul(k,ce)|0)+Math.imul(C,ue)|0,s=s+Math.imul(C,ce)|0,o=o+Math.imul(T,de)|0,n=(n=n+Math.imul(T,he)|0)+Math.imul(_,de)|0,s=s+Math.imul(_,he)|0;var ke=(c+(o=o+Math.imul(E,me)|0)|0)+((8191&(n=(n=n+Math.imul(E,fe)|0)+Math.imul(M,me)|0))<<13)|0;c=((s=s+Math.imul(M,fe)|0)+(n>>>13)|0)+(ke>>>26)|0,ke&=67108863,o=Math.imul(U,re),n=(n=Math.imul(U,oe))+Math.imul(V,re)|0,s=Math.imul(V,oe),o=o+Math.imul(B,se)|0,n=(n=n+Math.imul(B,ie)|0)+Math.imul(R,se)|0,s=s+Math.imul(R,ie)|0,o=o+Math.imul(L,ue)|0,n=(n=n+Math.imul(L,ce)|0)+Math.imul(N,ue)|0,s=s+Math.imul(N,ce)|0,o=o+Math.imul(k,de)|0,n=(n=n+Math.imul(k,he)|0)+Math.imul(C,de)|0,s=s+Math.imul(C,he)|0;var Ce=(c+(o=o+Math.imul(T,me)|0)|0)+((8191&(n=(n=n+Math.imul(T,fe)|0)+Math.imul(_,me)|0))<<13)|0;c=((s=s+Math.imul(_,fe)|0)+(n>>>13)|0)+(Ce>>>26)|0,Ce&=67108863,o=Math.imul(U,se),n=(n=Math.imul(U,ie))+Math.imul(V,se)|0,s=Math.imul(V,ie),o=o+Math.imul(B,ue)|0,n=(n=n+Math.imul(B,ce)|0)+Math.imul(R,ue)|0,s=s+Math.imul(R,ce)|0,o=o+Math.imul(L,de)|0,n=(n=n+Math.imul(L,he)|0)+Math.imul(N,de)|0,s=s+Math.imul(N,he)|0;var Pe=(c+(o=o+Math.imul(k,me)|0)|0)+((8191&(n=(n=n+Math.imul(k,fe)|0)+Math.imul(C,me)|0))<<13)|0;c=((s=s+Math.imul(C,fe)|0)+(n>>>13)|0)+(Pe>>>26)|0,Pe&=67108863,o=Math.imul(U,ue),n=(n=Math.imul(U,ce))+Math.imul(V,ue)|0,s=Math.imul(V,ce),o=o+Math.imul(B,de)|0,n=(n=n+Math.imul(B,he)|0)+Math.imul(R,de)|0,s=s+Math.imul(R,he)|0;var Le=(c+(o=o+Math.imul(L,me)|0)|0)+((8191&(n=(n=n+Math.imul(L,fe)|0)+Math.imul(N,me)|0))<<13)|0;c=((s=s+Math.imul(N,fe)|0)+(n>>>13)|0)+(Le>>>26)|0,Le&=67108863,o=Math.imul(U,de),n=(n=Math.imul(U,he))+Math.imul(V,de)|0,s=Math.imul(V,he);var Ne=(c+(o=o+Math.imul(B,me)|0)|0)+((8191&(n=(n=n+Math.imul(B,fe)|0)+Math.imul(R,me)|0))<<13)|0;c=((s=s+Math.imul(R,fe)|0)+(n>>>13)|0)+(Ne>>>26)|0,Ne&=67108863;var Oe=(c+(o=Math.imul(U,me))|0)+((8191&(n=(n=Math.imul(U,fe))+Math.imul(V,me)|0))<<13)|0;return c=((s=Math.imul(V,fe))+(n>>>13)|0)+(Oe>>>26)|0,Oe&=67108863,u[0]=ye,u[1]=ge,u[2]=we,u[3]=ve,u[4]=xe,u[5]=be,u[6]=Ie,u[7]=Ee,u[8]=Me,u[9]=Ae,u[10]=Te,u[11]=_e,u[12]=Se,u[13]=ke,u[14]=Ce,u[15]=Pe,u[16]=Le,u[17]=Ne,u[18]=Oe,0!==c&&(u[19]=c,r.length++),r};function y(e,t,r){r.negative=t.negative^e.negative,r.length=e.length+t.length;for(var o=0,n=0,s=0;s<r.length-1;s++){var i=n;n=0;for(var a=67108863&o,u=Math.min(s,t.length-1),c=Math.max(0,s-e.length+1);c<=u;c++){var l=s-c,d=(0|e.words[l])*(0|t.words[c]),h=67108863&d;a=67108863&(h=h+a|0),n+=(i=(i=i+(d/67108864|0)|0)+(h>>>26)|0)>>>26,i&=67108863}r.words[s]=a,o=i,i=n}return 0!==o?r.words[s]=o:r.length--,r._strip()}function g(e,t,r){return y(e,t,r)}Math.imul||(f=m),n.prototype.mulTo=function(e,t){var r=this.length+e.length;return 10===this.length&&10===e.length?f(this,e,t):r<63?m(this,e,t):r<1024?y(this,e,t):g(this,e,t)},n.prototype.mul=function(e){var t=new n(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},n.prototype.mulf=function(e){var t=new n(null);return t.words=new Array(this.length+e.length),g(this,e,t)},n.prototype.imul=function(e){return this.clone().mulTo(e,this)},n.prototype.imuln=function(e){var t=e<0;t&&(e=-e),r("number"==typeof e),r(e<67108864);for(var o=0,n=0;n<this.length;n++){var s=(0|this.words[n])*e,i=(67108863&s)+(67108863&o);o>>=26,o+=s/67108864|0,o+=i>>>26,this.words[n]=67108863&i}return 0!==o&&(this.words[n]=o,this.length++),t?this.ineg():this},n.prototype.muln=function(e){return this.clone().imuln(e)},n.prototype.sqr=function(){return this.mul(this)},n.prototype.isqr=function(){return this.imul(this.clone())},n.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),r=0;r<t.length;r++){var o=r/26|0,n=r%26;t[r]=e.words[o]>>>n&1}return t}(e);if(0===t.length)return new n(1);for(var r=this,o=0;o<t.length&&0===t[o];o++,r=r.sqr());if(++o<t.length)for(var s=r.sqr();o<t.length;o++,s=s.sqr())0!==t[o]&&(r=r.mul(s));return r},n.prototype.iushln=function(e){r("number"==typeof e&&e>=0);var t,o=e%26,n=(e-o)/26,s=67108863>>>26-o<<26-o;if(0!==o){var i=0;for(t=0;t<this.length;t++){var a=this.words[t]&s,u=(0|this.words[t])-a<<o;this.words[t]=u|i,i=a>>>26-o}i&&(this.words[t]=i,this.length++)}if(0!==n){for(t=this.length-1;t>=0;t--)this.words[t+n]=this.words[t];for(t=0;t<n;t++)this.words[t]=0;this.length+=n}return this._strip()},n.prototype.ishln=function(e){return r(0===this.negative),this.iushln(e)},n.prototype.iushrn=function(e,t,o){var n;r("number"==typeof e&&e>=0),n=t?(t-t%26)/26:0;var s=e%26,i=Math.min((e-s)/26,this.length),a=67108863^67108863>>>s<<s,u=o;if(n-=i,n=Math.max(0,n),u){for(var c=0;c<i;c++)u.words[c]=this.words[c];u.length=i}if(0===i);else if(this.length>i)for(this.length-=i,c=0;c<this.length;c++)this.words[c]=this.words[c+i];else this.words[0]=0,this.length=1;var l=0;for(c=this.length-1;c>=0&&(0!==l||c>=n);c--){var d=0|this.words[c];this.words[c]=l<<26-s|d>>>s,l=d&a}return u&&0!==l&&(u.words[u.length++]=l),0===this.length&&(this.words[0]=0,this.length=1),this._strip()},n.prototype.ishrn=function(e,t,o){return r(0===this.negative),this.iushrn(e,t,o)},n.prototype.shln=function(e){return this.clone().ishln(e)},n.prototype.ushln=function(e){return this.clone().iushln(e)},n.prototype.shrn=function(e){return this.clone().ishrn(e)},n.prototype.ushrn=function(e){return this.clone().iushrn(e)},n.prototype.testn=function(e){r("number"==typeof e&&e>=0);var t=e%26,o=(e-t)/26,n=1<<t;return this.length<=o?0:!!(this.words[o]&n)},n.prototype.imaskn=function(e){r("number"==typeof e&&e>=0);var t=e%26,o=(e-t)/26;if(r(0===this.negative,"imaskn works only with positive numbers"),this.length<=o)return this;if(0!==t&&o++,this.length=Math.min(o,this.length),0!==t){var n=67108863^67108863>>>t<<t;this.words[this.length-1]&=n}return this._strip()},n.prototype.maskn=function(e){return this.clone().imaskn(e)},n.prototype.iaddn=function(e){return r("number"==typeof e),r(e<67108864),e<0?this.isubn(-e):0!==this.negative?1===this.length&&(0|this.words[0])<=e?(this.words[0]=e-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(e),this.negative=1,this):this._iaddn(e)},n.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&this.words[t]>=67108864;t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},n.prototype.isubn=function(e){if(r("number"==typeof e),r(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,this.words[t+1]-=1;return this._strip()},n.prototype.addn=function(e){return this.clone().iaddn(e)},n.prototype.subn=function(e){return this.clone().isubn(e)},n.prototype.iabs=function(){return this.negative=0,this},n.prototype.abs=function(){return this.clone().iabs()},n.prototype._ishlnsubmul=function(e,t,o){var n,s,i=e.length+o;this._expand(i);var a=0;for(n=0;n<e.length;n++){s=(0|this.words[n+o])+a;var u=(0|e.words[n])*t;a=((s-=67108863&u)>>26)-(u/67108864|0),this.words[n+o]=67108863&s}for(;n<this.length-o;n++)a=(s=(0|this.words[n+o])+a)>>26,this.words[n+o]=67108863&s;if(0===a)return this._strip();for(r(-1===a),a=0,n=0;n<this.length;n++)a=(s=-(0|this.words[n])+a)>>26,this.words[n]=67108863&s;return this.negative=1,this._strip()},n.prototype._wordDiv=function(e,t){var r=(this.length,e.length),o=this.clone(),s=e,i=0|s.words[s.length-1];0!=(r=26-this._countBits(i))&&(s=s.ushln(r),o.iushln(r),i=0|s.words[s.length-1]);var a,u=o.length-s.length;if("mod"!==t){(a=new n(null)).length=u+1,a.words=new Array(a.length);for(var c=0;c<a.length;c++)a.words[c]=0}var l=o.clone()._ishlnsubmul(s,1,u);0===l.negative&&(o=l,a&&(a.words[u]=1));for(var d=u-1;d>=0;d--){var h=67108864*(0|o.words[s.length+d])+(0|o.words[s.length+d-1]);for(h=Math.min(h/i|0,67108863),o._ishlnsubmul(s,h,d);0!==o.negative;)h--,o.negative=0,o._ishlnsubmul(s,1,d),o.isZero()||(o.negative^=1);a&&(a.words[d]=h)}return a&&a._strip(),o._strip(),"div"!==t&&0!==r&&o.iushrn(r),{div:a||null,mod:o}},n.prototype.divmod=function(e,t,o){return r(!e.isZero()),this.isZero()?{div:new n(0),mod:new n(0)}:0!==this.negative&&0===e.negative?(a=this.neg().divmod(e,t),"mod"!==t&&(s=a.div.neg()),"div"!==t&&(i=a.mod.neg(),o&&0!==i.negative&&i.iadd(e)),{div:s,mod:i}):0===this.negative&&0!==e.negative?(a=this.divmod(e.neg(),t),"mod"!==t&&(s=a.div.neg()),{div:s,mod:a.mod}):0!=(this.negative&e.negative)?(a=this.neg().divmod(e.neg(),t),"div"!==t&&(i=a.mod.neg(),o&&0!==i.negative&&i.isub(e)),{div:a.div,mod:i}):e.length>this.length||this.cmp(e)<0?{div:new n(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new n(this.modrn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new n(this.modrn(e.words[0]))}:this._wordDiv(e,t);var s,i,a},n.prototype.div=function(e){return this.divmod(e,"div",0).div},n.prototype.mod=function(e){return this.divmod(e,"mod",0).mod},n.prototype.umod=function(e){return this.divmod(e,"mod",1).mod},n.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var r=0!==t.div.negative?t.mod.isub(e):t.mod,o=e.ushrn(1),n=e.andln(1),s=r.cmp(o);return s<0||1===n&&0===s?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},n.prototype.modrn=function(e){var t=e<0;t&&(e=-e),r(e<=67108863);for(var o=(1<<26)%e,n=0,s=this.length-1;s>=0;s--)n=(o*n+(0|this.words[s]))%e;return t?-n:n},n.prototype.modn=function(e){return this.modrn(e)},n.prototype.idivn=function(e){var t=e<0;t&&(e=-e),r(e<=67108863);for(var o=0,n=this.length-1;n>=0;n--){var s=(0|this.words[n])+67108864*o;this.words[n]=s/e|0,o=s%e}return this._strip(),t?this.ineg():this},n.prototype.divn=function(e){return this.clone().idivn(e)},n.prototype.egcd=function(e){r(0===e.negative),r(!e.isZero());var t=this,o=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var s=new n(1),i=new n(0),a=new n(0),u=new n(1),c=0;t.isEven()&&o.isEven();)t.iushrn(1),o.iushrn(1),++c;for(var l=o.clone(),d=t.clone();!t.isZero();){for(var h=0,p=1;0==(t.words[0]&p)&&h<26;++h,p<<=1);if(h>0)for(t.iushrn(h);h-- >0;)(s.isOdd()||i.isOdd())&&(s.iadd(l),i.isub(d)),s.iushrn(1),i.iushrn(1);for(var m=0,f=1;0==(o.words[0]&f)&&m<26;++m,f<<=1);if(m>0)for(o.iushrn(m);m-- >0;)(a.isOdd()||u.isOdd())&&(a.iadd(l),u.isub(d)),a.iushrn(1),u.iushrn(1);t.cmp(o)>=0?(t.isub(o),s.isub(a),i.isub(u)):(o.isub(t),a.isub(s),u.isub(i))}return{a:a,b:u,gcd:o.iushln(c)}},n.prototype._invmp=function(e){r(0===e.negative),r(!e.isZero());var t=this,o=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var s,i=new n(1),a=new n(0),u=o.clone();t.cmpn(1)>0&&o.cmpn(1)>0;){for(var c=0,l=1;0==(t.words[0]&l)&&c<26;++c,l<<=1);if(c>0)for(t.iushrn(c);c-- >0;)i.isOdd()&&i.iadd(u),i.iushrn(1);for(var d=0,h=1;0==(o.words[0]&h)&&d<26;++d,h<<=1);if(d>0)for(o.iushrn(d);d-- >0;)a.isOdd()&&a.iadd(u),a.iushrn(1);t.cmp(o)>=0?(t.isub(o),i.isub(a)):(o.isub(t),a.isub(i))}return(s=0===t.cmpn(1)?i:a).cmpn(0)<0&&s.iadd(e),s},n.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),r=e.clone();t.negative=0,r.negative=0;for(var o=0;t.isEven()&&r.isEven();o++)t.iushrn(1),r.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;r.isEven();)r.iushrn(1);var n=t.cmp(r);if(n<0){var s=t;t=r,r=s}else if(0===n||0===r.cmpn(1))break;t.isub(r)}return r.iushln(o)},n.prototype.invm=function(e){return this.egcd(e).a.umod(e)},n.prototype.isEven=function(){return 0==(1&this.words[0])},n.prototype.isOdd=function(){return 1==(1&this.words[0])},n.prototype.andln=function(e){return this.words[0]&e},n.prototype.bincn=function(e){r("number"==typeof e);var t=e%26,o=(e-t)/26,n=1<<t;if(this.length<=o)return this._expand(o+1),this.words[o]|=n,this;for(var s=n,i=o;0!==s&&i<this.length;i++){var a=0|this.words[i];s=(a+=s)>>>26,a&=67108863,this.words[i]=a}return 0!==s&&(this.words[i]=s,this.length++),this},n.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},n.prototype.cmpn=function(e){var t,o=e<0;if(0!==this.negative&&!o)return-1;if(0===this.negative&&o)return 1;if(this._strip(),this.length>1)t=1;else{o&&(e=-e),r(e<=67108863,"Number is too big");var n=0|this.words[0];t=n===e?0:n<e?-1:1}return 0!==this.negative?0|-t:t},n.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},n.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,r=this.length-1;r>=0;r--){var o=0|this.words[r],n=0|e.words[r];if(o!==n){o<n?t=-1:o>n&&(t=1);break}}return t},n.prototype.gtn=function(e){return 1===this.cmpn(e)},n.prototype.gt=function(e){return 1===this.cmp(e)},n.prototype.gten=function(e){return this.cmpn(e)>=0},n.prototype.gte=function(e){return this.cmp(e)>=0},n.prototype.ltn=function(e){return-1===this.cmpn(e)},n.prototype.lt=function(e){return-1===this.cmp(e)},n.prototype.lten=function(e){return this.cmpn(e)<=0},n.prototype.lte=function(e){return this.cmp(e)<=0},n.prototype.eqn=function(e){return 0===this.cmpn(e)},n.prototype.eq=function(e){return 0===this.cmp(e)},n.red=function(e){return new M(e)},n.prototype.toRed=function(e){return r(!this.red,"Already a number in reduction context"),r(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},n.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},n.prototype._forceRed=function(e){return this.red=e,this},n.prototype.forceRed=function(e){return r(!this.red,"Already a number in reduction context"),this._forceRed(e)},n.prototype.redAdd=function(e){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},n.prototype.redIAdd=function(e){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},n.prototype.redSub=function(e){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},n.prototype.redISub=function(e){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},n.prototype.redShl=function(e){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},n.prototype.redMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},n.prototype.redIMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},n.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},n.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},n.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},n.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},n.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},n.prototype.redPow=function(e){return r(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var w={k256:null,p224:null,p192:null,p25519:null};function v(e,t){this.name=e,this.p=new n(t,16),this.n=this.p.bitLength(),this.k=new n(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function x(){v.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function b(){v.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function I(){v.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function E(){v.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function M(e){if("string"==typeof e){var t=n._prime(e);this.m=t.p,this.prime=t}else r(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null}function A(e){M.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new n(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}v.prototype._tmp=function(){var e=new n(null);return e.words=new Array(Math.ceil(this.n/13)),e},v.prototype.ireduce=function(e){var t,r=e;do{this.split(r,this.tmp),t=(r=(r=this.imulK(r)).iadd(this.tmp)).bitLength()}while(t>this.n);var o=t<this.n?-1:r.ucmp(this.p);return 0===o?(r.words[0]=0,r.length=1):o>0?r.isub(this.p):void 0!==r.strip?r.strip():r._strip(),r},v.prototype.split=function(e,t){e.iushrn(this.n,0,t)},v.prototype.imulK=function(e){return e.imul(this.k)},o(x,v),x.prototype.split=function(e,t){for(var r=4194303,o=Math.min(e.length,9),n=0;n<o;n++)t.words[n]=e.words[n];if(t.length=o,e.length<=9)return e.words[0]=0,void(e.length=1);var s=e.words[9];for(t.words[t.length++]=s&r,n=10;n<e.length;n++){var i=0|e.words[n];e.words[n-10]=(i&r)<<4|s>>>22,s=i}s>>>=22,e.words[n-10]=s,0===s&&e.length>10?e.length-=10:e.length-=9},x.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,r=0;r<e.length;r++){var o=0|e.words[r];t+=977*o,e.words[r]=67108863&t,t=64*o+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},o(b,v),o(I,v),o(E,v),E.prototype.imulK=function(e){for(var t=0,r=0;r<e.length;r++){var o=19*(0|e.words[r])+t,n=67108863&o;o>>>=26,e.words[r]=n,t=o}return 0!==t&&(e.words[e.length++]=t),e},n._prime=function(e){if(w[e])return w[e];var t;if("k256"===e)t=new x;else if("p224"===e)t=new b;else if("p192"===e)t=new I;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new E}return w[e]=t,t},M.prototype._verify1=function(e){r(0===e.negative,"red works only with positives"),r(e.red,"red works only with red numbers")},M.prototype._verify2=function(e,t){r(0==(e.negative|t.negative),"red works only with positives"),r(e.red&&e.red===t.red,"red works only with red numbers")},M.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):(c(e,e.umod(this.m)._forceRed(this)),e)},M.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},M.prototype.add=function(e,t){this._verify2(e,t);var r=e.add(t);return r.cmp(this.m)>=0&&r.isub(this.m),r._forceRed(this)},M.prototype.iadd=function(e,t){this._verify2(e,t);var r=e.iadd(t);return r.cmp(this.m)>=0&&r.isub(this.m),r},M.prototype.sub=function(e,t){this._verify2(e,t);var r=e.sub(t);return r.cmpn(0)<0&&r.iadd(this.m),r._forceRed(this)},M.prototype.isub=function(e,t){this._verify2(e,t);var r=e.isub(t);return r.cmpn(0)<0&&r.iadd(this.m),r},M.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},M.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},M.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},M.prototype.isqr=function(e){return this.imul(e,e.clone())},M.prototype.sqr=function(e){return this.mul(e,e)},M.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(r(t%2==1),3===t){var o=this.m.add(new n(1)).iushrn(2);return this.pow(e,o)}for(var s=this.m.subn(1),i=0;!s.isZero()&&0===s.andln(1);)i++,s.iushrn(1);r(!s.isZero());var a=new n(1).toRed(this),u=a.redNeg(),c=this.m.subn(1).iushrn(1),l=this.m.bitLength();for(l=new n(2*l*l).toRed(this);0!==this.pow(l,c).cmp(u);)l.redIAdd(u);for(var d=this.pow(l,s),h=this.pow(e,s.addn(1).iushrn(1)),p=this.pow(e,s),m=i;0!==p.cmp(a);){for(var f=p,y=0;0!==f.cmp(a);y++)f=f.redSqr();r(y<m);var g=this.pow(d,new n(1).iushln(m-y-1));h=h.redMul(g),d=g.redSqr(),p=p.redMul(d),m=y}return h},M.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},M.prototype.pow=function(e,t){if(t.isZero())return new n(1).toRed(this);if(0===t.cmpn(1))return e.clone();var r=new Array(16);r[0]=new n(1).toRed(this),r[1]=e;for(var o=2;o<r.length;o++)r[o]=this.mul(r[o-1],e);var s=r[0],i=0,a=0,u=t.bitLength()%26;for(0===u&&(u=26),o=t.length-1;o>=0;o--){for(var c=t.words[o],l=u-1;l>=0;l--){var d=c>>l&1;s!==r[0]&&(s=this.sqr(s)),0!==d||0!==i?(i<<=1,i|=d,(4==++a||0===o&&0===l)&&(s=this.mul(s,r[i]),a=0,i=0)):a=0}u=26}return s},M.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},M.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},n.mont=function(e){return new A(e)},o(A,M),A.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},A.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},A.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var r=e.imul(t),o=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),n=r.isub(o).iushrn(this.shift),s=n;return n.cmp(this.m)>=0?s=n.isub(this.m):n.cmpn(0)<0&&(s=n.iadd(this.m)),s._forceRed(this)},A.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new n(0)._forceRed(this);var r=e.mul(t),o=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),s=r.isub(o).iushrn(this.shift),i=s;return s.cmp(this.m)>=0?i=s.isub(this.m):s.cmpn(0)<0&&(i=s.iadd(this.m)),i._forceRed(this)},A.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(0,r);var q,K,H=F.exports,$=o(H);!function(t){var o=r&&r.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:1}),t.map=t.array=t.rustEnum=t.str=t.vecU8=t.tagged=t.vec=t.bool=t.option=t.publicKey=t.i256=t.u256=t.i128=t.u128=t.i64=t.u64=t.struct=t.f64=t.f32=t.i32=t.u32=t.i16=t.u16=t.i8=t.u8=void 0;const n=s,i=e,a=o(H);var u=s;Object.defineProperty(t,"u8",{enumerable:1,get:function(){return u.u8}}),Object.defineProperty(t,"i8",{enumerable:1,get:function(){return u.s8}}),Object.defineProperty(t,"u16",{enumerable:1,get:function(){return u.u16}}),Object.defineProperty(t,"i16",{enumerable:1,get:function(){return u.s16}}),Object.defineProperty(t,"u32",{enumerable:1,get:function(){return u.u32}}),Object.defineProperty(t,"i32",{enumerable:1,get:function(){return u.s32}}),Object.defineProperty(t,"f32",{enumerable:1,get:function(){return u.f32}}),Object.defineProperty(t,"f64",{enumerable:1,get:function(){return u.f64}}),Object.defineProperty(t,"struct",{enumerable:1,get:function(){return u.struct}});class c extends n.Layout{constructor(e,t,r){super(e,r),this.blob=(0,n.blob)(e),this.signed=t}decode(e,t=0){const r=new a.default(this.blob.decode(e,t),10,"le");return this.signed?r.fromTwos(8*this.span).clone():r}encode(e,t,r=0){return this.signed&&(e=e.toTwos(8*this.span)),this.blob.encode(e.toArrayLike(Buffer,"le",this.span),t,r)}}function l(e){return new c(8,0,e)}t.u64=l,t.i64=function(e){return new c(8,1,e)},t.u128=function(e){return new c(16,0,e)},t.i128=function(e){return new c(16,1,e)},t.u256=function(e){return new c(32,0,e)},t.i256=function(e){return new c(32,1,e)};class d extends n.Layout{constructor(e,t,r,o){super(e.span,o),this.layout=e,this.decoder=t,this.encoder=r}decode(e,t){return this.decoder(this.layout.decode(e,t))}encode(e,t,r){return this.layout.encode(this.encoder(e),t,r)}getSpan(e,t){return this.layout.getSpan(e,t)}}t.publicKey=function(e){return new d((0,n.blob)(32),(e=>new i.PublicKey(e)),(e=>e.toBuffer()),e)};class h extends n.Layout{constructor(e,t){super(-1,t),this.layout=e,this.discriminator=(0,n.u8)()}encode(e,t,r=0){return null==e?this.discriminator.encode(0,t,r):(this.discriminator.encode(1,t,r),this.layout.encode(e,t,r+1)+1)}decode(e,t=0){const r=this.discriminator.decode(e,t);if(0===r)return null;if(1===r)return this.layout.decode(e,t+1);throw new Error("Invalid option "+this.property)}getSpan(e,t=0){const r=this.discriminator.decode(e,t);if(0===r)return 1;if(1===r)return this.layout.getSpan(e,t+1)+1;throw new Error("Invalid option "+this.property)}}function p(e){if(0===e)return 0;if(1===e)return 1;throw new Error("Invalid bool: "+e)}function m(e){return e?1:0}function f(e){const t=(0,n.u32)("length"),r=(0,n.struct)([t,(0,n.blob)((0,n.offset)(t,-t.span),"data")]);return new d(r,(({data:e})=>e),(e=>({data:e})),e)}t.option=function(e,t){return new h(e,t)},t.bool=function(e){return new d((0,n.u8)(),p,m,e)},t.vec=function(e,t){const r=(0,n.u32)("length"),o=(0,n.struct)([r,(0,n.seq)(e,(0,n.offset)(r,-r.span),"values")]);return new d(o,(({values:e})=>e),(e=>({values:e})),t)},t.tagged=function(e,t,r){const o=(0,n.struct)([l("tag"),t.replicate("data")]);return new d(o,(function({tag:t,data:r}){if(!t.eq(e))throw new Error("Invalid tag, expected: "+e.toString("hex")+", got: "+t.toString("hex"));return r}),(t=>({tag:e,data:t})),r)},t.vecU8=f,t.str=function(e){return new d(f(),(e=>e.toString("utf-8")),(e=>Buffer.from(e,"utf-8")),e)},t.rustEnum=function(e,t,r){const o=(0,n.union)(null!=r?r:(0,n.u8)(),t);return e.forEach(((e,t)=>o.addVariant(t,e,e.property))),o},t.array=function(e,t,r){const o=(0,n.struct)([(0,n.seq)(e,t,"values")]);return new d(o,(({values:e})=>e),(e=>({values:e})),r)};class y extends n.Layout{constructor(e,t,r){super(e.span+t.span,r),this.keyLayout=e,this.valueLayout=t}decode(e,t){return t=t||0,[this.keyLayout.decode(e,t),this.valueLayout.decode(e,t+this.keyLayout.getSpan(e,t))]}encode(e,t,r){r=r||0;const o=this.keyLayout.encode(e[0],t,r);return o+this.valueLayout.encode(e[1],t,r+o)}getSpan(e,t){return this.keyLayout.getSpan(e,t)+this.valueLayout.getSpan(e,t)}}t.map=function(e,t,r){const o=(0,n.u32)("length"),s=(0,n.struct)([o,(0,n.seq)(new y(e,t),(0,n.offset)(o,-o.span),"values")]);return new d(s,(({values:e})=>new Map(e)),(e=>({values:Array.from(e.entries())})),r)}}(n),exports.TreeType=void 0,(q=exports.TreeType||(exports.TreeType={}))[q.StateV1=1]="StateV1",q[q.AddressV1=2]="AddressV1",q[q.StateV2=3]="StateV2",q[q.AddressV2=4]="AddressV2",exports.VERSION=void 0,(K=exports.VERSION||(exports.VERSION={})).V1="V1",K.V2="V2";const j={version:'"V2"',isV2:()=>"V2"===j.version.replace(/['"]/g,"").toUpperCase()},z=e=>j.isV2()?`${e}V2`:e,W=new $("21888242871839275222246405745257275088548364400416034343698204186575808495617"),Z=new $("452312848583266388373324160190187140051835877600158453279131187530910662655"),J=[2,64,66,15,0],Q=t.Buffer.from([26,16,169,7,21,202,242,25]),G=t.Buffer.from([49,212,191,129,39,194,43,196]),X=t.Buffer.from([86,47,163,166,21,223,92,8]),Y=t.Buffer.from([228,34,128,84,47,139,86,240]),ee=t.Buffer.from([180,143,159,153,35,46,248,163]),te="noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV",re="SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7",oe="compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq",ne=()=>new e.PublicKey("35hkDgaAKwMCaxRz2ocSZ6NaUrtKkyNqU6c4RV3tYJRh"),se=()=>e.PublicKey.findProgramAddressSync([t.Buffer.from("cpi_authority")],new e.PublicKey(re))[0],ie=()=>({registeredProgramPda:new e.PublicKey(ne()),noopProgram:new e.PublicKey(te),accountCompressionProgram:new e.PublicKey(oe),accountCompressionAuthority:new e.PublicKey(se()),cpiSignatureAccount:null}),ae=()=>({mainnet:[{stateTreeLookupTable:new e.PublicKey(pe),nullifyLookupTable:new e.PublicKey(me)}],devnet:[{stateTreeLookupTable:new e.PublicKey(fe),nullifyLookupTable:new e.PublicKey(ye)}]}),ue=e=>e.includes("localhost")||e.includes("127.0.0.1"),ce=()=>[{tree:new e.PublicKey(ve),queue:new e.PublicKey(ge),cpiContext:new e.PublicKey(we),treeType:exports.TreeType.StateV1,nextTreeInfo:null},{tree:new e.PublicKey(Ie),queue:new e.PublicKey(Ee),cpiContext:new e.PublicKey(Me),treeType:exports.TreeType.StateV1,nextTreeInfo:null},{tree:new e.PublicKey(Ae),queue:new e.PublicKey(Te),cpiContext:e.PublicKey.default,treeType:exports.TreeType.StateV2,nextTreeInfo:null}].filter((e=>j.isV2()?1:e.treeType===exports.TreeType.StateV1)),le=()=>({tree:new e.PublicKey(xe),queue:new e.PublicKey(be),cpiContext:null,treeType:exports.TreeType.AddressV1,nextTreeInfo:null}),de=()=>({nullifierQueue:new e.PublicKey(ge),merkleTree:new e.PublicKey(ve),merkleTreeHeight:_e,addressTree:new e.PublicKey(xe),addressQueue:new e.PublicKey(be)}),he=new e.PublicKey("cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m"),pe="7i86eQs3GSqHjN47WdWLTCGMW6gde1q96G2EVnUyK2st",me="H9QD4u1fG7KmkAzn2tDXhheushxFe1EcrjGGyEFXeMqT",fe="Dk9mNkbiZXJZ4By8DfSP6HEE4ojZzRvucwpawLeuwq8q",ye="AXbHzp1NgjLvpfnD6JRTTovXZ7APUCdtWZFCRr5tCxse",ge="nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148",we="cpi1uHzrEhBG733DoEJNgHCyRS3XmmyVNZx5fonubE4",ve="smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT",xe="amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2",be="aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F",Ie="smt2rJAFdyJJupwMKAqTNAJwvjhmiZ4JYGZmbVRw1Ho",Ee="nfq2hgS7NYemXsFaFUCe3EMXSDSfnZnAe27jC6aPP1X",Me="cpi2cdhkH5roePvcudTgUL8ppEBfTay1desGh8G8QxK",Ae="HLKs5NJ8FXkJg8BrzJt56adFYYuwg5etzDtBbQYTsixu",Te="6L7SzhYB3anwEQ9cphpJ1U7Scwj57bx2xueReg7R9cKU",_e=26,Se=new $(Math.floor(2**_e*.95)),ke=j.isV2()?new $(1):new $(300),Ce=(j.isV2(),new $(392)),Pe=new $(5e3),Le=new $(5e3);var Ne=function(e){const t=new Uint8Array(256);for(let e=0;e<t.length;e++)t[e]=255;for(let r=0;r<58;r++){const o=e.charAt(r),n=o.charCodeAt(0);if(255!==t[n])throw new TypeError(o+" is ambiguous");t[n]=r}const r=e.charAt(0),o=Math.log(58)/Math.log(256),n=Math.log(256)/Math.log(58);function s(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;let n=0,s=0,i=0;for(;e[n]===r;)s++,n++;const a=(e.length-n)*o+1>>>0,u=new Uint8Array(a);for(;e[n];){let r=t[e.charCodeAt(n)];if(255===r)return;let o=0;for(let e=a-1;(0!==r||o<i)&&-1!==e;e--,o++)r+=58*u[e]>>>0,u[e]=r%256>>>0,r=r/256>>>0;if(0!==r)throw new Error("Non-zero carry");i=o,n++}let c=a-i;for(;c!==a&&0===u[c];)c++;const l=new Uint8Array(s+(a-c));let d=s;for(;c!==a;)l[d++]=u[c++];return l}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";let o=0,s=0,i=0;const a=t.length;for(;i!==a&&0===t[i];)i++,o++;const u=(a-i)*n+1>>>0,c=new Uint8Array(u);for(;i!==a;){let e=t[i],r=0;for(let t=u-1;(0!==e||r<s)&&-1!==t;t--,r++)e+=256*c[t]>>>0,c[t]=e%58>>>0,e=e/58>>>0;if(0!==e)throw new Error("Non-zero carry");s=r,i++}let l=u-s;for(;l!==u&&0===c[l];)l++;let d=r.repeat(o);for(;l<u;++l)d+=e.charAt(c[l]);return d},decodeUnsafe:s,decode:function(e){const t=s(e);if(t)return t;throw new Error("Non-base58 character")}}}("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");const Oe=(e,t)=>{if("base58"===t){if("string"!=typeof e)throw new Error("Must be a base58 string");return Oe(Ne.decode(e))}return function(e){if(e.gte(W))throw new Error("Value is too large. Max <254 bits");return e}(new $(e,t))};function Be(e){const r=Oe(e).toArrayLike(t.Buffer,void 0,32);return Ne.encode(new Uint8Array(r))}const Re=(e,r,o)=>e instanceof Uint8Array&&!(e instanceof t.Buffer)?new $(t.Buffer.from(e),r,o):new $(e,r,o),De=(e,t,r,o)=>({owner:e,lamports:null!=t?t:new $(0),address:null!=o?o:null,data:null!=r?r:null}),Ue=(e,t,r,o,n)=>Object.assign(Object.assign({},e),{owner:t,lamports:null!=r?r:new $(0),address:null!=n?n:null,data:null!=o?o:null,readOnly:0}),Ve=(e,t,r,o=0)=>({treeInfo:e,hash:t,leafIndex:r,proveByIndex:o}),Fe=n.struct([n.publicKey("owner"),n.u64("lamports"),n.option(n.array(n.u8(),32),"address"),n.option(n.struct([n.array(n.u8(),8,"discriminator"),n.vecU8("data"),n.array(n.u8(),32,"dataHash")]),"data")],"compressedAccount"),qe=n.struct([n.u8("merkleTreePubkeyIndex"),n.u8("queuePubkeyIndex"),n.u32("leafIndex"),n.bool("proveByIndex")],"merkleContext"),Ke=n.struct([n.array(n.u8(),32,"seed"),n.u8("addressQueueAccountIndex"),n.u8("addressMerkleTreeAccountIndex"),n.u16("addressMerkleTreeRootIndex")],"newAddressParams"),He=n.struct([n.option(n.struct([n.array(n.u8(),32,"a"),n.array(n.u8(),64,"b"),n.array(n.u8(),32,"c")]),"proof"),n.vec(n.struct([Fe,qe,n.u16("rootIndex"),n.bool("readOnly")]),"inputCompressedAccountsWithMerkleContext"),n.vec(n.struct([Fe,n.u8("merkleTreeIndex")]),"outputCompressedAccounts"),n.option(n.u64(),"relayFee"),n.vec(Ke,"newAddressParams"),n.option(n.u64(),"compressOrDecompressLamports"),n.bool("isCompress")]);function $e(e){const r=t.Buffer.alloc(1e3),o=He.encode(e,r),n=t.Buffer.from(new Uint8Array(r.slice(0,o))),s=t.Buffer.alloc(4);return s.writeUInt32LE(o,0),t.Buffer.concat([new Uint8Array(Q),new Uint8Array(s),new Uint8Array(n)])}const je=n.struct([n.option(n.struct([n.array(n.u8(),32,"a"),n.array(n.u8(),64,"b"),n.array(n.u8(),32,"c")]),"proof"),n.vec(Ke,"newAddressParams"),n.vec(n.struct([Fe,qe,n.u16("rootIndex"),n.bool("readOnly")]),"inputCompressedAccountsWithMerkleContext"),n.vec(n.struct([Fe,n.u8("merkleTreeIndex")]),"outputCompressedAccounts"),n.option(n.u64(),"relayFee"),n.option(n.u64(),"compressOrDecompressLamports"),n.bool("isCompress"),n.option(n.struct([n.bool("set_context"),n.bool("first_set_context"),n.u8("cpi_context_account_index")]),"compressedCpiContext")]),ze=n.struct([n.array(n.u8(),32,"a"),n.array(n.u8(),64,"b"),n.array(n.u8(),32,"c")],"compressedProof"),We=n.struct([n.bool("set_context"),n.bool("first_set_context"),n.u8("cpi_context_account_index")],"compressedCpiContext"),Ze=n.struct([n.array(n.u8(),32,"seed"),n.u8("address_queue_account_index"),n.u8("address_merkle_tree_account_index"),n.u16("address_merkle_tree_root_index"),n.bool("assigned_to_account"),n.u8("assigned_account_index")],"newAddressParamsAssignedPacked"),Je=n.struct([n.u8("merkle_tree_pubkey_index"),n.u8("queue_pubkey_index"),n.u32("leaf_index"),n.bool("prove_by_index")],"packedMerkleContext"),Qe=n.struct([n.array(n.u8(),8,"discriminator"),n.array(n.u8(),32,"data_hash"),Je,n.u16("root_index"),n.u64("lamports"),n.option(n.array(n.u8(),32),"address")],"inAccount"),Ge=n.struct([n.array(n.u8(),32,"address"),n.u16("address_merkle_tree_root_index"),n.u8("address_merkle_tree_account_index")],"packedReadOnlyAddress"),Xe=n.struct([n.array(n.u8(),32,"account_hash"),Je,n.u16("root_index")],"packedReadOnlyCompressedAccount"),Ye=n.struct([n.u8("mode"),n.u8("bump"),n.publicKey("invoking_program_id"),n.u64("compress_or_decompress_lamports"),n.bool("is_compress"),n.bool("with_cpi_context"),n.bool("with_transaction_hash"),We,n.option(ze,"proof"),n.vec(Ze,"new_address_params"),n.vec(Qe,"input_compressed_accounts"),n.vec(n.struct([Fe,n.u8("merkleTreeIndex")]),"output_compressed_accounts"),n.vec(Ge,"read_only_addresses"),n.vec(Xe,"read_only_accounts")]);function et(e){return Ye.decode(e.slice(X.length))}function tt(e){return He.decode(e.slice(Q.length+4))}function rt(e){return je.decode(e.slice(G.length+4))}const ot=e=>{const t=Ur.programId,{feePayer:r,authority:o,registeredProgramPda:n,noopProgram:s,accountCompressionAuthority:i,accountCompressionProgram:a,solPoolPda:u,decompressionRecipient:c,systemProgram:l}=e;return[{pubkey:r,isSigner:1,isWritable:1},{pubkey:o,isSigner:1,isWritable:0},{pubkey:n,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:null!=u?u:t,isSigner:0,isWritable:null!==u},{pubkey:null!=c?c:t,isSigner:0,isWritable:1},{pubkey:l,isSigner:0,isWritable:0}]},nt=n.struct([n.vec(n.array(n.u8(),32),"inputCompressedAccountHashes"),n.vec(n.array(n.u8(),32),"outputCompressedAccountHashes"),n.vec(n.struct([n.struct([n.publicKey("owner"),n.u64("lamports"),n.option(n.array(n.u8(),32),"address"),n.option(n.struct([n.array(n.u8(),8,"discriminator"),n.vecU8("data"),n.array(n.u8(),32,"dataHash")]),"data")],"compressedAccount"),n.u8("merkleTreeIndex")]),"outputCompressedAccounts"),n.vec(n.u32(),"outputLeafIndices"),n.vec(n.struct([n.publicKey("tree_pubkey"),n.publicKey("queue_pubkey"),n.u64("tree_type"),n.u64("seq")]),"sequenceNumbers"),n.option(n.u64(),"relayFee"),n.bool("isCompress"),n.option(n.u64(),"compressOrDecompressLamports"),n.vec(n.publicKey(),"pubkeyArray"),n.option(n.vecU8(),"message")]);function st(e){return nt.decode(e)}const it=n.struct([n.u8("is_invoked_by_program"),n.u8("bump"),n.u8("num_queues"),n.u8("num_output_queues"),n.u8("start_output_appends"),n.u8("num_address_queues"),n.array(n.u8(),32,"tx_hash")],"appendNullifyCreateAddressInputsMeta"),at=n.struct([n.u8("index"),n.array(n.u8(),32,"leaf")],"appendLeavesInput"),ut=n.struct([n.array(n.u8(),32,"account_hash"),n.u32("leaf_index"),n.u8("prove_by_index"),n.u8("tree_index"),n.u8("queue_index")],"insertNullifierInput"),ct=n.struct([n.array(n.u8(),32,"address"),n.u8("tree_index"),n.u8("queue_index")],"insertAddressInput"),lt=n.struct([n.publicKey("tree_pubkey"),n.publicKey("queue_pubkey"),n.u64("tree_type"),n.u64("seq")],"merkleTreeSequenceNumber");function dt(e){let t=0;const r=it.decode(e,t);t+=it.span;const o=e.readUInt8(t);t+=1;const s=[];for(let r=0;r<o;r++){const r=at.decode(e,t);s.push(r),t+=at.span}const i=e.readUInt8(t);t+=1;const a=[];for(let r=0;r<i;r++){const r=ut.decode(e,t);a.push(r),t+=ut.span}const u=e.readUInt8(t);t+=1;const c=[];for(let r=0;r<u;r++){const r=ct.decode(e,t);c.push(r),t+=ct.span}const l=e.readUInt8(t);t+=1;const d=[];for(let r=0;r<l;r++){const r=lt.decode(e,t);d.push(r),t+=lt.span}const h=e.readUInt8(t);t+=1;for(let r=0;r<h;r++)lt.decode(e,t),t+=lt.span;const p=e.readUInt8(t);t+=1;for(let r=0;r<p;r++)lt.decode(e,t),t+=lt.span;const m=e.readUInt8(t);t+=1;const f=[];for(let r=0;r<m;r++){const r=n.u32().decode(e,t);f.push(r),t+=4}return{meta:r,leaves:s,nullifiers:a,addresses:c,sequence_numbers:d,output_leaf_indices:f}}function ht(r,o,n){const s=e=>Array.from(e instanceof t.Buffer?new Uint8Array(e):e);return{inputCompressedAccountHashes:r.nullifiers.map((e=>s(e.account_hash))),outputCompressedAccountHashes:r.leaves.map((e=>s(e.leaf))),outputCompressedAccounts:r.leaves.map(((r,o)=>{var i,a,u,c,l,d;return{compressedAccount:{owner:new e.PublicKey((null===(i=null==n?void 0:n.outputCompressedAccounts[o])||void 0===i?void 0:i.compressedAccount.owner)||e.PublicKey.default),lamports:Re((null===(a=null==n?void 0:n.outputCompressedAccounts[o])||void 0===a?void 0:a.compressedAccount.lamports)||0),address:null==n?void 0:n.outputCompressedAccounts[o].compressedAccount.address,data:(null===(u=null==n?void 0:n.outputCompressedAccounts[o])||void 0===u?void 0:u.compressedAccount.data)?{discriminator:s(t.Buffer.from(null===(c=n.outputCompressedAccounts[o].compressedAccount.data)||void 0===c?void 0:c.discriminator)),data:null!==(l=s(t.Buffer.from(new Uint8Array(n.outputCompressedAccounts[o].compressedAccount.data.data))))&&void 0!==l?l:[],dataHash:s(t.Buffer.from(null===(d=n.outputCompressedAccounts[o].compressedAccount.data)||void 0===d?void 0:d.dataHash))}:null},merkleTreeIndex:r.index}})),outputLeafIndices:r.output_leaf_indices,sequenceNumbers:r.sequence_numbers.map((e=>({tree_pubkey:e.tree_pubkey,queue_pubkey:e.queue_pubkey,tree_type:e.tree_type,seq:e.seq}))),pubkeyArray:o.slice(2).filter((t=>!t.equals(e.PublicKey.default))),isCompress:(null==n?void 0:n.isCompress)||0,relayFee:(null==n?void 0:n.relayFee)?Re(n.relayFee):null,compressOrDecompressLamports:(null==n?void 0:n.compressOrDecompressLamports)?Re(n.compressOrDecompressLamports):null,message:null}}function pt(e,t){const r=e.findIndex((e=>e.equals(t)));return-1===r?(e.push(t),e.length-1):r}function mt(e,t){return t<=0?[]:new Array(t).fill(e)}function ft(e){return e.map((e=>({pubkey:e,isWritable:1,isSigner:0})))}function yt(e,t,r,o,n=[]){const s=n.slice(),i=[],a=[];if(e.forEach(((e,r)=>{const o=pt(s,e.treeInfo.tree),n=pt(s,e.treeInfo.queue);i.push({compressedAccount:{owner:e.owner,lamports:e.lamports,address:e.address,data:e.data},merkleContext:{merkleTreePubkeyIndex:o,queuePubkeyIndex:n,leafIndex:e.leafIndex,proveByIndex:e.proveByIndex},rootIndex:t[r],readOnly:0})})),e.length>0&&o)throw new Error("Cannot specify both input accounts and outputStateTreeInfo");let u;if(e.length>0)u=e[0].treeInfo;else{if(!o)throw new Error("Neither input accounts nor outputStateTreeInfo are available");u=o}const c=u.nextTreeInfo||u;let l=c.tree;if(c.treeType===exports.TreeType.StateV2){if(!j.isV2())throw new Error("V2 trees are not supported yet");l=c.queue}const d=mt(l,r.length);return r.forEach(((e,t)=>{const r=pt(s,d[t]);a.push({compressedAccount:{owner:e.owner,lamports:e.lamports,address:e.address,data:e.data},merkleTreeIndex:r})})),{packedInputCompressedAccounts:i,packedOutputCompressedAccounts:a,remainingAccounts:s}}const gt=e=>{if(e.lt(Re(0)))throw new Error("Insufficient balance for transfer")},wt=e=>{if(0===e.length)throw new Error("No accounts provided for validation");const t=e[0].owner;if(!e.every((e=>e.owner.equals(t))))throw new Error("All input accounts must have the same owner")},vt=(e,t)=>{if(e>0&&t>0){if(8===e)throw new Error(`Invalid number of compressed accounts for proof: ${e}. Allowed numbers: ${[1,2,3,4].join(", ")}`);It(e,[1,2,3,4],"compressed accounts"),bt(t)}else e>0?xt(e):bt(t)},xt=e=>{It(e,[1,2,3,4,8],"compressed accounts")},bt=e=>{It(e,[1,2],"new addresses")},It=(e,t,r)=>{if(!t.includes(e))throw new Error(`Invalid number of ${r}: ${e}. Allowed numbers: ${t.join(", ")}`)};function Et(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function Mt(e,...t){if(!((r=e)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function At(e,t=1){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}const Tt=BigInt(2**32-1),_t=BigInt(32);function St(e,t=0){return t?{h:Number(e&Tt),l:Number(e>>_t&Tt)}:{h:0|Number(e>>_t&Tt),l:0|Number(e&Tt)}}function kt(e,t=0){let r=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let n=0;n<e.length;n++){const{h:s,l:i}=St(e[n],t);[r[n],o[n]]=[s,i]}return[r,o]}const Ct=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];function Pt(e){for(let r=0;r<e.length;r++)e[r]=(t=e[r])<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;var t}function Lt(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),Mt(e),e}class Nt{clone(){return this._cloneInto()}}const Ot=[],Bt=[],Rt=[],Dt=BigInt(0),Ut=BigInt(1),Vt=BigInt(2),Ft=BigInt(7),qt=BigInt(256),Kt=BigInt(113);for(let e=0,t=Ut,r=1,o=0;e<24;e++){[r,o]=[o,(2*r+3*o)%5],Ot.push(2*(5*o+r)),Bt.push((e+1)*(e+2)/2%64);let n=Dt;for(let e=0;e<7;e++)t=(t<<Ut^(t>>Ft)*Kt)%qt,t&Vt&&(n^=Ut<<(Ut<<BigInt(e))-Ut);Rt.push(n)}const[Ht,$t]=kt(Rt,1),jt=(e,t,r)=>r>32?((e,t,r)=>t<<r-32|e>>>64-r)(e,t,r):((e,t,r)=>e<<r|t>>>32-r)(e,t,r),zt=(e,t,r)=>r>32?((e,t,r)=>e<<r-32|t>>>64-r)(e,t,r):((e,t,r)=>t<<r|e>>>32-r)(e,t,r);class Wt extends Nt{constructor(e,t,r,o=0,n=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=o,this.rounds=n,this.pos=0,this.posOut=0,this.finished=0,this.destroyed=0,Et(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var s;this.state=new Uint8Array(200),this.state32=(s=this.state,new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)))}keccak(){Ct||Pt(this.state32),function(e,t=24){const r=new Uint32Array(10);for(let o=24-t;o<24;o++){for(let t=0;t<10;t++)r[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const o=(t+8)%10,n=(t+2)%10,s=r[n],i=r[n+1],a=jt(s,i,1)^r[o],u=zt(s,i,1)^r[o+1];for(let r=0;r<50;r+=10)e[t+r]^=a,e[t+r+1]^=u}let t=e[2],n=e[3];for(let r=0;r<24;r++){const o=Bt[r],s=jt(t,n,o),i=zt(t,n,o),a=Ot[r];t=e[a],n=e[a+1],e[a]=s,e[a+1]=i}for(let t=0;t<50;t+=10){for(let o=0;o<10;o++)r[o]=e[t+o];for(let o=0;o<10;o++)e[t+o]^=~r[(o+2)%10]&r[(o+4)%10]}e[0]^=Ht[o],e[1]^=$t[o]}r.fill(0)}(this.state32,this.rounds),Ct||Pt(this.state32),this.posOut=0,this.pos=0}update(e){At(this);const{blockLen:t,state:r}=this,o=(e=Lt(e)).length;for(let n=0;n<o;){const s=Math.min(t-this.pos,o-n);for(let t=0;t<s;t++)r[this.pos++]^=e[n++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=1;const{state:e,suffix:t,pos:r,blockLen:o}=this;e[r]^=t,0!=(128&t)&&r===o-1&&this.keccak(),e[o-1]^=128,this.keccak()}writeInto(e){At(this,0),Mt(e),this.finish();const t=this.state,{blockLen:r}=this;for(let o=0,n=e.length;o<n;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,n-o);e.set(t.subarray(this.posOut,this.posOut+s),o),this.posOut+=s,o+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Et(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(function(e,t){Mt(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=1,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:o,rounds:n,enableXOF:s}=this;return e||(e=new Wt(t,r,o,s,n)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=n,e.suffix=r,e.outputLen=o,e.enableXOF=s,e.destroyed=this.destroyed,e}}const Zt=(()=>function(e){const t=t=>e().update(Lt(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}((()=>new Wt(136,1,32))))(),Jt=e=>"object"==typeof e&&null!==e,Qt=e=>Jt(e)&&!(e instanceof RegExp)&&!(e instanceof Error)&&!(e instanceof Date),Gt=Symbol("mapObjectSkip"),Xt=(e,t,r,o=new WeakMap)=>{if(r={deep:0,target:{},...r},o.has(e))return o.get(e);o.set(e,r.target);const{target:n}=r;delete r.target;const s=e=>e.map((e=>Qt(e)?Xt(e,t,r,o):e));if(Array.isArray(e))return s(e);for(const[i,a]of Object.entries(e)){const u=t(i,a,e);if(u===Gt)continue;let[c,l,{shouldRecurse:d=1}={}]=u;"__proto__"!==c&&(r.deep&&d&&Qt(l)&&(l=Array.isArray(l)?s(l):Xt(l,t,r,o)),n[c]=l)}return n};function Yt(e,t,r){if(!Jt(e))throw new TypeError(`Expected an object, got \`${e}\` (${typeof e})`);return Xt(e,t,r)}const er=/[\p{Lu}]/u,tr=/[\p{Ll}]/u,rr=/^[\p{Lu}](?![\p{Lu}])/gu,or=/([\p{Alpha}\p{N}_]|$)/u,nr=/[_.\- ]+/,sr=new RegExp("^"+nr.source),ir=new RegExp(nr.source+or.source,"gu"),ar=new RegExp("\\d+"+or.source,"gu");class ur extends Map{constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"==typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.maxSize=e.maxSize,this.maxAge=e.maxAge||Number.POSITIVE_INFINITY,this.onEviction=e.onEviction,this.cache=new Map,this.oldCache=new Map,this._size=0}_emitEvictions(e){if("function"==typeof this.onEviction)for(const[t,r]of e)this.onEviction(t,r.value)}_deleteIfExpired(e,t){return"number"==typeof t.expiry&&t.expiry<=Date.now()?("function"==typeof this.onEviction&&this.onEviction(e,t.value),this.delete(e)):0}_getOrDeleteIfExpired(e,t){if(0==this._deleteIfExpired(e,t))return t.value}_getItemValue(e,t){return t.expiry?this._getOrDeleteIfExpired(e,t):t.value}_peek(e,t){const r=t.get(e);return this._getItemValue(e,r)}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this._emitEvictions(this.oldCache),this.oldCache=this.cache,this.cache=new Map)}_moveToRecent(e,t){this.oldCache.delete(e),this._set(e,t)}*_entriesAscending(){for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||0==this._deleteIfExpired(t,r)&&(yield e)}for(const e of this.cache){const[t,r]=e;0==this._deleteIfExpired(t,r)&&(yield e)}}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this._getItemValue(e,t)}if(this.oldCache.has(e)){const t=this.oldCache.get(e);if(0==this._deleteIfExpired(e,t))return this._moveToRecent(e,t),t.value}}set(e,t,{maxAge:r=this.maxAge}={}){const o="number"==typeof r&&r!==Number.POSITIVE_INFINITY?Date.now()+r:void 0;return this.cache.has(e)?this.cache.set(e,{value:t,expiry:o}):this._set(e,{value:t,expiry:o}),this}has(e){return this.cache.has(e)?!this._deleteIfExpired(e,this.cache.get(e)):this.oldCache.has(e)?!this._deleteIfExpired(e,this.oldCache.get(e)):0}peek(e){return this.cache.has(e)?this._peek(e,this.cache):this.oldCache.has(e)?this._peek(e,this.oldCache):void 0}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this._entriesAscending()],r=t.length-e;r<0?(this.cache=new Map(t),this.oldCache=new Map,this._size=t.length):(r>0&&this._emitEvictions(t.slice(0,r)),this.oldCache=new Map(t.slice(r)),this.cache=new Map,this._size=0),this.maxSize=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache){const[t,r]=e;0==this._deleteIfExpired(t,r)&&(yield[t,r.value])}for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||0==this._deleteIfExpired(t,r)&&(yield[t,r.value])}}*entriesDescending(){let e=[...this.cache];for(let t=e.length-1;t>=0;--t){const r=e[t],[o,n]=r;0==this._deleteIfExpired(o,n)&&(yield[o,n.value])}e=[...this.oldCache];for(let t=e.length-1;t>=0;--t){const r=e[t],[o,n]=r;this.cache.has(o)||0==this._deleteIfExpired(o,n)&&(yield[o,n.value])}}*entriesAscending(){for(const[e,t]of this._entriesAscending())yield[e,t.value]}get size(){if(!this._size)return this.oldCache.size;let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return Math.min(this._size+e,this.maxSize)}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[r,o]of this.entriesAscending())e.call(t,o,r,this)}get[Symbol.toStringTag](){return JSON.stringify([...this.entriesAscending()])}}const cr=new ur({maxSize:1e5}),lr=e=>!("object"!=typeof e||null===e||e instanceof RegExp||e instanceof Error||e instanceof Date),dr=(e,t={})=>{if(!lr(e))return e;const{exclude:r,pascalCase:o=0,stopPaths:n,deep:s=0,preserveConsecutiveUppercase:i=0}=t,a=new Set(n),u=e=>(t,n)=>{if(s&&lr(n)){const r=void 0===e?t:`${e}.${t}`;a.has(r)||(n=Yt(n,u(r)))}if(!r||!((e,t)=>e.some((e=>"string"==typeof e?e===t:(e.lastIndex=0,e.test(t)))))(r,t)){const e=o?`${t}_`:t;if(cr.has(e))t=cr.get(e);else{const r=function(e,t){if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("Expected the input to be `string | string[]`");if(t={pascalCase:0,preserveConsecutiveUppercase:0,...t},0===(e=Array.isArray(e)?e.map((e=>e.trim())).filter((e=>e.length)).join("-"):e.trim()).length)return"";const r=0==t.locale?e=>e.toLowerCase():e=>e.toLocaleLowerCase(t.locale),o=0==t.locale?e=>e.toUpperCase():e=>e.toLocaleUpperCase(t.locale);return 1===e.length?nr.test(e)?"":t.pascalCase?o(e):r(e):(e!==r(e)&&(e=((e,t,r,o)=>{let n=0,s=0,i=0,a=0;for(let u=0;u<e.length;u++){const c=e[u];a=u>2?"-"===e[u-3]:1,n&&er.test(c)?(e=e.slice(0,u)+"-"+e.slice(u),n=0,i=s,s=1,u++):s&&i&&tr.test(c)&&(!a||o)?(e=e.slice(0,u-1)+"-"+e.slice(u-1),i=s,s=0,n=1):(n=t(c)===c&&r(c)!==c,i=s,s=r(c)===c&&t(c)!==c)}return e})(e,r,o,t.preserveConsecutiveUppercase)),e=e.replace(sr,""),e=t.preserveConsecutiveUppercase?((e,t)=>(rr.lastIndex=0,e.replaceAll(rr,(e=>t(e)))))(e,r):r(e),t.pascalCase&&(e=o(e.charAt(0))+e.slice(1)),((e,t)=>(ir.lastIndex=0,ar.lastIndex=0,e.replaceAll(ar,((r,o,n)=>["_","-"].includes(e.charAt(n+r.length))?r:t(r))).replaceAll(ir,((e,r)=>t(r)))))(e,o))}(t,{pascalCase:o,locale:0,preserveConsecutiveUppercase:i});t.length<100&&cr.set(e,r),t=r}}return[t,n]};return Yt(e,u(void 0))};function hr(e){return"0x"+e.toString("hex")}function pr(e){return Re(e,void 0,"be").lt(W)}const mr=e=>{return t=e,r={deep:1},Array.isArray(t)?Object.keys(t).map((e=>dr(t[e],r))):dr(t,r);var t,r};function fr(e){let r=255;for(;r>=0;){const o=t.Buffer.concat([e,t.Buffer.from([r])]),n=Zt(o);if(32!==n.length)throw new Error("Invalid hash length");if(n[0]=0,pr(t.Buffer.from(n)))return[t.Buffer.from(n),r];r-=1}return null}function yr(e){const t=Zt.create();for(const r of e)t.update(r);const r=t.digest();return r[0]=0,r}function gr(r){const o=r.proof?{a:r.proof.a,b:r.proof.b,c:r.proof.c}:null,n=r.new_address_params.map((e=>({seed:e.seed,addressMerkleTreeRootIndex:e.address_merkle_tree_root_index,addressMerkleTreeAccountIndex:e.address_merkle_tree_account_index,addressQueueAccountIndex:e.address_queue_account_index})));return{proof:o,inputCompressedAccountsWithMerkleContext:r.input_compressed_accounts.map((r=>({compressedAccount:{owner:new e.PublicKey(t.Buffer.alloc(32)),lamports:Re(r.lamports),address:r.address,data:null},merkleContext:{merkleTreePubkeyIndex:r.packedMerkleContext.merkle_tree_pubkey_index,queuePubkeyIndex:r.packedMerkleContext.queue_pubkey_index,leafIndex:r.packedMerkleContext.leaf_index,proveByIndex:r.packedMerkleContext.prove_by_index},rootIndex:r.root_index,readOnly:0}))),outputCompressedAccounts:r.output_compressed_accounts.map((e=>({compressedAccount:{owner:e.compressedAccount.owner,lamports:e.compressedAccount.lamports,address:e.compressedAccount.address,data:e.compressedAccount.data},merkleTreeIndex:e.merkleTreeIndex}))),relayFee:null,newAddressParams:n,compressOrDecompressLamports:r.compress_or_decompress_lamports,isCompress:r.is_compress}}function wr(e,t){return yr([t.toBytes(),...e])}function vr(t,r=de().addressTree){if(32!=t.length)throw new Error("Seed length is not 32 bytes.");const o=r.toBytes(),n=fr(Buffer.from([...o,...t]));if(null===n)throw new Error("DeriveAddressError");const s=n[0];return new e.PublicKey(s)}function xr(e,t){const r=t.slice(),o=e.map((e=>({seed:Array.from(e.seed),addressMerkleTreeRootIndex:e.addressMerkleTreeRootIndex,addressMerkleTreeAccountIndex:0,addressQueueAccountIndex:0})));return e.forEach(((e,t)=>{o[t].addressMerkleTreeAccountIndex=pt(r,e.addressMerkleTreePubkey)})),e.forEach(((e,t)=>{o[t].addressQueueAccountIndex=pt(r,e.addressQueuePubkey)})),{newAddressParamsPacked:o,remainingAccounts:r}}async function br(e,t,r="confirmed"){const o=await e.getLatestBlockhash(r),n={signature:t.toString(),lastValidBlockHeight:o.lastValidBlockHeight,blockhash:o.blockhash};return await e.confirmTransaction(n,r)}function Ir(e,t){return t.includes(e)?t.filter((t=>t.publicKey.toString()!==e.publicKey.toString())):t}function Er(e){const t=Ar(e.ar[0]),r=Ar(e.ar[1]),o=new Uint8Array([...t,...r]),n=Ar(e.bs[0][0]),s=Ar(e.bs[0][1]),i=Ar(e.bs[1][0]),a=Ar(e.bs[1][1]),u=new Uint8Array([...n,...s,...i,...a]),c=Ar(e.krs[0]),l=Ar(e.krs[1]);return{a:o,b:u,c:new Uint8Array([...c,...l])}}function Mr(e){const t=e.a,r=e.b,o=e.c,n=t.slice(0,32),s=Tr(Re(t.slice(32,64),32,"be"))?0:1;n[0]=_r(n[0],s);const i=r.slice(0,64),a=r.slice(64,128),u=function(e,t){const r=W.div(Re(2));return e.lt(r)?1:e.gt(r)?0:t.lt(r)}(Re(a.slice(0,32),32,"be"),Re(a.slice(32,64),32,"be"));i[0]=_r(i[0],u);const c=o.slice(0,32),l=o.slice(32,64),d=Tr(Re(l,32,"be"));return c[0]=_r(c[0],d),{a:Array.from(n),b:Array.from(i),c:Array.from(c)}}function Ar(e){const t=Re(e.startsWith("0x")?e.substring(2):e,"hex");return new Uint8Array(t.toArray("be",32))}function Tr(e){return e.lte(W.sub(e))}function _r(e,t){return t?e:128|e}function Sr(t,r,o,n){const s=new e.TransactionMessage({payerKey:r,recentBlockhash:o,instructions:t}).compileToV0Message(n);return new e.VersionedTransaction(s)}async function kr(e,t,r){const o=await e.sendTransaction(t,r);return await Cr(e,o,r),o}async function Cr(e,t,r){const o=(null==r?void 0:r.commitment)||e.commitment||"confirmed",n=ue(e.rpcEndpoint)?200:1e3;let s=0;await new Promise(((r,i)=>{const a=setInterval((async()=>{var u;s+=n,s>=8e4&&(clearInterval(a),i(new Error(`Transaction ${t}'s confirmation timed out`)));const c=await e.getSignatureStatuses([t]);(null===(u=null==c?void 0:c.value[0])||void 0===u?void 0:u.confirmationStatus)===o&&(clearInterval(a),r(t))}),n)}));const i=await e.getSlot();return await e.confirmTransactionIndexed(i),{context:{slot:i},value:{err:null}}}function Pr(e,t,r,o=[],n){if(o.includes(t))throw new Error("payer must not be in additionalSigners");const s=[t,...o],i=Sr(e,t.publicKey,r,n);return i.sign(s),i}function Lr(e,t){return Nr(e,t)}function Nr(e,t){const r=e.find((e=>e.tree.equals(t)||e.queue.equals(t)));if(!r)throw new Error(`No associated TreeInfo found for tree or queue. Please set activeStateTreeInfos with latest Tree accounts. If you use custom state trees, set manually. Pubkey: ${t.toBase58()}`);if(!r.queue)throw new Error("Queue must not be null for state tree. Please set activeStateTreeInfos with latest Tree accounts. If you use custom state trees, set manually. Pubkey: "+t.toBase58());return r}function Or(e,t=(j.isV2()?exports.TreeType.StateV2:exports.TreeType.StateV1),r=0){const o=e.filter((e=>!e.nextTreeInfo)).filter((e=>e.treeType===t));if(0===o.length)throw new Error("No active state tree infos found for the specified tree type");const n=r?o.length:Math.min(5,o.length),s=Math.floor(Math.random()*n);if(!o[s].queue)throw new Error("Queue must not be null for state tree");return o[s]}async function Br({connection:t,stateTreeLUTPairs:r}){var o;const n=await Promise.all(r.map((async e=>({stateTreeLookupTable:await t.getAddressLookupTable(e.stateTreeLookupTable),nullifyLookupTable:await t.getAddressLookupTable(e.nullifyLookupTable)})))),s=[];for(const{stateTreeLookupTable:t,nullifyLookupTable:r}of n){if(!t.value)throw new Error("State tree lookup table not found");if(!r.value)throw new Error("Nullify table not found");const n=t.value.state.addresses,i=r.value.state.addresses;if(n.length%3!=0)throw new Error("State tree lookup table must have a multiple of 3 addresses");for(let t=0;t<n.length;t+=3){const r=n[t],o=n[t+1],a=n[t+2];let u=null;if(!r||!o||!a)throw new Error("Invalid state tree pubkeys structure");i.map((e=>e.toBase58())).includes(r.toBase58())&&(u={tree:e.PublicKey.default,queue:e.PublicKey.default,cpiContext:e.PublicKey.default,treeType:exports.TreeType.StateV1,nextTreeInfo:null}),s.push({tree:r,queue:o,cpiContext:a,treeType:exports.TreeType.StateV1,nextTreeInfo:u})}for(const t of s)if(null===(o=t.nextTreeInfo)||void 0===o?void 0:o.tree.equals(e.PublicKey.default)){const e=s.find((e=>!e.nextTreeInfo));if(!e)throw new Error("No available tree info found to assign as next tree");t.nextTreeInfo=e}}return s}const Rr=e=>e.reduce(((e,t)=>e.add(Re(t.lamports))),Re(0)),Dr=t.Buffer.from("sol_pool_pda");class Ur{constructor(){}static deriveCompressedSolPda(){const t=[Dr],[r,o]=e.PublicKey.findProgramAddressSync(t,this.programId);return r}static createTransferOutputState(e,t,r){r=Re(r);const o=Rr(e).sub(r);return gt(o),o.eq(Re(0))?[De(t,r)]:(wt(e),[De(e[0].owner,o),De(t,r)])}static createDecompressOutputState(e,t){t=Re(t);const r=Rr(e).sub(t);return gt(r),r.eq(Re(0))?[]:(wt(e),[De(e[0].owner,r)])}static createNewAddressOutputState(e,t,r,o){r=Re(null!=r?r:0);const n=Rr(null!=o?o:[]).sub(r);return gt(n),n.eq(Re(0))||!o?[De(t,r,void 0,e)]:(wt(o),[De(o[0].owner,n),De(t,r,void 0,e)])}static async createAccount({payer:t,newAddressParams:r,newAddress:o,recentValidityProof:n,outputStateTreeInfo:s,inputCompressedAccounts:i,inputStateRootIndices:a,lamports:u}){const c=this.createNewAddressOutputState(o,t,u,i),{packedInputCompressedAccounts:l,packedOutputCompressedAccounts:d,remainingAccounts:h}=yt(null!=i?i:[],null!=a?a:[],c,i&&0!==i.length?void 0:s),{newAddressParamsPacked:p,remainingAccounts:m}=xr([r],h),f=$e({proof:n,inputCompressedAccountsWithMerkleContext:l,outputCompressedAccounts:d,relayFee:null,newAddressParams:p,compressOrDecompressLamports:null,isCompress:0}),y=[...ot(Object.assign(Object.assign({},ie()),{feePayer:t,authority:t,solPoolPda:null,decompressionRecipient:null,systemProgram:e.SystemProgram.programId})),...ft(m)];return new e.TransactionInstruction({programId:this.programId,keys:y,data:f})}static async transfer({payer:t,inputCompressedAccounts:r,toAddress:o,lamports:n,recentInputStateRootIndices:s,recentValidityProof:i}){const a=this.createTransferOutputState(r,o,n),{packedInputCompressedAccounts:u,packedOutputCompressedAccounts:c,remainingAccounts:l}=yt(r,s,a),d=$e({proof:i,inputCompressedAccountsWithMerkleContext:u,outputCompressedAccounts:c,relayFee:null,newAddressParams:[],compressOrDecompressLamports:null,isCompress:0}),h=[...ot(Object.assign(Object.assign({},ie()),{feePayer:t,authority:t,solPoolPda:null,decompressionRecipient:null,systemProgram:e.SystemProgram.programId})),...ft(l)];return new e.TransactionInstruction({programId:this.programId,keys:h,data:d})}static async compress({payer:t,toAddress:r,lamports:o,outputStateTreeInfo:n}){o=Re(o);const s=De(r,o),{packedInputCompressedAccounts:i,packedOutputCompressedAccounts:a,remainingAccounts:u}=yt([],[],[s],n),c=$e({proof:null,inputCompressedAccountsWithMerkleContext:i,outputCompressedAccounts:a,relayFee:null,newAddressParams:[],compressOrDecompressLamports:o,isCompress:1}),l=[...ot(Object.assign(Object.assign({},ie()),{feePayer:t,authority:t,solPoolPda:Ur.deriveCompressedSolPda(),decompressionRecipient:null,systemProgram:e.SystemProgram.programId})),...ft(u)];return new e.TransactionInstruction({programId:this.programId,keys:l,data:c})}static async decompress({payer:t,inputCompressedAccounts:r,toAddress:o,lamports:n,recentInputStateRootIndices:s,recentValidityProof:i}){n=Re(n);const a=this.createDecompressOutputState(r,n),{packedInputCompressedAccounts:u,packedOutputCompressedAccounts:c,remainingAccounts:l}=yt(r,s,a),d=$e({proof:i,inputCompressedAccountsWithMerkleContext:u,outputCompressedAccounts:c,relayFee:null,newAddressParams:[],compressOrDecompressLamports:n,isCompress:0}),h=[...ot(Object.assign(Object.assign({},ie()),{feePayer:t,authority:t,solPoolPda:Ur.deriveCompressedSolPda(),decompressionRecipient:o,systemProgram:e.SystemProgram.programId})),...ft(l)];return new e.TransactionInstruction({programId:this.programId,keys:h,data:d})}}function Vr(e,t){let r=Re(0);t=Re(t);const o=[];e.sort(((e,t)=>t.lamports.cmp(e.lamports)));for(const n of e){if(r.gte(Re(t)))break;r=r.add(n.lamports),o.push(n)}if(r.lt(Re(t)))throw new Error(`Insufficient balance for transfer. Required: ${t.toString()}, available: ${r.toString()}`);return[o,r]}Ur.programId=new e.PublicKey("SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7");class Fr{constructor(e,t,r){this.index=e,this.value=t,this.nextIndex=r}equals(e){return this.value.eq(e.value)}compareTo(e){return this.value.cmp(e.value)}hash(e,t){try{return e.poseidonHash([Re(this.value.toArray("be",32)).toString(),Re(this.nextIndex).toString(),Re(t.toArray("be",32)).toString()])}catch(e){throw new Error("Hashing failed")}}}class qr{constructor(e,t,r){this.newLowElement=e,this.newElement=t,this.newElementNextValue=r}}class Kr{constructor(e,t,r){this.elements=e,this.currentNodeIndex=t,this.highestElementIndex=r}static default(){return new Kr([new Fr(0,Re(0),0)],0,0)}get(e){return this.elements[e]}length(){return Number(this.currentNodeIndex)}isEmpty(){return 0===this.currentNodeIndex}findElement(e){return this.elements.slice(0,this.length()+1).find((t=>t.value===e))}init(){try{const e=Z;return this.append(e)}catch(e){throw new Error(`Failed to initialize IndexedArray: ${e}`)}}findLowElementIndex(e){for(let t=0;t<=this.length();t++){const r=this.elements[t];if(this.elements[r.nextIndex].value.gt(e)&&r.value.lt(e))return t;if(r.value.eq(e))throw new Error("Element already exists in the array")}return this.highestElementIndex}findLowElement(e){const t=this.findLowElementIndex(e);if(void 0===t)return[void 0,void 0];const r=this.elements[t];return[r,this.elements[r.nextIndex].value]}hashElement(e,t){const r=this.elements[t];if(!r)return;const o=this.elements[r.nextIndex];return o?e.poseidonHash([Re(r.value.toArray("be",32)).toString(),Re(r.nextIndex).toString(),Re(o.value.toArray("be",32)).toString()]):void 0}append(e){const t=this.findLowElementIndex(e);if(void 0===t)throw new Error("Low element index not found.");return this.appendWithLowElementIndex(t,e)}appendWithLowElementIndex(e,t){const r=this.elements[e];if(0===r.nextIndex){if(t.lte(r.value))throw new Error("New element value must be greater than the low element value.")}else{const e=this.elements[r.nextIndex];if(t.lte(r.value))throw new Error("New element value must be greater than the low element value.");if(t.gte(e.value))throw new Error("New element value must be less than the next element value.")}const o=this.newElementWithLowElementIndex(e,t);return 0===r.nextIndex&&(this.highestElementIndex=o.newElement.index),this.currentNodeIndex=o.newElement.index,this.elements[this.length()]=o.newElement,this.elements[e]=o.newLowElement,o}lowest(){return this.elements.length>0?this.elements[0]:void 0}newElementWithLowElementIndex(e,t){const r=this.elements[e],o=this.currentNodeIndex+1,n=new Fr(o,t,r.nextIndex);r.nextIndex=o;const s=this.elements[n.nextIndex].value;return new qr(r,n,s)}newElement(e){const t=this.findLowElementIndex(e);if(void 0===t)throw new Error("Low element index not found.");return this.newElementWithLowElementIndex(t,e)}}class Hr{constructor(e,t,r=[],{zeroElement:o="0"}={}){if(this.levels=e,this.capacity=2**e,this.zeroElement=o,this._lightWasm=t,r.length>this.capacity)throw new Error("Tree is full");this._zeros=[],this._layers=[],this._layers[0]=r,this._zeros[0]=this.zeroElement;for(let t=1;t<=e;t++)this._zeros[t]=this._lightWasm.poseidonHashString([this._zeros[t-1],this._zeros[t-1]]);this._rebuild()}_rebuild(){for(let e=1;e<=this.levels;e++){this._layers[e]=[];for(let t=0;t<Math.ceil(this._layers[e-1].length/2);t++)this._layers[e][t]=this._lightWasm.poseidonHashString([this._layers[e-1][2*t],2*t+1<this._layers[e-1].length?this._layers[e-1][2*t+1]:this._zeros[e-1]])}}root(){return this._layers[this.levels].length>0?this._layers[this.levels][0]:this._zeros[this.levels]}insert(e){if(this._layers[0].length>=this.capacity)throw new Error("Tree is full");this.update(this._layers[0].length,e)}bulkInsert(e){if(this._layers[0].length+e.length>this.capacity)throw new Error("Tree is full");this._layers[0].push(...e),this._rebuild()}update(e,t){if(isNaN(Number(e))||e<0||e>this._layers[0].length||e>=this.capacity)throw new Error("Insert index out of bounds: "+e);this._layers[0][e]=t;for(let t=1;t<=this.levels;t++)e>>=1,this._layers[t][e]=this._lightWasm.poseidonHashString([this._layers[t-1][2*e],2*e+1<this._layers[t-1].length?this._layers[t-1][2*e+1]:this._zeros[t-1]])}path(e){if(isNaN(Number(e))||e<0||e>=this._layers[0].length)throw new Error("Index out of bounds: "+e);const t=[],r=[];for(let o=0;o<this.levels;o++)r[o]=e%2,t[o]=(1^e)<this._layers[o].length?this._layers[o][1^e]:this._zeros[o],e>>=1;return{pathElements:t,pathIndices:r}}indexOf(e,t=null){return t?this._layers[0].findIndex((r=>t(e,r))):this._layers[0].indexOf(e)}elements(){return this._layers[0].slice()}serialize(){return{levels:this.levels,_zeros:this._zeros,_layers:this._layers}}static deserialize(e,t){const r=Object.assign(Object.create(this.prototype),e);return r._hash=t,r.capacity=2**r.levels,r.zeroElement=r._zeros[0],r}}async function $r(e){const t=[],{noopProgram:r,accountCompressionProgram:o}=ie(),n=(await e.getSignaturesForAddress(o,void 0,"confirmed")).map((e=>e.signature)),s=await e.getParsedTransactions(n,{maxSupportedTransactionVersion:0,commitment:"confirmed"});for(const t of s){if(!t||!t.transaction||!t.meta)continue;if(!t.meta.innerInstructions||0==t.meta.innerInstructions.length)continue;const r=t.transaction.message.accountKeys.map((e=>e.pubkey)),o=await e.getTransaction(t.transaction.signatures[0],{commitment:"confirmed",maxSupportedTransactionVersion:0});for(const e of(null==o?void 0:o.transaction.message.compiledInstructions)||[])if(e.data&&e.data.length>0){const t=Uint8Array.from(e.data);if(t.length===J.length&&J.every(((e,r)=>e===t[r])))continue}if(o.meta.innerInstructions&&o.meta.innerInstructions.length>0)for(const e of o.meta.innerInstructions)for(const t of e.instructions)t.accounts.map((e=>r[e])),t.data&&t.data.length>0&&Ne.decode(t.data)}if(t.length>0)return t;const i=s.filter((e=>e?e.transaction.message.accountKeys.some((e=>("string"==typeof e?e:e.pubkey.toBase58())===r.toBase58())):0));return jr(i,zr)}const jr=(e,r)=>{const{noopProgram:o}=ie(),n=[];return e.forEach((e=>{!e||!e.meta||e.meta.err||!e.meta.innerInstructions||e.meta.innerInstructions.length<=0||e.meta.innerInstructions.forEach((s=>{if(s.instructions.length>0){const i=s.instructions[s.instructions.length-1];if("data"in i&&i.data&&i.programId.toBase58()===o.toBase58()){const o=Ne.decode(i.data),s=r(t.Buffer.from(o),e);null!=s&&n.push(s)}}}))})),n},zr=e=>{const r=t.Buffer.from(e.map((e=>e)));try{return st(r)}catch(e){return console.error("Error deserializing event:",e),null}};async function Wr(e,t){return(await Zr(e)).find((e=>Re(e.hash).eq(t)))}async function Zr(e){var t,r;const o=(await $r(e)).reverse(),n=[],s=[],i=await e.getStateTreeInfos();for(const e of o){for(let o=0;o<e.outputCompressedAccounts.length;o++){const s=Lr(i,e.pubkeyArray[e.outputCompressedAccounts[o].merkleTreeIndex]),a=e.outputCompressedAccounts[o],u={treeInfo:s,hash:Re(e.outputCompressedAccountHashes[o]),leafIndex:e.outputLeafIndices[o],proveByIndex:s.treeType===exports.TreeType.StateV2},c=Ue(u,a.compressedAccount.owner,a.compressedAccount.lamports,null!==(t=a.compressedAccount.data)&&void 0!==t?t:void 0,null!==(r=a.compressedAccount.address)&&void 0!==r?r:void 0);n.push(c)}for(let t=0;t<e.inputCompressedAccountHashes.length;t++){const r=e.inputCompressedAccountHashes[t];s.push(Re(r))}}const a=n.filter((e=>!s.some((t=>t.eq(Re(e.hash))))));return a.sort(((e,t)=>t.leafIndex-e.leafIndex)),a}const Jr=n.struct([n.publicKey("mint"),n.publicKey("owner"),n.u64("amount"),n.option(n.publicKey(),"delegate"),n.u8("state"),n.option(n.vecU8(),"tlv")]);function Qr(e,t=he){if(null===e.data)return null;const{data:r}=e.data;if(0===r.length)return null;if(e.owner.toBase58()!==t.toBase58())throw new Error(`Invalid owner ${e.owner.toBase58()} for token layout`);try{return Jr.decode(Buffer.from(r))}catch(e){throw console.error("Decoding error:",e),e}}async function Gr(e,t){const r=await Promise.all(e.map((e=>async function(e,t){const r=e.pubkeyArray,o=await t.getStateTreeInfos(),n=e.outputCompressedAccountHashes,s=e.outputCompressedAccounts.map(((t,s)=>{var i;const a=r[e.outputCompressedAccounts[s].merkleTreeIndex],u=Lr(o,a);if(!(u.tree.equals(r[e.outputCompressedAccounts[s].merkleTreeIndex])||j.isV2()&&u.queue.equals(r[e.outputCompressedAccounts[s].merkleTreeIndex])))throw new Error("Invalid tree");const c={treeInfo:u,hash:Re(n[s]),leafIndex:e.outputLeafIndices[s],proveByIndex:u.treeType===exports.TreeType.StateV2};if(!t.compressedAccount.data)throw new Error("No data");const l=Qr(t.compressedAccount);if(!l)throw new Error("Invalid token data");return{compressedAccount:Ue(c,t.compressedAccount.owner,t.compressedAccount.lamports,t.compressedAccount.data,null!==(i=t.compressedAccount.address)&&void 0!==i?i:void 0),parsed:l}}));return{inputCompressedAccountHashes:e.inputCompressedAccountHashes,outputCompressedAccounts:s}}(e,t)))),o=r.flatMap((e=>e.outputCompressedAccounts)),n=r.flatMap((e=>e.inputCompressedAccountHashes));return o.filter((e=>!n.some((t=>Re(t).eq(e.compressedAccount.hash)))))}async function Xr(e,t,r){const o=await $r(e);return{items:(await Gr(o,e)).filter((e=>e.parsed.owner.equals(t)&&e.parsed.mint.equals(r))).sort(((e,t)=>e.compressedAccount.leafIndex-t.compressedAccount.leafIndex)),cursor:null}}async function Yr(e,t,r){const o=await $r(e);return{items:(await Gr(o,e)).filter((e=>{var o;return(null===(o=e.parsed.delegate)||void 0===o?void 0:o.equals(t))&&e.parsed.mint.equals(r)})),cursor:null}}async function eo(e,t){const r=await $r(e),o=(await Gr(r,e)).filter((e=>Re(e.compressedAccount.hash).eq(t)));if(0===o.length)throw new Error("No compressed account found");return o[0]}class to extends TypeError{constructor(e,t){let r;const{message:o,explanation:n,...s}=e,{path:i}=e,a=0===i.length?o:`At path: ${i.join(".")} -- ${o}`;super(n??a),null!=n&&(this.cause=a),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function ro(e){return"object"==typeof e&&null!=e}function oo(e){return ro(e)&&!Array.isArray(e)}function no(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function so(e,t,r,o){if(1==e)return;0==e?e={}:"string"==typeof e&&(e={message:e});const{path:n,branch:s}=t,{type:i}=r,{refinement:a,message:u=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${no(o)}\``}=e;return{value:o,type:i,refinement:a,key:n[n.length-1],path:n,branch:s,...e,message:u}}function*io(e,t,r,o){var n;ro(n=e)&&"function"==typeof n[Symbol.iterator]||(e=[e]);for(const n of e){const e=so(n,t,r,o);e&&(yield e)}}function*ao(e,t,r={}){const{path:o=[],branch:n=[e],coerce:s=0,mask:i=0}=r,a={path:o,branch:n,mask:i};s&&(e=t.coercer(e,a));let u="valid";for(const o of t.validator(e,a))o.explanation=r.message,u="not_valid",yield[o,void 0];for(let[c,l,d]of t.entries(e,a)){const t=ao(l,d,{path:void 0===c?o:[...o,c],branch:void 0===c?n:[...n,l],coerce:s,mask:i,message:r.message});for(const r of t)r[0]?(u=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(l=r[1],void 0===c?e=l:e instanceof Map?e.set(c,l):e instanceof Set?e.add(l):ro(e)&&(void 0!==l||c in e)&&(e[c]=l))}if("not_valid"!==u)for(const o of t.refiner(e,a))o.explanation=r.message,u="not_refined",yield[o,void 0];"valid"===u&&(yield[void 0,e])}class uo{constructor(e){const{type:t,schema:r,validator:o,refiner:n,coercer:s=(e=>e),entries:i=function*(){}}=e;this.type=t,this.schema=r,this.entries=i,this.coercer=s,this.validator=o?(e,t)=>io(o(e,t),t,this,e):()=>[],this.refiner=n?(e,t)=>io(n(e,t),t,this,e):()=>[]}assert(e,t){return function(e,t,r){const o=ho(e,t,{message:r});if(o[0])throw o[0]}(e,this,t)}create(e,t){return co(e,this,t)}is(e){return lo(e,this)}mask(e,t){return function(e,t,r){const o=ho(e,t,{coerce:1,mask:1,message:r});if(o[0])throw o[0];return o[1]}(e,this,t)}validate(e,t={}){return ho(e,this,t)}}function co(e,t,r){const o=ho(e,t,{coerce:1,message:r});if(o[0])throw o[0];return o[1]}function lo(e,t){return!ho(e,t)[0]}function ho(e,t,r={}){const o=ao(e,t,r),n=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(o);return n[0]?[new to(n[0],(function*(){for(const e of o)e[0]&&(yield e[0])})),void 0]:[void 0,n[1]]}function po(e,t){return new uo({type:e,schema:null,validator:t})}function mo(){return po("any",(()=>1))}function fo(e){return new uo({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,o]of t.entries())yield[r,o,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${no(e)}`})}function yo(){return po("boolean",(e=>"boolean"==typeof e))}function go(e){return po("instance",(t=>t instanceof e||`Expected a \`${e.name}\` instance, but received: ${no(t)}`))}function wo(e){const t=no(e);return new uo({type:"literal",schema:e,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${no(r)}`})}function vo(e){return new uo({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function xo(){return po("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${no(e)}`))}function bo(){return po("string",(e=>"string"==typeof e||`Expected a string, but received: ${no(e)}`))}function Io(e){const t=Object.keys(e);return new uo({type:"type",schema:e,*entries(r){if(ro(r))for(const o of t)yield[o,r[o],e[o]]},validator:e=>oo(e)||`Expected an object, but received: ${no(e)}`,coercer:e=>oo(e)?{...e}:e})}function Eo(e){const t=e.map((e=>e.type)).join(" | ");return new uo({type:"union",schema:null,coercer(t,r){for(const o of e){const[e,n]=o.validate(t,{coerce:1,mask:r.mask});if(!e)return n}return t},validator(r,o){const n=[];for(const t of e){const[...e]=ao(r,t,o),[s]=e;if(!s[0])return[];for(const[t]of e)t&&n.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${no(r)}`,...n]}})}function Mo(){return po("unknown",(()=>1))}function Ao(e,t,r){return new uo({...e,coercer:(o,n)=>lo(o,t)?e.coercer(r(o,n),n):e.coercer(o,n)})}const To=Ao(go(e.PublicKey),bo(),(t=>new e.PublicKey(t))),_o=Ao(go(Array),bo(),(t=>Array.from(new e.PublicKey(t).toBytes()))),So=Ao(go($),bo(),(e=>Oe(e,"base58"))),ko=Ao(go($),Eo([bo(),xo()]),(e=>{if("number"==typeof e){if(!Number.isSafeInteger(e))throw new Error(`Unsafe integer. Precision loss: ${e}`);return Re(e)}return Re(e,10)})),Co=Ao(bo(),bo(),(e=>""===e?null:e));function Po(e){return Eo([Io({jsonrpc:wo("2.0"),id:bo(),result:e}),Io({jsonrpc:wo("2.0"),id:bo(),error:Io({code:Mo(),message:bo(),data:vo(mo())})})])}const Lo=Po(Mo());function No(e){return Ao(Po(e),Lo,(t=>"error"in t?t:Object.assign(Object.assign({},t),{result:co(t.result,e)})))}function Oo(e){return No(Io({context:Io({slot:xo()}),value:e}))}const Bo=Io({treeType:xo(),tree:To,queue:To,cpiContext:vo(To)}),Ro=Io({treeType:xo(),tree:To,queue:To,cpiContext:vo(To),nextTreeContext:(Do=vo(Bo),new uo({...Do,validator:(e,t)=>void 0===e||Do.validator(e,t),refiner:(e,t)=>void 0===e||Do.refiner(e,t)}))});var Do;const Uo=Io({address:vo(_o),hash:So,data:vo(Io({data:Co,dataHash:So,discriminator:ko})),lamports:ko,owner:To,leafIndex:xo(),tree:To,seq:vo(ko),slotCreated:ko}),Vo=Io({address:vo(_o),hash:So,data:vo(Io({data:Co,dataHash:So,discriminator:ko})),lamports:ko,owner:To,leafIndex:xo(),seq:vo(ko),slotCreated:ko,merkleContext:Ro,proveByIndex:yo()}),Fo=Io({mint:To,owner:To,amount:ko,delegate:vo(To),state:bo()}),qo=Io({tokenData:Fo,account:Uo}),Ko=Io({tokenData:Fo,account:Vo}),Ho=Io({items:fo(Uo)}),$o=Io({items:fo(Vo)}),jo=Io({items:fo(Uo),cursor:vo(bo())}),zo=Io({items:fo(Vo),cursor:vo(bo())}),Wo=Io({items:fo(qo),cursor:vo(bo())}),Zo=Io({items:fo(Ko),cursor:vo(bo())}),Jo=xo(),Qo=bo(),Go=Io({items:fo(Io({signature:bo(),slot:xo(),blockTime:xo(),error:vo(bo())}))}),Xo=Io({items:fo(Io({signature:bo(),slot:xo(),blockTime:xo()})),cursor:vo(bo())}),Yo=Io({hash:So,leafIndex:xo(),merkleTree:To,proof:fo(So),rootSeq:xo(),root:So}),en=Io({hash:So,leafIndex:xo(),proof:fo(So),root:So,rootSeq:xo(),proveByIndex:yo(),treeContext:Ro}),tn=Io({address:So,nextIndex:xo(),merkleTree:To,proof:fo(So),rootSeq:xo(),root:So,lowerRangeAddress:So,higherRangeAddress:So,lowElementLeafIndex:xo()}),rn=Io({a:fo(xo()),b:fo(xo()),c:fo(xo())}),on=Io({rootIndex:xo(),proveByIndex:yo()}),nn=Io({compressedProof:rn,leafIndices:fo(xo()),leaves:fo(So),rootIndices:fo(xo()),roots:fo(So),merkleTrees:fo(To)}),sn=Io({hash:So,root:So,rootIndex:on,merkleContext:Ro,leafIndex:xo()}),an=Io({address:So,root:So,rootIndex:xo(),merkleContext:Ro}),un=Io({compressedProof:vo(rn),accounts:fo(sn),addresses:fo(an)}),cn=fo(Yo),ln=fo(en),dn=Io({amount:ko}),hn=ko,pn=Io({balance:ko,mint:To}),mn=Io({tokenBalances:fo(pn),cursor:vo(bo())}),fn=Io({items:fo(pn),cursor:vo(bo())}),yn=Io({cursor:vo(bo()),items:fo(Io({balance:ko,owner:To}))}),gn=Io({hash:fo(xo()),root:fo(xo()),proof:fo(fo(xo()))}),wn=Io({items:fo(Io({blockTime:xo(),signature:bo(),slot:xo()}))}),vn=Io({items:fo(Io({blockTime:xo(),signature:bo(),slot:xo()})),cursor:vo(bo())}),xn=Io({account:Vo,txHash:So,nullifier:So}),bn=Io({compressionInfo:Io({closedAccounts:fo(Io({account:Uo,optionalTokenData:vo(Fo)})),openedAccounts:fo(Io({account:Uo,optionalTokenData:vo(Fo)}))}),transaction:mo()}),In=Io({compressionInfo:Io({closedAccounts:fo(Io({account:xn,optionalTokenData:vo(Fo)})),openedAccounts:fo(Io({account:Vo,optionalTokenData:vo(Fo)}))}),transaction:mo()});function En({discriminator:e,data:r,dataHash:o}){return{discriminator:e.toArray("le",8),data:t.Buffer.from(r,"base64"),dataHash:o.toArray("le",32)}}async function Mn(t,r,o,n=0){var s,i;const a=z(n?"getCompressedTokenAccountsByDelegate":"getCompressedTokenAccountsByOwner"),u=n?"delegate":"owner",c=await Tn(t.compressionApiEndpoint,a,{[u]:r.toBase58(),mint:null===(s=o.mint)||void 0===s?void 0:s.toBase58(),limit:null===(i=o.limit)||void 0===i?void 0:i.toNumber(),cursor:o.cursor});let l;if(l=j.isV2()?co(c,Oo(Zo)):co(c,Oo(Wo)),"error"in l)throw new e.SolanaJSONRPCError(l.error,`failed to get info for compressed accounts by ${u} ${r.toBase58()}`);if(null===l.result.value)throw new Error("not implemented: NULL result");const d=[],h=await t.getStateTreeInfos();return l.result.value.items.map((e=>{var t;const o=e.account,n=e.tokenData,s=j.isV2()?o.merkleContext.tree:o.tree,i=j.isV2()?o.proveByIndex:0,a=Lr(h,s),c=Ue(Ve(a,o.hash,o.leafIndex,i),o.owner,Re(o.lamports),o.data?En(o.data):void 0,o.address||void 0),l={mint:n.mint,owner:n.owner,amount:n.amount,delegate:n.delegate,state:["uninitialized","initialized","frozen"].indexOf(n.state),tlv:null};if((null===(t=l[u])||void 0===t?void 0:t.toBase58())!==r.toBase58())throw new Error(`RPC returned token account with ${u} different from requested ${u}`);d.push({compressedAccount:c,parsed:l})})),{items:d.sort(((e,t)=>t.compressedAccount.leafIndex-e.compressedAccount.leafIndex)),cursor:l.result.value.cursor}}function An(e){return e.replace(/(":\s*)(-?\d+)(\s*[},])/g,((e,t,r,o)=>{const n=Number(r);return!Number.isNaN(n)&&(n>Number.MAX_SAFE_INTEGER||n<Number.MIN_SAFE_INTEGER)?`${t}"${r}"${o}`:e}))}const Tn=async(e,t,r=[],o=1,n=0)=>{const s=JSON.stringify({jsonrpc:"2.0",id:"test-account",method:t,params:r});if(n){const t=()=>{const t=s.replace(/"/g,'\\"');return`curl -X POST ${e} \\\n     -H "Content-Type: application/json" \\\n     -d "${t}"`};console.log("Debug: Stack trace:"),console.log((new Error).stack),console.log("\nDebug: curl:"),console.log(t()),console.log("\n")}const i=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:s});if(!i.ok)throw new Error(`HTTP error! status: ${i.status}`);const a=An(await i.text());return o?mr(JSON.parse(a)):JSON.parse(a)},_n=async(e,t,r=[],o=0)=>{let n,s="";o&&(s=`Proof generation for method:${t}`,console.time(s)),"inclusion"===t?n=JSON.stringify({circuitType:"inclusion",stateTreeHeight:26,inputCompressedAccounts:r}):"new-address"===t?n=JSON.stringify({circuitType:"non-inclusion",addressTreeHeight:26,newAddresses:r}):"combined"===t&&(n=JSON.stringify({circuitType:"combined",stateTreeHeight:26,addressTreeHeight:26,inputCompressedAccounts:r[0],newAddresses:r[1]}));const i=await fetch(`${e}/prove`,{method:"POST",headers:{"Content-Type":"application/json"},body:n});if(!i.ok)throw new Error(`Error fetching proof: ${i.statusText}`);const a=Mr(Er(await i.json()));return o&&console.timeEnd(s),a};function Sn(e){const t=[];for(let r=0;r<e.length;r++){const o={root:hr(e[r].root),pathIndex:e[r].leafIndex,pathElements:e[r].merkleProof.map((e=>hr(e))),leaf:hr(Re(e[r].hash))};t.push(o)}return t}function kn(e){const t=[];for(let r=0;r<e.length;r++){const o={root:hr(e[r].root),value:hr(e[r].value),pathIndex:e[r].indexHashedIndexedElementLeaf.toNumber(),pathElements:e[r].merkleProofHashedIndexedElementLeaf.map((e=>hr(e))),nextIndex:e[r].nextIndex.toNumber(),leafLowerRangeValue:hr(e[r].leafLowerRangeValue),leafHigherRangeValue:hr(e[r].leafHigherRangeValue)};t.push(o)}return t}function Cn(e,t,r){if(e.length!==t.length)throw new Error("Input lengths must match.");if(0===e.length)return Re(0);let o=r.poseidonHashBN([e[0].toString(),t[0].toString()]);for(let n=1;n<e.length;n++)o=r.poseidonHashBN([o.toString(),e[n].toString(),t[n].toString()]);return o}function Pn(e){const t=e.account,r=e.optionalTokenData,o=Ue(Ve(t.treeInfo,t.hash.toArray("be",32),t.leafIndex,t.proveByIndex),t.owner,Re(t.lamports),t.data?En(t.data):void 0,t.address||void 0);return null===r?{account:o,maybeTokenData:null}:{account:o,maybeTokenData:{mint:r.mint,owner:r.owner,amount:r.amount,delegate:r.delegate,state:["uninitialized","initialized","frozen"].indexOf(r.state),tlv:null}}}class Ln extends e.Connection{constructor(e,t,r,o){super(e,o||"confirmed"),this.allStateTreeInfos=null,this.lastStateTreeFetchTime=null,this.CACHE_TTL=36e5,this.fetchPromise=null,this.compressionApiEndpoint=t,this.proverEndpoint=r}async getCachedActiveStateTreeInfo(){}async getCachedActiveStateTreeInfos(){}async getStateTreeInfos(){if(ue(this.rpcEndpoint))return ce();if(this.allStateTreeInfos&&this.lastStateTreeFetchTime&&Date.now()-this.lastStateTreeFetchTime<=this.CACHE_TTL)return this.allStateTreeInfos;if(this.fetchPromise)return this.fetchPromise;let e;try{return this.fetchPromise=this.doFetch(),e=await this.fetchPromise,this.allStateTreeInfos=e,this.lastStateTreeFetchTime=Date.now(),e}finally{this.fetchPromise=null}}async doFetch(){const{mainnet:e,devnet:t}=ae();try{return await Br({connection:this,stateTreeLUTPairs:[e[0]]})}catch(e){try{return await Br({connection:this,stateTreeLUTPairs:[t[0]]})}catch(t){throw new Error(`Failed to fetch state tree infos from both mainnet and devnet. Mainnet error: ${e}. Devnet error: ${t}`)}}}async getCompressedAccount(t,r){if(!r&&!t)throw new Error("Either hash or address must be provided");if(r&&t)throw new Error("Only one of hash or address must be provided");const o=await this.getStateTreeInfos(),n=await Tn(this.compressionApiEndpoint,z("getCompressedAccount"),{hash:r?Be(r):void 0,address:t?Be(t):void 0});let s;if(s=j.isV2()?co(n,Oo(vo(Vo))):co(n,Oo(vo(Uo))),"error"in s)throw new e.SolanaJSONRPCError(s.error,`failed to get info for compressed account ${r?r.toString():t?t.toString():""}`);if(null===s.result.value)return null;const i=Lr(o,j.isV2()?s.result.value.merkleContext.tree:s.result.value.tree),a=s.result.value;return Ue(Ve(i,a.hash,a.leafIndex),a.owner,Re(a.lamports),a.data?En(a.data):void 0,a.address||void 0)}async getCompressedBalance(t,r){if(!r&&!t)throw new Error("Either hash or address must be provided");if(r&&t)throw new Error("Only one of hash or address must be provided");const o=co(await Tn(this.compressionApiEndpoint,"getCompressedBalance",{hash:r?Be(r):void 0,address:t?Be(t):void 0}),Oo(hn));if("error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get balance for compressed account ${r?r.toString():t?t.toString():""}`);return null===o.result.value?Re(0):Re(o.result.value)}async getCompressedBalanceByOwner(t){const r=co(await Tn(this.compressionApiEndpoint,"getCompressedBalanceByOwner",{owner:t.toBase58()}),Oo(hn));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get balance for compressed account ${t.toBase58()}`);return null===r.result.value?Re(0):Re(r.result.value)}async getCompressedAccountProof(t){const r=await Tn(this.compressionApiEndpoint,z("getCompressedAccountProof"),{hash:Be(t)});let o;if(o=j.isV2()?co(r,Oo(en)):co(r,Oo(Yo)),"error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get proof for compressed account ${t.toString()}`);if(null===o.result.value)throw new Error(`failed to get proof for compressed account ${t.toString()}`);const n=Lr(await this.getStateTreeInfos(),j.isV2()?o.result.value.treeContext.tree:o.result.value.tree);return{hash:Re(o.result.value.hash.toArray("be",32)),treeInfo:n,leafIndex:o.result.value.leafIndex,merkleProof:o.result.value.proof,rootIndex:o.result.value.rootSeq%2400,root:o.result.value.root,proveByIndex:j.isV2()?o.result.value.proveByIndex:0}}async getMultipleCompressedAccounts(t){const r=await Tn(this.compressionApiEndpoint,z("getMultipleCompressedAccounts"),{hashes:t.map((e=>Be(e)))});let o;if(o=j.isV2()?co(r,Oo($o)):co(r,Oo(Ho)),"error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get info for compressed accounts ${t.map((e=>Be(e))).join(", ")}`);if(null===o.result.value)throw new Error(`failed to get info for compressed accounts ${t.map((e=>Be(e))).join(", ")}`);const n=await this.getStateTreeInfos(),s=[];return o.result.value.items.map((e=>{const t=j.isV2()?e.merkleContext.tree:e.tree,r=Lr(n,t),o=Ue(Ve(r,Re(e.hash.toArray("be",32)),e.leafIndex),e.owner,Re(e.lamports),e.data?En(e.data):void 0,e.address||void 0);s.push(o)})),s.sort(((e,t)=>t.leafIndex-e.leafIndex))}async getMultipleCompressedAccountProofs(t){const r=await Tn(this.compressionApiEndpoint,z("getMultipleCompressedAccountProofs"),t.map((e=>Be(e))));let o;if(o=j.isV2()?co(r,Oo(fo(en))):co(r,Oo(fo(Yo))),"error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get proofs for compressed accounts ${t.map((e=>Be(e))).join(", ")}`);if(null===o.result.value)throw new Error(`failed to get proofs for compressed accounts ${t.map((e=>Be(e))).join(", ")}`);const n=[],s=await this.getStateTreeInfos();for(const e of o.result.value){const t=Lr(s,j.isV2()?e.treeContext.tree:e.merkleTree),r={hash:Re(e.hash.toArray("be",32)),treeInfo:t,leafIndex:e.leafIndex,merkleProof:e.proof,rootIndex:e.rootSeq%2400,root:e.root,proveByIndex:j.isV2()?e.proveByIndex:0};n.push(r)}return n}async getCompressedAccountsByOwner(t,r){var o;const n=await Tn(this.compressionApiEndpoint,z("getCompressedAccountsByOwner"),{owner:t.toBase58(),filters:(null==r?void 0:r.filters)||[],dataSlice:null==r?void 0:r.dataSlice,cursor:null==r?void 0:r.cursor,limit:null===(o=null==r?void 0:r.limit)||void 0===o?void 0:o.toNumber()});let s;if(s=j.isV2()?co(n,Oo(zo)):co(n,Oo(jo)),"error"in s)throw new e.SolanaJSONRPCError(s.error,`failed to get info for compressed accounts owned by ${t.toBase58()}`);if(null===s.result.value)return{items:[],cursor:null};const i=[],a=await this.getStateTreeInfos();return s.result.value.items.map((e=>{const t=Lr(a,j.isV2()?e.merkleContext.tree:e.tree),r=Ue(Ve(t,Re(e.hash.toArray("be",32)),e.leafIndex,j.isV2()?e.proveByIndex:0),e.owner,Re(e.lamports),e.data?En(e.data):void 0,e.address||void 0);i.push(r)})),{items:i.sort(((e,t)=>t.leafIndex-e.leafIndex)),cursor:s.result.value.cursor}}async getCompressedTokenAccountsByOwner(e,t){return t||(t={}),await Mn(this,e,t,0)}async getCompressedTokenAccountsByDelegate(e,t){return t||(t={}),await Mn(this,e,t,1)}async getCompressedTokenAccountBalance(t){const r=co(await Tn(this.compressionApiEndpoint,"getCompressedTokenAccountBalance",{hash:Be(t)}),Oo(dn));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get balance for compressed token account ${t.toString()}`);if(null===r.result.value)throw new Error(`failed to get balance for compressed token account ${t.toString()}`);return{amount:Re(r.result.value.amount)}}async getCompressedTokenBalancesByOwner(t,r){var o,n;r||(r={});const s=co(await Tn(this.compressionApiEndpoint,"getCompressedTokenBalancesByOwner",{owner:t.toBase58(),mint:null===(o=r.mint)||void 0===o?void 0:o.toBase58(),limit:null===(n=r.limit)||void 0===n?void 0:n.toNumber(),cursor:r.cursor}),Oo(mn));if("error"in s)throw new e.SolanaJSONRPCError(s.error,`failed to get compressed token balances for owner ${t.toBase58()}`);if(null===s.result.value)throw new Error(`failed to get compressed token balances for owner ${t.toBase58()}`);return{items:r.mint?s.result.value.tokenBalances.filter((e=>e.mint.toBase58()===r.mint.toBase58())):s.result.value.tokenBalances,cursor:s.result.value.cursor}}async getCompressedTokenBalancesByOwnerV2(t,r){var o,n;r||(r={});const s=co(await Tn(this.compressionApiEndpoint,"getCompressedTokenBalancesByOwnerV2",{owner:t.toBase58(),mint:null===(o=r.mint)||void 0===o?void 0:o.toBase58(),limit:null===(n=r.limit)||void 0===n?void 0:n.toNumber(),cursor:r.cursor}),Oo(fn));if("error"in s)throw new e.SolanaJSONRPCError(s.error,`failed to get compressed token balances for owner ${t.toBase58()}`);if(null===s.result.value)throw new Error(`failed to get compressed token balances for owner ${t.toBase58()}`);const i=r.mint?s.result.value.items.filter((e=>e.mint.toBase58()===r.mint.toBase58())):s.result.value.items;return{context:s.result.context,value:{items:i,cursor:s.result.value.cursor}}}async getCompressionSignaturesForAccount(t){const r=co(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForAccount",{hash:Be(t)}),Oo(wn));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get signatures for compressed account ${t.toString()}`);return r.result.value.items}async getTransactionWithCompressionInfo(t){const r=await Tn(this.compressionApiEndpoint,z("getTransactionWithCompressionInfo"),{signature:t});let o;if(o=j.isV2()?co(r,No(In)):co(r,No(bn)),"error"in o)throw new e.SolanaJSONRPCError(o.error,"failed to get slot");if(null===o.result.transaction)return null;const n=[],s=[],i=await this.getStateTreeInfos();j.isV2()?(o.result.compressionInfo.closedAccounts.map((e=>{n.push(function(e){const t={account:e.account.account,optionalTokenData:e.optionalTokenData},r={nullifier:e.account.nullifier,txHash:e.account.txHash},o=Pn(t);return{account:o.account,maybeTokenData:o.maybeTokenData,maybeNullifierMetadata:r}}(e))})),o.result.compressionInfo.openedAccounts.map((e=>{s.push(Pn(e))}))):(o.result.compressionInfo.closedAccounts.map((e=>{const t=Lr(i,e.account.tree),r=Ue(Ve(t,Re(e.account.hash.toArray("be",32)),e.account.leafIndex),e.account.owner,Re(e.account.lamports),e.account.data?En(e.account.data):void 0,e.account.address||void 0);n.push({account:r,maybeTokenData:e.optionalTokenData})})),o.result.compressionInfo.openedAccounts.map((e=>{const t=Lr(i,e.account.tree),r=Ue(Ve(t,Re(e.account.hash.toArray("be",32)),e.account.leafIndex),e.account.owner,Re(e.account.lamports),e.account.data?En(e.account.data):void 0,e.account.address||void 0);s.push({account:r,maybeTokenData:e.optionalTokenData})})));const a=e=>{const t=Object.values(e.reduce(((e,{maybeTokenData:t})=>{if(t){const{owner:r,mint:o,amount:n}=t,s=`${r.toBase58()}_${o.toBase58()}`;s in e?e[s].amount=e[s].amount.add(n):e[s]={owner:r,mint:o,amount:n}}return e}),{}));return t.length>0?t:void 0},u=a(n),c=a(s);return{compressionInfo:{closedAccounts:n,openedAccounts:s,preTokenBalances:u,postTokenBalances:c},transaction:o.result.transaction}}async getCompressionSignaturesForAddress(t,r){var o;const n=co(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForAddress",{address:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(o=null==r?void 0:r.limit)||void 0===o?void 0:o.toNumber()}),Oo(vn));if("error"in n)throw new e.SolanaJSONRPCError(n.error,`failed to get signatures for address ${t.toBase58()}`);if(null===n.result.value)throw new Error(`failed to get signatures for address ${t.toBase58()}`);return n.result.value}async getCompressionSignaturesForOwner(t,r){var o;const n=co(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForOwner",{owner:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(o=null==r?void 0:r.limit)||void 0===o?void 0:o.toNumber()}),Oo(vn));if("error"in n)throw new e.SolanaJSONRPCError(n.error,`failed to get signatures for owner ${t.toBase58()}`);if(null===n.result.value)throw new Error(`failed to get signatures for owner ${t.toBase58()}`);return n.result.value}async getCompressionSignaturesForTokenOwner(t,r){var o;const n=co(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForTokenOwner",{owner:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(o=null==r?void 0:r.limit)||void 0===o?void 0:o.toNumber()}),Oo(vn));if("error"in n)throw new e.SolanaJSONRPCError(n.error,`failed to get signatures for owner ${t.toBase58()}`);if(null===n.result.value)throw new Error(`failed to get signatures for owner ${t.toBase58()}`);return n.result.value}async getIndexerHealth(){const t=co(await Tn(this.compressionApiEndpoint,"getIndexerHealth"),No(Qo));if("error"in t)throw new e.SolanaJSONRPCError(t.error,"failed to get health");return t.result}async confirmTransactionIndexed(e){const t=ue(this.rpcEndpoint)?1e4:2e4,r=ue(this.rpcEndpoint)?100:200,o=Date.now();for(;;){if(await this.getIndexerSlot()>=e)return 1;if(Date.now()-o>t)throw new Error(`Timeout: Indexer slot did not reach the required slot within ${t/1e3}s`);await new Promise((e=>setTimeout(e,r)))}}async getIndexerSlot(){const t=co(await Tn(this.compressionApiEndpoint,"getIndexerSlot"),No(Jo));if("error"in t)throw new e.SolanaJSONRPCError(t.error,"failed to get slot");return t.result}async getCompressedMintTokenHolders(t,r){var o;const n=co(await Tn(this.compressionApiEndpoint,"getCompressedMintTokenHolders",{mint:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(o=null==r?void 0:r.limit)||void 0===o?void 0:o.toNumber()}),Oo(yn));if("error"in n)throw new e.SolanaJSONRPCError(n.error,"failed to get mint token holders");return n.result}async getLatestCompressionSignatures(t,r){const o=co(await Tn(this.compressionApiEndpoint,"getLatestCompressionSignatures",{limit:r,cursor:t}),Oo(Xo));if("error"in o)throw new e.SolanaJSONRPCError(o.error,"failed to get latest non-voting signatures");return o.result}async getLatestNonVotingSignatures(t,r){const o=co(await Tn(this.compressionApiEndpoint,"getLatestNonVotingSignatures",{limit:t,cursor:r}),Oo(Go));if("error"in o)throw new e.SolanaJSONRPCError(o.error,"failed to get latest non-voting signatures");return o.result}async getMultipleNewAddressProofs(t){const r=co(await Tn(this.compressionApiEndpoint,"getMultipleNewAddressProofs",t.map((e=>Be(e)))),Oo(fo(tn)));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get proofs for new addresses ${t.map((e=>Be(e))).join(", ")}`);if(null===r.result.value)throw new Error(`failed to get proofs for new addresses ${t.map((e=>Be(e))).join(", ")}`);const o=[];for(const e of r.result.value){const t={root:e.root,rootIndex:e.rootSeq%2400,value:e.address,leafLowerRangeValue:e.lowerRangeAddress,leafHigherRangeValue:e.higherRangeAddress,nextIndex:Re(e.nextIndex),merkleProofHashedIndexedElementLeaf:e.proof,indexHashedIndexedElementLeaf:Re(e.lowElementLeafIndex),treeInfo:{tree:e.merkleTree,queue:de().addressQueue,treeType:exports.TreeType.AddressV1,nextTreeInfo:null}};o.push(t)}return o}async getValidityProof(e=[],t=[]){const r=await this.getMultipleCompressedAccounts(e),o=r.map((e=>e.treeInfo.tree)),n=r.map((e=>e.treeInfo.queue)),s=de().addressTree,i=de().addressQueue,a=e.map(((e,t)=>({hash:e,tree:o[t],queue:n[t]}))),u=t.map((e=>({address:e,tree:s,queue:i})));return this.getValidityProofV0(a,u)}async getValidityProofV0(e=[],t=[]){const{value:r}=await this.getValidityProofAndRpcContext(e,t);return r}async getValidityProofAndRpcContext(t=[],r=[]){vt(t.length,r.length);const o=await Tn(this.compressionApiEndpoint,z("getValidityProof"),{hashes:t.map((({hash:e})=>Be(e))),newAddressesWithTrees:r.map((({address:e,tree:t})=>({address:Be(e),tree:t.toBase58()})))});let n;if(n=j.isV2()?co(o,Oo(un)):co(o,Oo(nn)),"error"in n)throw new e.SolanaJSONRPCError(n.error,`failed to get validity proof for hashes ${t.map((e=>e.hash.toString())).join(", ")}`);if(null===n.result.value)throw new Error(`failed to get validity proof for hashes ${t.map((e=>e.hash.toString())).join(", ")}`);const s=n.result.value;if(j.isV2())return{value:{compressedProof:s.compressedProof,leaves:s.accounts.map((e=>e.hash)).concat(s.addresses.map((e=>e.address))),roots:s.accounts.map((e=>e.root)).concat(s.addresses.map((e=>e.root))),rootIndices:s.accounts.map((e=>e.rootIndex.rootIndex)).concat(s.addresses.map((e=>e.rootIndex))),proveByIndices:s.accounts.map((e=>e.rootIndex.proveByIndex)).concat(s.addresses.map((()=>0))),treeInfos:s.accounts.map((e=>e.merkleContext)).concat(s.addresses.map((e=>e.merkleContext))),leafIndices:s.accounts.map((e=>e.leafIndex)).concat(s.addresses.map((()=>0)))},context:n.result.context};{const e=await this.getStateTreeInfos(),t=s.merkleTrees.map((t=>t.equals(de().addressTree)?{tree:t,queue:de().addressQueue,treeType:exports.TreeType.AddressV1,nextTreeInfo:null}:Nr(e,t)));return{value:{compressedProof:s.compressedProof,roots:s.roots,rootIndices:s.rootIndices.map((e=>e)),leafIndices:s.leafIndices,leaves:s.leaves,treeInfos:t,proveByIndices:s.rootIndices.map((e=>e.proveByIndex))},context:n.result.context}}}}class Nn extends e.Connection{constructor(e,t,r,o,n,s){super(e,n||"confirmed"),this.log=0,this.allStateTreeInfos=null,this.lastStateTreeFetchTime=null,this.fetchPromise=null,this.CACHE_TTL=36e5,this.compressionApiEndpoint=r,this.proverEndpoint=o;const{depth:i,log:a}=null!=s?s:{},{merkleTreeHeight:u}=de();this.lightWasm=t,this.depth=null!=i?i:u,this.log=null!=a?a:0}async getCachedActiveStateTreeInfo(){}async getCachedActiveStateTreeInfos(){}async getStateTreeInfos(){return ce()}async doFetch(){throw new Error("doFetch not supported in test-rpc")}async getCompressedAccount(e,t){if(e)throw new Error("address is not supported in test-rpc");if(!t)throw new Error("hash is required");const r=await Wr(this,t);return null!=r?r:null}async getCompressedBalance(e,t){if(e)throw new Error("address is not supported in test-rpc");if(!t)throw new Error("hash is required");const r=await Wr(this,t);if(!r)throw new Error("Account not found");return Re(r.lamports)}async getCompressedBalanceByOwner(e){return(await this.getCompressedAccountsByOwner(e)).items.reduce(((e,t)=>e.add(t.lamports)),Re(0))}async getCompressedAccountProof(e){return(await this.getMultipleCompressedAccountProofs([e]))[0]}async getMultipleCompressedAccounts(e){return await async function(e,t){return(await Zr(e)).filter((e=>t.some((t=>Re(e.hash).eq(t))))).sort(((e,t)=>t.leafIndex-e.leafIndex))}(this,e)}async confirmTransactionIndexed(e){return 1}async getMultipleCompressedAccountProofs(t){const r=await $r(this).then((e=>e.reverse())),o=new Map,n=await this.getStateTreeInfos();for(const e of r)for(let t=0;t<e.outputCompressedAccounts.length;t++){const r=e.outputCompressedAccountHashes[t],s=Lr(n,e.pubkeyArray[e.outputCompressedAccounts[t].merkleTreeIndex]);o.has(s.tree.toBase58())||o.set(s.tree.toBase58(),{leaves:[],leafIndices:[],treeInfo:s});const i=o.get(s.tree.toBase58());if(!i)throw new Error(`Tree not found: ${s.tree.toBase58()}`);i.leaves.push(r),i.leafIndices.push(e.outputLeafIndices[t])}const s=new Map;for(const[r,{leaves:n,treeInfo:i}]of o.entries()){const a=new e.PublicKey(r);let u;if(i.treeType===exports.TreeType.StateV1)u=new Hr(this.depth,this.lightWasm,n.map((e=>Re(e).toString())));else{if(i.treeType!==exports.TreeType.StateV2)throw new Error(`Invalid tree type: ${i.treeType} in test-rpc.ts`);u=new Hr(32,this.lightWasm,[])}for(let e=0;e<t.length;e++){const r=n.findIndex((r=>Re(r).eq(t[e])));if(-1!==r)if(i.treeType===exports.TreeType.StateV1){const o=u.path(r).pathElements.map((e=>Re(e))),a=Re(u.root()),c={hash:Re(t[e].toArray("be",32)),treeInfo:i,leafIndex:r,merkleProof:o,proveByIndex:0,rootIndex:n.length,root:a};s.set(t[e].toString(),c)}else if(i.treeType===exports.TreeType.StateV2){const r=u._zeros.slice(0,-1).map((e=>Re(e))),n=Re(u.root()),c=o.get(a.toBase58()).leafIndices.findIndex((r=>t[e].eq(Re(o.get(a.toBase58()).leaves[r])))),l={hash:Re(t[e].toArray("be",32)),treeInfo:i,leafIndex:c,merkleProof:r,proveByIndex:1,rootIndex:0,root:n};s.set(t[e].toString(),l)}}}if(s.forEach(((e,t)=>{if(e.treeInfo.treeType===exports.TreeType.StateV1){const r=e.leafIndex,n=o.get(e.treeInfo.tree.toBase58()).leaves[r],s=Re(n);if(!s.eq(e.hash))throw new Error(`Mismatch at index ${t}: expected ${e.hash.toString()}, got ${s.toString()}`)}})),new Set(t.map((e=>{const t=s.get(e.toString());if(!t)throw new Error(`Proof not found for hash: ${e.toString()}`);return t.treeInfo.treeType}))).size>1)throw new Error("Requested hashes belong to different tree types (V1/V2)");return t.map((e=>{const t=s.get(e.toString());if(!t)throw new Error(`No proof found for hash: ${e.toString()}`);return t}))}async getCompressedAccountsByOwner(e,t){const r=await async function(e,t){return(await Zr(e)).filter((e=>e.owner.equals(t)))}(this,e);return{items:r,cursor:null}}async getLatestCompressionSignatures(e,t){throw new Error("getLatestNonVotingSignaturesWithContext not supported in test-rpc")}async getLatestNonVotingSignatures(e){throw new Error("getLatestNonVotingSignaturesWithContext not supported in test-rpc")}async getCompressedTokenAccountsByOwner(e,t){return await Xr(this,e,t.mint)}async getCompressedTokenAccountsByDelegate(e,t){return await Yr(this,e,t.mint)}async getCompressedTokenAccountBalance(e){const t=await eo(this,e);return{amount:Re(t.parsed.amount)}}async getCompressedTokenBalancesByOwner(e,t){return{items:(await Xr(this,e,t.mint)).items.map((e=>({balance:Re(e.parsed.amount),mint:e.parsed.mint}))),cursor:null}}async getCompressedTokenBalancesByOwnerV2(e,t){return{context:{slot:1},value:{items:(await Xr(this,e,t.mint)).items.map((e=>({balance:Re(e.parsed.amount),mint:e.parsed.mint}))),cursor:null}}}async getCompressionSignaturesForAccount(e){throw new Error("getCompressionSignaturesForAccount not implemented in test-rpc")}async getTransactionWithCompressionInfo(e){throw new Error("getCompressedTransaction not implemented in test-rpc")}async getCompressionSignaturesForAddress(e,t){throw new Error("getSignaturesForAddress3 not implemented")}async getCompressionSignaturesForOwner(e,t){throw new Error("getSignaturesForOwner not implemented")}async getCompressionSignaturesForTokenOwner(e,t){throw new Error("getSignaturesForTokenOwner not implemented")}async getIndexerHealth(){return"ok"}async getIndexerSlot(){return 1}async getMultipleNewAddressProofs(e){const t=Kr.default(),r=[];t.init();const o=[];for(let e=0;e<r.length;e++)t.append(Re(r[e]));for(let e=0;e<t.elements.length;e++){const r=t.hashElement(this.lightWasm,e);o.push(Re(r))}const n=new Hr(this.depth,this.lightWasm,o.map((e=>Re(e).toString()))),s=[];for(let r=0;r<e.length;r++){const[o]=t.findLowElement(e[r]);if(!o)throw new Error("Address not found");const i=o.index,a=n.path(i).pathElements.map((e=>Re(e))),u=t.get(o.nextIndex).value,c={root:Re(n.root()),rootIndex:3,value:e[r],leafLowerRangeValue:o.value,leafHigherRangeValue:u,nextIndex:Re(o.nextIndex),merkleProofHashedIndexedElementLeaf:a,indexHashedIndexedElementLeaf:Re(o.index),treeInfo:{tree:de().addressTree,queue:de().addressQueue,treeType:exports.TreeType.AddressV1,nextTreeInfo:null}};s.push(c)}return s}async getCompressedMintTokenHolders(e,t){throw new Error("getCompressedMintTokenHolders not implemented in test-rpc")}async getValidityProofAndRpcContext(e=[],t=[]){if(t.some((e=>!(e instanceof $))))throw new Error("AddressWithTree is not supported in test-rpc");return{value:await this.getValidityProofV0(e,t),context:{slot:1}}}async getValidityProof(e=[],t=[]){if(t.some((e=>!(e instanceof $))))throw new Error("AddressWithTree is not supported in test-rpc");let r;const o=[];if(0===e.length&&0===t.length)throw new Error("Empty input. Provide hashes and/or new addresses.");if(e.length>0&&0===t.length){for(const t of e){const e=await this.getCompressedAccount(void 0,t);if(!e)throw new Error("Account not found");o.push(e.treeInfo)}const t=o.some((e=>e.treeType===exports.TreeType.StateV1)),n=await this.getMultipleCompressedAccountProofs(e);if(t){const e=Sn(n);r={compressedProof:await _n(this.proverEndpoint,"inclusion",e,this.log),roots:n.map((e=>e.root)),rootIndices:n.map((e=>e.rootIndex)),leafIndices:n.map((e=>e.leafIndex)),leaves:n.map((e=>Re(e.hash))),treeInfos:n.map((e=>e.treeInfo)),proveByIndices:n.map((e=>e.proveByIndex))}}else r={compressedProof:null,roots:n.map((()=>Re(0))),rootIndices:n.map((e=>e.rootIndex)),leafIndices:n.map((e=>e.leafIndex)),leaves:n.map((e=>Re(e.hash))),treeInfos:n.map((e=>e.treeInfo)),proveByIndices:n.map((e=>e.proveByIndex))}}else if(0===e.length&&t.length>0){const e=await this.getMultipleNewAddressProofs(t),o=kn(e);r={compressedProof:await _n(this.proverEndpoint,"new-address",o,this.log),roots:e.map((e=>e.root)),rootIndices:e.map((()=>3)),leafIndices:e.map((e=>e.indexHashedIndexedElementLeaf.toNumber())),leaves:e.map((e=>Re(e.value))),treeInfos:e.map((e=>e.treeInfo)),proveByIndices:e.map((()=>0))}}else{if(!(e.length>0&&t.length>0))throw new Error("Invalid input");{const o=await this.getMultipleCompressedAccountProofs(e),n=await this.getMultipleNewAddressProofs(t),s=o.map((e=>e.treeInfo)).some((e=>e.treeType===exports.TreeType.StateV1)),i=kn(n);let a;if(s){const e=Sn(o);a=await _n(this.proverEndpoint,"combined",[e,i],1)}else a=await _n(this.proverEndpoint,"new-address",i,1);r={compressedProof:a,roots:o.map((e=>s?e.root:Re(0))).concat(n.map((e=>e.root))),rootIndices:o.map((e=>e.rootIndex)).concat(n.map((()=>3))),leafIndices:o.map((e=>e.leafIndex)).concat(n.map((e=>e.indexHashedIndexedElementLeaf.toNumber()))),leaves:o.map((e=>Re(e.hash))).concat(n.map((e=>Re(e.value)))),treeInfos:o.map((e=>e.treeInfo)).concat(n.map((e=>e.treeInfo))),proveByIndices:o.map((e=>e.proveByIndex)).concat(n.map((()=>0)))}}}return r}async getValidityProofV0(e=[],t=[]){return this.getValidityProof(e.map((e=>e.hash)),t.map((e=>e.address)))}}let On=1;const Bn=Vn(255),Rn=Vn(254),Dn=Vn(253),Un=Vn(252);function Vn(t){if(t||(t=On,On++),t>255)return e.Keypair.generate();const r=new Uint8Array(32);return r[31]=t,e.Keypair.fromSeed(r)}var Fn,qn,Kn,Hn,$n,jn,zn,Wn;exports.UtxoErrorCode=void 0,(Fn=exports.UtxoErrorCode||(exports.UtxoErrorCode={})).NEGATIVE_LAMPORTS="NEGATIVE_LAMPORTS",Fn.NOT_U64="NOT_U64",Fn.BLINDING_EXCEEDS_FIELD_SIZE="BLINDING_EXCEEDS_FIELD_SIZE",exports.SelectInUtxosErrorCode=void 0,(qn=exports.SelectInUtxosErrorCode||(exports.SelectInUtxosErrorCode={})).FAILED_TO_FIND_UTXO_COMBINATION="FAILED_TO_FIND_UTXO_COMBINATION",qn.INVALID_NUMBER_OF_IN_UTXOS="INVALID_NUMBER_OF_IN_UTXOS",exports.CreateUtxoErrorCode=void 0,(Kn=exports.CreateUtxoErrorCode||(exports.CreateUtxoErrorCode={})).OWNER_UNDEFINED="OWNER_UNDEFINED",Kn.INVALID_OUTPUT_UTXO_LENGTH="INVALID_OUTPUT_UTXO_LENGTH",Kn.UTXO_DATA_UNDEFINED="UTXO_DATA_UNDEFINED",exports.RpcErrorCode=void 0,(Hn=exports.RpcErrorCode||(exports.RpcErrorCode={})).CONNECTION_UNDEFINED="CONNECTION_UNDEFINED",Hn.RPC_PUBKEY_UNDEFINED="RPC_PUBKEY_UNDEFINED",Hn.RPC_METHOD_NOT_IMPLEMENTED="RPC_METHOD_NOT_IMPLEMENTED",Hn.RPC_INVALID="RPC_INVALID",exports.LookupTableErrorCode=void 0,($n=exports.LookupTableErrorCode||(exports.LookupTableErrorCode={})).LOOK_UP_TABLE_UNDEFINED="LOOK_UP_TABLE_UNDEFINED",$n.LOOK_UP_TABLE_NOT_INITIALIZED="LOOK_UP_TABLE_NOT_INITIALIZED",exports.HashErrorCode=void 0,(exports.HashErrorCode||(exports.HashErrorCode={})).NO_POSEIDON_HASHER_PROVIDED="NO_POSEIDON_HASHER_PROVIDED",exports.ProofErrorCode=void 0,(jn=exports.ProofErrorCode||(exports.ProofErrorCode={})).INVALID_PROOF="INVALID_PROOF",jn.PROOF_INPUT_UNDEFINED="PROOF_INPUT_UNDEFINED",jn.PROOF_GENERATION_FAILED="PROOF_GENERATION_FAILED",exports.MerkleTreeErrorCode=void 0,(zn=exports.MerkleTreeErrorCode||(exports.MerkleTreeErrorCode={})).MERKLE_TREE_NOT_INITIALIZED="MERKLE_TREE_NOT_INITIALIZED",zn.SOL_MERKLE_TREE_UNDEFINED="SOL_MERKLE_TREE_UNDEFINED",zn.MERKLE_TREE_UNDEFINED="MERKLE_TREE_UNDEFINED",zn.INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE="INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE",zn.MERKLE_TREE_INDEX_UNDEFINED="MERKLE_TREE_INDEX_UNDEFINED",zn.MERKLE_TREE_SET_SPACE_UNDEFINED="MERKLE_TREE_SET_SPACE_UNDEFINED",exports.UtilsErrorCode=void 0,(Wn=exports.UtilsErrorCode||(exports.UtilsErrorCode={})).ACCOUNT_NAME_UNDEFINED_IN_IDL="ACCOUNT_NAME_UNDEFINED_IN_IDL",Wn.PROPERTY_UNDEFINED="PROPERTY_UNDEFINED",Wn.LOOK_UP_TABLE_CREATION_FAILED="LOOK_UP_TABLE_CREATION_FAILED",Wn.UNSUPPORTED_ARCHITECTURE="UNSUPPORTED_ARCHITECTURE",Wn.UNSUPPORTED_PLATFORM="UNSUPPORTED_PLATFORM",Wn.ACCOUNTS_UNDEFINED="ACCOUNTS_UNDEFINED",Wn.INVALID_NUMBER="INVALID_NUMBER";class Zn extends Error{constructor(e,t,r){super(`${e}: ${r}`),this.code=e,this.functionName=t,this.codeMessage=r}}exports.ADDRESS_QUEUE_ROLLOVER_FEE=Ce,exports.ADDRESS_TREE_NETWORK_FEE=Le,exports.ALICE=Bn,exports.AccountProofResult=gn,exports.AppendLeavesInputLayout=at,exports.AppendNullifyCreateAddressInputsMetaLayout=it,exports.BOB=Rn,exports.BalanceResult=dn,exports.CHARLIE=Dn,exports.COMPRESSED_TOKEN_PROGRAM_ID=he,exports.COMPUTE_BUDGET_PATTERN=J,exports.CompressedAccountLayout=Fe,exports.CompressedAccountResult=Uo,exports.CompressedAccountResultV2=Vo,exports.CompressedAccountsByOwnerResult=jo,exports.CompressedAccountsByOwnerResultV2=zo,exports.CompressedCpiContextLayout=We,exports.CompressedMintTokenHoldersResult=yn,exports.CompressedProofLayout=ze,exports.CompressedTokenAccountResult=qo,exports.CompressedTokenAccountResultV2=Ko,exports.CompressedTokenAccountsByOwnerOrDelegateResult=Wo,exports.CompressedTokenAccountsByOwnerOrDelegateResultV2=Zo,exports.CompressedTransactionResult=bn,exports.CompressedTransactionResultV2=In,exports.CreateUtxoError=class extends Zn{},exports.DAVE=Un,exports.DEFAULT_MERKLE_TREE_HEIGHT=_e,exports.DEFAULT_MERKLE_TREE_ROOTS=2800,exports.DEFAULT_ZERO="0",exports.FIELD_SIZE=W,exports.HIGHEST_ADDRESS_PLUS_ONE=Z,exports.HashError=class extends Zn{},exports.HealthResult=Qo,exports.IDL={version:"1.2.0",name:"light_system_program",constants:[{name:"SOL_POOL_PDA_SEED",type:"bytes",value:"[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]"}],instructions:[{name:"initCpiContextAccount",accounts:[{name:"feePayer",isMut:1,isSigner:1},{name:"cpiContextAccount",isMut:1,isSigner:0},{name:"associatedMerkleTree",isMut:0,isSigner:0}],args:[]},{name:"invoke",accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0,docs:["This pda is used to invoke the account compression program."]},{name:"accountCompressionProgram",isMut:0,isSigner:0,docs:["Merkle trees."]},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1,docs:["Sol pool pda is used to store the native sol that has been compressed.","It's only required when compressing or decompressing sol."]},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1,docs:["Only needs to be provided for decompression as a recipient for the","decompressed sol.","Compressed sol originate from authority."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"invokeCpi",accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"invokingProgram",isMut:0,isSigner:0},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0},{name:"cpiContextAccount",isMut:1,isSigner:0,isOptional:1}],args:[{name:"inputs",type:"bytes"}]},{name:"invokeCpiWithReadOnly",accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"invokingProgram",isMut:0,isSigner:0},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0},{name:"cpiContextAccount",isMut:1,isSigner:0,isOptional:1}],args:[{name:"inputs",type:"bytes"}]},{name:"stubIdlBuild",docs:["This function is a stub to allow Anchor to include the input types in","the IDL. It should not be included in production builds nor be called in","practice."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0,docs:["This pda is used to invoke the account compression program."]},{name:"accountCompressionProgram",isMut:0,isSigner:0,docs:["Merkle trees."]},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1,docs:["Sol pool pda is used to store the native sol that has been compressed.","It's only required when compressing or decompressing sol."]},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1,docs:["Only needs to be provided for decompression as a recipient for the","decompressed sol.","Compressed sol originate from authority."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs1",type:{defined:"InstructionDataInvoke"}},{name:"inputs2",type:{defined:"InstructionDataInvokeCpi"}},{name:"inputs3",type:{defined:"PublicTransactionEvent"}}]}],accounts:[{name:"cpiContextAccount",docs:["Collects instruction data without executing a compressed transaction.","Signer checks are performed on instruction data.","Collected instruction data is combined with the instruction data of the executing cpi,","and executed as a single transaction.","This enables to use input compressed accounts that are owned by multiple programs,","with one zero-knowledge proof."],type:{kind:"struct",fields:[{name:"feePayer",type:"publicKey"},{name:"associatedMerkleTree",type:"publicKey"},{name:"context",type:{vec:{defined:"InstructionDataInvokeCpi"}}}]}}],types:[{name:"InstructionDataInvoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"}]}},{name:"NewAddressParamsPacked",type:{kind:"struct",fields:[{name:"seed",type:{array:["u8",32]}},{name:"addressQueueAccountIndex",type:"u8"},{name:"addressMerkleTreeAccountIndex",type:"u8"},{name:"addressMerkleTreeRootIndex",type:"u16"}]}},{name:"OutputCompressedAccountWithPackedContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleTreeIndex",type:"u8"}]}},{name:"CompressedProof",type:{kind:"struct",fields:[{name:"a",type:{array:["u8",32]}},{name:"b",type:{array:["u8",64]}},{name:"c",type:{array:["u8",32]}}]}},{name:"InstructionDataInvokeCpi",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]}},{name:"CompressedCpiContext",type:{kind:"struct",fields:[{name:"setContext",docs:["Is set by the program that is invoking the CPI to signal that is should","set the cpi context."],type:"bool"},{name:"firstSetContext",docs:["Is set to wipe the cpi context since someone could have set it before","with unrelated data."],type:"bool"},{name:"cpiContextAccountIndex",docs:["Index of cpi context account in remaining accounts."],type:"u8"}]}},{name:"CompressedAccount",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"lamports",type:"u64"},{name:"address",type:{option:{array:["u8",32]}}},{name:"data",type:{option:{defined:"CompressedAccountData"}}}]}},{name:"CompressedAccountData",type:{kind:"struct",fields:[{name:"discriminator",type:{array:["u8",8]}},{name:"data",type:"bytes"},{name:"dataHash",type:{array:["u8",32]}}]}},{name:"PackedCompressedAccountWithMerkleContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",docs:["Index of root used in inclusion validity proof."],type:"u16"},{name:"readOnly",docs:["Placeholder to mark accounts read-only unimplemented set to false."],type:"bool"}]}},{name:"PackedMerkleContext",type:{kind:"struct",fields:[{name:"merkleTreePubkeyIndex",type:"u8"},{name:"queuePubkeyIndex",type:"u8"},{name:"leafIndex",type:"u32"},{name:"proveByIndex",type:"bool"}]}},{name:"MerkleTreeSequenceNumber",type:{kind:"struct",fields:[{name:"pubkey",type:"publicKey"},{name:"seq",type:"u64"}]}},{name:"PublicTransactionEvent",type:{kind:"struct",fields:[{name:"inputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"outputLeafIndices",type:{vec:"u32"}},{name:"sequenceNumbers",type:{vec:{defined:"MerkleTreeSequenceNumber"}}},{name:"relayFee",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"pubkeyArray",type:{vec:"publicKey"}},{name:"message",type:{option:"bytes"}}]}}],errors:[{code:6e3,name:"SumCheckFailed",msg:"Sum check failed"},{code:6001,name:"SignerCheckFailed",msg:"Signer check failed"},{code:6002,name:"CpiSignerCheckFailed",msg:"Cpi signer check failed"},{code:6003,name:"ComputeInputSumFailed",msg:"Computing input sum failed."},{code:6004,name:"ComputeOutputSumFailed",msg:"Computing output sum failed."},{code:6005,name:"ComputeRpcSumFailed",msg:"Computing rpc sum failed."},{code:6006,name:"InvalidAddress",msg:"InvalidAddress"},{code:6007,name:"DeriveAddressError",msg:"DeriveAddressError"},{code:6008,name:"CompressedSolPdaUndefinedForCompressSol",msg:"CompressedSolPdaUndefinedForCompressSol"},{code:6009,name:"DecompressLamportsUndefinedForCompressSol",msg:"DecompressLamportsUndefinedForCompressSol"},{code:6010,name:"CompressedSolPdaUndefinedForDecompressSol",msg:"CompressedSolPdaUndefinedForDecompressSol"},{code:6011,name:"DeCompressLamportsUndefinedForDecompressSol",msg:"DeCompressLamportsUndefinedForDecompressSol"},{code:6012,name:"DecompressRecipientUndefinedForDecompressSol",msg:"DecompressRecipientUndefinedForDecompressSol"},{code:6013,name:"WriteAccessCheckFailed",msg:"WriteAccessCheckFailed"},{code:6014,name:"InvokingProgramNotProvided",msg:"InvokingProgramNotProvided"},{code:6015,name:"InvalidCapacity",msg:"InvalidCapacity"},{code:6016,name:"InvalidMerkleTreeOwner",msg:"InvalidMerkleTreeOwner"},{code:6017,name:"ProofIsNone",msg:"ProofIsNone"},{code:6018,name:"ProofIsSome",msg:"Proof is some but no input compressed accounts or new addresses provided."},{code:6019,name:"EmptyInputs",msg:"EmptyInputs"},{code:6020,name:"CpiContextAccountUndefined",msg:"CpiContextAccountUndefined"},{code:6021,name:"CpiContextEmpty",msg:"CpiContextEmpty"},{code:6022,name:"CpiContextMissing",msg:"CpiContextMissing"},{code:6023,name:"DecompressionRecipientDefined",msg:"DecompressionRecipientDefined"},{code:6024,name:"SolPoolPdaDefined",msg:"SolPoolPdaDefined"},{code:6025,name:"AppendStateFailed",msg:"AppendStateFailed"},{code:6026,name:"InstructionNotCallable",msg:"The instruction is not callable"},{code:6027,name:"CpiContextFeePayerMismatch",msg:"CpiContextFeePayerMismatch"},{code:6028,name:"CpiContextAssociatedMerkleTreeMismatch",msg:"CpiContextAssociatedMerkleTreeMismatch"},{code:6029,name:"NoInputs",msg:"NoInputs"},{code:6030,name:"InputMerkleTreeIndicesNotInOrder",msg:"Input merkle tree indices are not in ascending order."},{code:6031,name:"OutputMerkleTreeIndicesNotInOrder",msg:"Output merkle tree indices are not in ascending order."},{code:6032,name:"OutputMerkleTreeNotUnique"},{code:6033,name:"DataFieldUndefined"},{code:6034,name:"ReadOnlyAddressAlreadyExists"},{code:6035,name:"ReadOnlyAccountDoesNotExist"},{code:6036,name:"HashChainInputsLenghtInconsistent"},{code:6037,name:"InvalidAddressTreeHeight"},{code:6038,name:"InvalidStateTreeHeight"}]},exports.INSERT_INTO_QUEUES_DISCRIMINATOR=ee,exports.INVOKE_CPI_DISCRIMINATOR=G,exports.INVOKE_CPI_WITH_ACCOUNT_INFO_DISCRIMINATOR=Y,exports.INVOKE_CPI_WITH_READ_ONLY_DISCRIMINATOR=X,exports.INVOKE_DISCRIMINATOR=Q,exports.InAccountLayout=Qe,exports.IndexedArray=Kr,exports.IndexedElement=Fr,exports.IndexedElementBundle=qr,exports.InsertAddressInputLayout=ct,exports.InsertNullifierInputLayout=ut,exports.InstructionDataInvokeCpiLayout=je,exports.InstructionDataInvokeCpiWithReadOnlyLayout=Ye,exports.InstructionDataInvokeLayout=He,exports.LatestNonVotingSignaturesResult=Go,exports.LatestNonVotingSignaturesResultPaginated=Xo,exports.LightSystemProgram=Ur,exports.LookupTableError=class extends Zn{},exports.MerkleContextLayout=qe,exports.MerkleProofResult=Yo,exports.MerkleProofResultV2=en,exports.MerkleTree=Hr,exports.MerkleTreeError=class extends Zn{},exports.MerkleTreeSequenceNumberLayout=lt,exports.MultipleCompressedAccountsResult=Ho,exports.MultipleCompressedAccountsResultV2=$o,exports.MultipleMerkleProofsResult=cn,exports.MultipleMerkleProofsResultV2=ln,exports.NativeBalanceResult=hn,exports.NewAddressParamsAssignedPackedLayout=Ze,exports.NewAddressParamsLayout=Ke,exports.NewAddressProofResult=tn,exports.PackedMerkleContextLayout=Je,exports.PackedReadOnlyAddressLayout=Ge,exports.PackedReadOnlyCompressedAccountLayout=Xe,exports.ProofError=class extends Zn{},exports.PublicTransactionEventLayout=nt,exports.RootIndexResultV2=on,exports.Rpc=Ln,exports.RpcError=class extends Zn{},exports.STATE_MERKLE_TREE_NETWORK_FEE=Pe,exports.STATE_MERKLE_TREE_ROLLOVER_FEE=ke,exports.SelectInUtxosError=class extends Zn{},exports.SignatureListResult=wn,exports.SignatureListWithCursorResult=vn,exports.SlotResult=Jo,exports.TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD=Se,exports.TestRpc=Nn,exports.TokenBalanceListResult=mn,exports.TokenBalanceListResultV2=fn,exports.TokenBalanceResult=pn,exports.TokenDataLayout=Jr,exports.TokenDataResult=Fo,exports.UTXO_MERGE_MAXIMUM=10,exports.UTXO_MERGE_THRESHOLD=20,exports.UtilsError=class extends Zn{},exports.UtxoError=class extends Zn{},exports.ValidityProofResult=nn,exports.ValidityProofResultV2=un,exports.accountCompressionProgram=oe,exports.addressQueue=be,exports.addressTree=xe,exports.airdropSol=async function({connection:e,lamports:t,recipientPublicKey:r}){const o=await e.requestAirdrop(r,t);return await br(e,o),o},exports.batchMerkleTree=Ae,exports.batchQueue=Te,exports.bn=Re,exports.bufToDecStr=e=>Oe(e).toString(),exports.buildAndSignTx=Pr,exports.buildTx=Sr,exports.byteArrayToKeypair=function(t){return e.Keypair.fromSecretKey(Uint8Array.from(t))},exports.calculateComputeUnitPrice=function(e,t){return Math.ceil(1e6*e/t)},exports.checkValidityProofShape=e=>{if(32!==e.a.length||64!==e.b.length||32!==e.c.length)throw new Error("ValidityProof has invalid shape")},exports.compress=async function(t,r,o,n,s,i){const{blockhash:a}=await t.getLatestBlockhash();s||(s=Or(await t.getStateTreeInfos()));const u=await Ur.compress({payer:r.publicKey,toAddress:n,lamports:o,outputStateTreeInfo:s}),c=Pr([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),u],r,a,[]);return await kr(t,c,i)},exports.confirmConfig={commitment:"confirmed",preflightCommitment:"confirmed"},exports.confirmTransaction=br,exports.confirmTx=Cr,exports.convertInvokeCpiWithReadOnlyToInvoke=gr,exports.convertMerkleProofsWithContextToHex=Sn,exports.convertNonInclusionMerkleProofInputsToHex=kn,exports.convertToPublicTransactionEvent=ht,exports.cpiContext2Pubkey=Me,exports.cpiContextPubkey=we,exports.createAccount=async function(t,r,o,n,s,i,a){const{blockhash:u}=await t.getLatestBlockhash(),{tree:c,queue:l}=null!=s?s:le(),d=wr(o,n),h=vr(d,c);i||(i=Or(await t.getStateTreeInfos()));const p=await t.getValidityProofV0(void 0,[{address:Re(h.toBytes()),tree:c,queue:l}]),m={seed:d,addressMerkleTreeRootIndex:p.rootIndices[0],addressMerkleTreePubkey:p.treeInfos[0].tree,addressQueuePubkey:p.treeInfos[0].queue},f=await Ur.createAccount({payer:r.publicKey,newAddressParams:m,newAddress:Array.from(h.toBytes()),recentValidityProof:p.compressedProof,programId:n,outputStateTreeInfo:i}),y=Pr([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),f],r,u,[]);return await kr(t,y,a)},exports.createAccountWithLamports=async function(t,r,o,n,s,i,a,u){n=Re(n);const c=await t.getCompressedAccountsByOwner(r.publicKey),[l]=Vr(c.items,n),{blockhash:d}=await t.getLatestBlockhash(),{tree:h}=null!=i?i:le(),p=wr(o,s),m=vr(p,h),f=await t.getValidityProof(l.map((e=>e.hash)),[Re(m.toBytes())]),y={seed:p,addressMerkleTreeRootIndex:f.rootIndices[f.rootIndices.length-1],addressMerkleTreePubkey:f.treeInfos[f.treeInfos.length-1].tree,addressQueuePubkey:f.treeInfos[f.treeInfos.length-1].queue},g=await Ur.createAccount({payer:r.publicKey,newAddressParams:y,newAddress:Array.from(m.toBytes()),recentValidityProof:f.compressedProof,inputCompressedAccounts:l,inputStateRootIndices:f.rootIndices,outputStateTreeInfo:a}),w=Pr([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),g],r,d,[]);return await kr(t,w,u)},exports.createBN254=Oe,exports.createCompressedAccountLegacy=De,exports.createCompressedAccountMeta=(e,t,r,o)=>({treeInfo:e,outputStateTreeIndex:t,address:null!=r?r:null,lamports:null!=o?o:null}),exports.createCompressedAccountWithMerkleContextLegacy=Ue,exports.createMerkleContextLegacy=Ve,exports.createRpc=function(t,r,o,n){let s;if(t)if("string"==typeof t)s=t,r=r||s,o=o||s;else{if(!(t instanceof e.Connection))throw new Error("Invalid endpoint or connection type");s=t.rpcEndpoint,r=r||s,o=o||s}else s="http://127.0.0.1:8899",r=r||"http://127.0.0.1:8784",o=o||"http://127.0.0.1:3001";return new Ln(s,r,o,n)},exports.createRpcResult=Po,exports.createStateTreeLookupTable=async function({connection:t,payer:r,authority:o,recentSlot:n}){const[s,i]=e.AddressLookupTableProgram.createLookupTable({payer:r.publicKey,authority:o.publicKey,recentSlot:n}),a=Pr([s],r,(await t.getLatestBlockhash()).blockhash,Ir(r,[o]));return{address:i,txId:await kr(t,a)}},exports.decodeInstructionDataInvoke=tt,exports.decodeInstructionDataInvokeCpi=rt,exports.decodeInstructionDataInvokeCpiWithReadOnly=et,exports.decodePublicTransactionEvent=st,exports.decompress=async function(t,r,o,n,s){const i=(await t.getCompressedAccountsByOwner(r.publicKey)).items;o=Re(o);const a=Rr(i);if(o.gt(a))throw new Error(`Not enough compressed lamports. Expected ${o}, got ${a}`);const u=await t.getValidityProof(i.map((e=>Re(e.hash)))),{blockhash:c}=await t.getLatestBlockhash(),l=await Ur.decompress({payer:r.publicKey,toAddress:n,inputCompressedAccounts:i,recentValidityProof:u.compressedProof,recentInputStateRootIndices:u.rootIndices,lamports:o}),d=Pr([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),l],r,c,[]);return await kr(t,d,s)},exports.dedupeSigner=Ir,exports.deepEqual=function e(t,r){if(typeof t!=typeof r)return console.log(`Type mismatch: ${typeof t} !== ${typeof r}`),0;if(t instanceof $&&r instanceof $)return t.eq(r);if("object"==typeof t&&null!==t&&null!==r){const o=Object.keys(t),n=Object.keys(r);if(o.length!==n.length)return console.log(`Key length mismatch: ${o.length} !== ${n.length}`),0;for(const s of o){if(!n.includes(s))return console.log(`Key ${s} not found in value`),0;if(!e(t[s],r[s]))return console.log(`Value mismatch at key ${s}`),0}return 1}return t!==r&&console.log(`Value mismatch: ${t} !== ${r}`),t===r},exports.defaultStateTreeLookupTables=ae,exports.defaultStaticAccounts=()=>[new e.PublicKey(ne()),new e.PublicKey(te),new e.PublicKey(oe),new e.PublicKey(se())],exports.defaultStaticAccountsStruct=ie,exports.defaultTestStateTreeAccounts=de,exports.defaultTestStateTreeAccounts2=()=>({nullifierQueue2:new e.PublicKey(Ee),merkleTree2:new e.PublicKey(Ie)}),exports.deriveAddress=vr,exports.deriveAddressSeed=wr,exports.deserializeAppendNullifyCreateAddressInputsIndexer=dt,exports.encodeBN254toBase58=Be,exports.encodeInstructionDataInvoke=$e,exports.encodePublicTransactionEvent=function(e){const r=t.Buffer.alloc(1e3),o=nt.encode(e,r);return r.slice(0,o)},exports.extendStateTreeLookupTable=async function({connection:t,tableAddress:r,newStateTreeAddresses:o,newQueueAddresses:n,newCpiContextAddresses:s,payer:i,authority:a}){const u=await t.getAddressLookupTable(r);if(!u.value)throw new Error("Lookup table not found");if(u.value.state.addresses.length%3!=0)throw new Error("Lookup table must have a multiple of 3 addresses");if(o.length!==n.length||o.length!==s.length)throw new Error("Same number of newStateTreeAddresses, newQueueAddresses, and newCpiContextAddresses required");const c=Pr([e.AddressLookupTableProgram.extendLookupTable({payer:i.publicKey,authority:a.publicKey,lookupTable:r,addresses:o.flatMap(((e,t)=>[e,n[t],s[t]]))})],i,(await t.getLatestBlockhash()).blockhash,Ir(i,[a]));return{tableAddress:r,txId:await kr(t,c)}},exports.featureFlags=j,exports.getAccountCompressionAuthority=se,exports.getAllStateTreeInfos=Br,exports.getCompressedTokenAccountByHashTest=eo,exports.getCompressedTokenAccounts=Gr,exports.getCompressedTokenAccountsByDelegateTest=Yr,exports.getCompressedTokenAccountsByOwnerTest=Xr,exports.getConnection=function(){return new e.Connection("http://127.0.0.1:8899","confirmed")},exports.getDefaultAddressTreeInfo=le,exports.getIndexOrAdd=pt,exports.getParsedEvents=$r,exports.getPublicInputHash=function(e,t,r,o){const n=Cn(e.map((e=>e.root)),t,o),s=r.map((e=>e.value)),i=Cn(r.map((e=>e.root)),s,o);return i.isZero()?n.isZero()?Cn([n],[i],o):n:i},exports.getRegisteredProgramPda=ne,exports.getStateTreeInfoByPubkey=Lr,exports.getTestKeypair=Vn,exports.getTestRpc=async function(e,t="http://127.0.0.1:8899",r="http://127.0.0.1:8784",o="http://127.0.0.1:3001",n,s=0){return new Nn(t,e,r,o,void 0,{depth:n||de().merkleTreeHeight,log:s})},exports.getTreeInfoByPubkey=Nr,exports.hashToBn254FieldSizeBe=fr,exports.hashvToBn254FieldSizeBe=yr,exports.invokeAccountsLayout=ot,exports.isLocalTest=ue,exports.isSmallerThanBn254FieldSizeBe=pr,exports.jsonRpcResult=No,exports.jsonRpcResultAndContext=Oo,exports.lightSystemProgram=re,exports.localTestActiveStateTreeInfos=ce,exports.merkleTree2Pubkey=Ie,exports.merkletreePubkey=ve,exports.negateAndCompressProof=Mr,exports.newAccountWithLamports=async function(e,t=1e9,r){(void 0===r||r>255)&&(r=256);const o=Vn(r),n=await e.requestAirdrop(o.publicKey,t);return await Cr(e,n),o},exports.noopProgram=te,exports.nullifiedStateTreeLookupTableDevnet=ye,exports.nullifiedStateTreeLookupTableMainnet=me,exports.nullifierQueue2Pubkey=Ee,exports.nullifierQueuePubkey=ge,exports.nullifyLookupTable=async function({connection:t,fullStateTreeAddress:r,nullifyLookupTableAddress:o,stateTreeLookupTableAddress:n,payer:s,authority:i}){const a=await t.getAddressLookupTable(n);if(!a.value)throw console.log("stateTreeLookupTable",a),new Error("State tree lookup table not found");if(!a.value.state.addresses.map((e=>e.toBase58())).includes(r.toBase58()))throw console.log("fullStateTreeAddress",r),console.log("stateTreeLookupTable.value.state.addresses",a.value.state.addresses),new Error("State tree address not found in lookup table. Pass correct address or stateTreeLookupTable");const u=await t.getAddressLookupTable(o);if(!u.value)throw new Error("Nullify table not found");if(u.value.state.addresses.map((e=>e.toBase58())).includes(r.toBase58()))throw new Error("Address already exists in nullify lookup table");const c=Pr([e.AddressLookupTableProgram.extendLookupTable({payer:s.publicKey,authority:i.publicKey,lookupTable:o,addresses:[r]})],s,(await t.getLatestBlockhash()).blockhash,Ir(s,[i]));return{txId:await kr(t,c)}},exports.packCompressedAccounts=yt,exports.packNewAddressParams=xr,exports.packTreeInfos=function(e,t,r){const o=e.slice(),n=[],s=[];let i=-1;if(0===t.length&&0===r.length)return{stateTrees:void 0,addressTrees:s};if(t.forEach((e=>{const t=pt(o,e.treeInfo.tree),r=pt(o,e.treeInfo.queue);n.push({rootIndex:e.rootIndex,merkleTreePubkeyIndex:t,queuePubkeyIndex:r,leafIndex:e.leafIndex,proveByIndex:e.proveByIndex})})),n.length>0){const e=t[0].treeInfo.nextTreeInfo||t[0].treeInfo;let r=e.tree;if(e.treeType===exports.TreeType.StateV2){if(!j.isV2())throw new Error("V2 trees are not supported yet");r=e.queue}i=pt(o,r)}return r.forEach((e=>{const t=pt(o,e.treeInfo.tree),r=pt(o,e.treeInfo.queue);s.push({rootIndex:e.rootIndex,addressMerkleTreePubkeyIndex:t,addressQueuePubkeyIndex:r})})),{stateTrees:n.length>0?{packedTreeInfos:n,outputTreeIndex:i}:void 0,addressTrees:s}},exports.padOutputStateMerkleTrees=mt,exports.parseAccountData=En,exports.parseEvents=jr,exports.parseLightTransaction=function(e,r){let o=0,n=null,s=null;for(const r of e){const e=r.slice(0,8),s=Ne.encode(e),i=Ne.encode(Q),a=Ne.encode(G),u=Ne.encode(X);if(s===i){n=tt(t.Buffer.from(r)),o=1;break}if(s==a){n=rt(t.Buffer.from(r)),o=1;break}if(s==u){n=gr(et(t.Buffer.from(r))),o=1;break}}if(!o)return null;for(const r of e){const e=r.slice(0,8),o=Ne.encode(e),n=Ne.encode(ee);if(console.log(o,n),o===n){const e=r.slice(12);s=dt(t.Buffer.from(e))}}return console.log("appendInputsData",s),n?ht(s,r[r.length-1],n):null},exports.parsePublicTransactionEventWithIdl=zr,exports.parseTokenLayoutWithIdl=Qr,exports.pickRandomTreeAndQueue=function(e){const t=e.length,r=Math.floor(Math.random()*t);let o;if(void 0!==r){if(r<0||r>=e.length)throw new Error(`Index ${r} out of bounds for infos array of length ${e.length}`);o=r}else o=Math.floor(Math.random()*e.length);return e[o]},exports.pipe=function(e,...t){return r=>t.reduce(((e,t)=>t(e)),e(r))},exports.placeholderValidityProof=()=>({a:Array.from({length:32},((e,t)=>t+1)),b:Array.from({length:64},((e,t)=>t+1)),c:Array.from({length:32},((e,t)=>t+1))}),exports.proofFromJsonStruct=Er,exports.proverRequest=_n,exports.pushUniqueItems=function(e,t){e.forEach((e=>{t.includes(e)||t.push(e)}))},exports.rpcRequest=Tn,exports.selectMinCompressedSolAccountsForTransfer=Vr,exports.selectStateTreeInfo=Or,exports.sendAndConfirmTx=kr,exports.sleep=function(e){return new Promise((t=>setTimeout(t,e)))},exports.stateTreeLookupTableDevnet=fe,exports.stateTreeLookupTableMainnet=pe,exports.sumUpLamports=Rr,exports.toAccountMetas=ft,exports.toArray=e=>Array.isArray(e)?e:[e],exports.toCamelCase=mr,exports.toHex=hr,exports.toUnixTimestamp=e=>new Date(e).getTime(),exports.transfer=async function(t,r,o,n,s,i){var a;let u=Re(0);const c=[];let l;for(o=Re(o);u.lt(o);){const e={filters:void 0,dataSlice:void 0,cursor:l,limit:Re(1e3)},r=await t.getCompressedAccountsByOwner(n.publicKey,e);for(const e of r.items)e.lamports.gt(Re(0))&&(c.push(e),u=u.add(e.lamports));if(l=null!==(a=r.cursor)&&void 0!==a?a:void 0,r.items.length<1e3||u.gte(o))break}if(u.lt(o))throw new Error(`Insufficient balance for transfer. Required: ${o.toString()}, available: ${u.toString()}`);const[d]=Vr(c,o),h=await t.getValidityProof(d.map((e=>Re(e.hash)))),p=await Ur.transfer({payer:r.publicKey,inputCompressedAccounts:d,toAddress:s,lamports:o,recentInputStateRootIndices:h.rootIndices,recentValidityProof:h.compressedProof}),{blockhash:m}=await t.getLatestBlockhash(),f=Pr([e.ComputeBudgetProgram.setComputeUnitLimit({units:35e4}),p],r,m);return await kr(t,f,i)},exports.validateNumbers=It,exports.validateNumbersForInclusionProof=xt,exports.validateNumbersForNonInclusionProof=bt,exports.validateNumbersForProof=vt,exports.validateSameOwner=wt,exports.validateSufficientBalance=gt,exports.versionedEndpoint=z,exports.wrapBigNumbersAsStrings=An;
//# sourceMappingURL=index.cjs.map
