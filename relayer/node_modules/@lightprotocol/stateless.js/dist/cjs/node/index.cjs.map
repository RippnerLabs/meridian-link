{"version":3,"file":"index.cjs","sources":["../../../../../node_modules/.pnpm/buffer-layout@1.2.2/node_modules/buffer-layout/lib/Layout.js","../../../../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js","../../../../../src/state/types.ts","../../../../../src/constants.ts","../../../../../node_modules/.pnpm/@coral-xyz+borsh@0.29.0_@solana+web3.js@1.98.0/node_modules/@coral-xyz/borsh/dist/index.js","../../../../../node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js","../../../../../node_modules/.pnpm/base-x@5.0.0/node_modules/base-x/src/esm/index.js","../../../../../src/state/BN254.ts","../../../../../src/state/bn.ts","../../../../../src/state/compressed-account.ts","../../../../../src/programs/system/layout.ts","../../../../../src/programs/system/pack.ts","../../../../../src/utils/validation.ts","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha3.js","../../../../../node_modules/.pnpm/map-obj@5.0.0/node_modules/map-obj/index.js","../../../../../node_modules/.pnpm/camelcase@8.0.0/node_modules/camelcase/index.js","../../../../../node_modules/.pnpm/quick-lru@6.1.2/node_modules/quick-lru/index.js","../../../../../node_modules/.pnpm/camelcase-keys@9.1.3/node_modules/camelcase-keys/index.js","../../../../../src/utils/conversion.ts","../../../../../src/utils/address.ts","../../../../../src/utils/airdrop.ts","../../../../../src/utils/dedupe-signer.ts","../../../../../src/utils/parse-validity-proof.ts","../../../../../src/utils/send-and-confirm.ts","../../../../../src/utils/get-state-tree-infos.ts","../../../../../src/programs/system/program.ts","../../../../../src/programs/system/select-compressed-accounts.ts","../../../../../src/test-helpers/merkle-tree/indexed-array.ts","../../../../../src/test-helpers/merkle-tree/merkle-tree.ts","../../../../../src/test-helpers/test-rpc/get-parsed-events.ts","../../../../../src/test-helpers/test-rpc/get-compressed-accounts.ts","../../../../../src/test-helpers/test-rpc/get-compressed-token-accounts.ts","../../../../../node_modules/.pnpm/superstruct@2.0.2/node_modules/superstruct/dist/index.mjs","../../../../../src/rpc-interface.ts","../../../../../src/rpc.ts","../../../../../src/test-helpers/test-rpc/test-rpc.ts","../../../../../src/test-helpers/test-utils.ts","../../../../../src/errors.ts","../../../../../src/programs/system/idl.ts","../../../../../src/utils/calculate-compute-unit-price.ts","../../../../../src/actions/compress.ts","../../../../../src/actions/create-account.ts","../../../../../src/utils/state-tree-lookup-table.ts","../../../../../src/actions/decompress.ts","../../../../../src/utils/pipe.ts","../../../../../src/utils/sleep.ts","../../../../../src/actions/transfer.ts"],"sourcesContent":["/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\n'use strict';\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && (layout instanceof Layout))) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = (() => new Class());\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true,\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true,\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n\n  /** @override */\n  isCount() {\n    return true;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(((count instanceof ExternalLayout) && count.isCount())\n          || (Number.isInteger(count) && (0 <= count)))) {\n      throw new TypeError('count must be non-negative integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if ((!(count instanceof ExternalLayout))\n        && (0 < elementLayout.span)) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!((word instanceof UInt)\n          || (word instanceof UIntBE))) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if (('string' === typeof msb)\n        && (undefined === property)) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function(v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function() {\n      return value;\n    };\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n}\n\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if ((bits + usedBits) > totalBits) {\n      throw new Error('bits too long for span remainder ('\n                      + (totalBits - usedBits) + ' of '\n                      + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) { // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode() {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ((!Number.isInteger(value))\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\n      throw new TypeError(nameWithProperty('BitField.encode', this)\n                          + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n                                   | wordValue);\n  };\n}\n\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    return BitField.prototype.encode.call(this, value);\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let idx = offset;\n    while ((idx < b.length) && (0 !== b[idx])) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n}\n\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if (('string' === typeof maxSpan)\n        && (undefined === property)) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.length - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    return span;\n  }\n}\n\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    return this.value;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = (property => new UInt(2, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = (property => new UInt(3, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = (property => new UInt(4, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = (property => new UInt(5, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = (property => new UInt(6, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = (property => new UIntBE(2, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = (property => new UIntBE(3, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = (property => new UIntBE(4, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = (property => new UIntBE(5, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = (property => new UIntBE(6, property));\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = (property => new NearUInt64BE(property));\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = (property => new Int(1, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = (property => new Int(2, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = (property => new Int(3, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = (property => new Int(4, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = (property => new Int(5, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = (property => new Int(6, property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = (property => new IntBE(2, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = (property => new IntBE(3, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = (property => new IntBE(4, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = (property => new IntBE(5, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = (property => new IntBE(6, property));\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = (property => new NearInt64BE(property));\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = (property => new Float(property));\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = (property => new FloatBE(property));\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = (property => new Double(property));\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = (property => new DoubleBE(property));\n\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n\n/** Factory for {@link CString} values. */\nexports.cstr = (property => new CString(property));\n\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n\n/** Factory for {@link Constant} values. */\nexports.const = ((value, property) => new Constant(value, property));\n","(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = require('buffer').Buffer;\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})(typeof module === 'undefined' || module, this);\n","import BN from 'bn.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport { NewAddressParamsPacked } from '../utils';\nimport { PackedCompressedAccountWithMerkleContext } from './compressed-account';\n\nexport enum TreeType {\n    /**\n     * v1 state merkle tree\n     */\n    StateV1 = 1,\n    /**\n     * v1 address merkle tree\n     */\n    AddressV1 = 2,\n    /**\n     * v2 state merkle tree\n     */\n    StateV2 = 3,\n    /**\n     * v2 address merkle tree\n     */\n    AddressV2 = 4,\n}\n\n/**\n * @deprecated Use {@link TreeInfo} instead.\n *\n * A bundle of active trees for a given tree type.\n */\nexport type ActiveTreeBundle = {\n    /**\n     * Tree.\n     */\n    tree: PublicKey;\n    /**\n     * Queue.\n     */\n    queue: PublicKey | null;\n    /**\n     * CPI context.\n     */\n    cpiContext: PublicKey | null;\n    /**\n     * Tree type.\n     */\n    treeType: TreeType;\n};\n\n/**\n * @deprecated Use {@link TreeInfo} instead.\n *\n * State tree info, versioned via {@link TreeType}. The protocol\n * stores compressed accounts in state trees.\n */\nexport type StateTreeInfo = TreeInfo;\n\n/**\n * Tree info, versioned via {@link TreeType}. The protocol\n * stores compressed accounts in state trees, and PDAs in address trees.\n *\n * Onchain Accounts are subject to Solana's write-lock limits.\n *\n * To load balance transactions, use {@link selectStateTreeInfo} to\n * randomly select a tree from a range of active trees.\n *\n * Example:\n * ```typescript\n * const infos = await rpc.getStateTreeInfos();\n * const info = selectStateTreeInfo(infos);\n * const ix = await CompressedTokenProgram.compress({\n *     // ...\n *     outputStateTreeInfo: info\n * });\n * ```\n */\nexport type TreeInfo = {\n    /**\n     * Pubkey of the tree account.\n     */\n    tree: PublicKey;\n    /**\n     * Pubkey of the queue account associated with the tree.\n     */\n    queue: PublicKey;\n    /**\n     * The type of tree. One of {@link TreeType}.\n     */\n    treeType: TreeType;\n    /**\n     * Optional compressed cpi context account.\n     */\n    cpiContext?: PublicKey;\n    /**\n     * Next tree info. Is `some` if the next tree should be used for the next\n     * state transition.\n     */\n    nextTreeInfo: TreeInfo | null;\n};\n\n/**\n * @deprecated Use {@link TreeInfo} instead.\n *\n * Address tree info, versioned via {@link TreeType}. The protocol\n * stores PDAs in address trees.\n */\nexport type AddressTreeInfo = Omit<\n    StateTreeInfo,\n    'cpiContext' | 'nextTreeInfo'\n> & {\n    /**\n     * Next tree info.\n     */\n    nextTreeInfo: AddressTreeInfo | null;\n};\n\n/**\n * Packed merkle context.\n */\nexport interface PackedMerkleContextLegacy {\n    /**\n     * Merkle tree pubkey index.\n     */\n    merkleTreePubkeyIndex: number;\n    /**\n     * Queue pubkey index in remaining accounts.\n     */\n    queuePubkeyIndex: number;\n    /**\n     * Leaf index.\n     */\n    leafIndex: number;\n    /**\n     * Whether to prove by index or validity proof.\n     */\n    proveByIndex: boolean;\n}\n\n/**\n * @deprecated Use {@link CompressedAccount} instead.\n *\n * Describe the generic compressed account details applicable to every\n * compressed account.\n *\n * */\nexport interface CompressedAccountLegacy {\n    /**\n     * Public key of program or user owning the account.\n     */\n    owner: PublicKey;\n    /**\n     * Lamports attached to the account.\n     */\n    lamports: BN;\n    /**\n     * Optional unique account ID that is persistent across transactions.\n     */\n    address: number[] | null;\n    /**\n     * Optional data attached to the account.\n     */\n    data: CompressedAccountData | null;\n}\n/**\n * @deprecated Use {@link CompressedAccountMeta} instead.\n *\n * Describe the generic compressed account details applicable to every\n * compressed account.\n */\nexport interface OutputCompressedAccountWithPackedContext {\n    compressedAccount: CompressedAccountLegacy;\n    merkleTreeIndex: number;\n}\n\n/**\n * Compressed account-related proof metadata.\n */\nexport type AccountProofInput = {\n    hash: BN;\n    treeInfo: TreeInfo;\n    leafIndex: number;\n    rootIndex: number;\n    proveByIndex: boolean;\n};\n\n/**\n * New address proof metadata.\n */\nexport type NewAddressProofInput = {\n    treeInfo: TreeInfo;\n    address: number[];\n    rootIndex: number;\n    root: BN;\n};\n\n/**\n * Describes compressed account data.\n */\nexport interface CompressedAccountData {\n    /**\n     * 8 bytes.\n     */\n    discriminator: number[];\n    /**\n     * Data.\n     */\n    data: Buffer;\n    /**\n     * 32 bytes.\n     */\n    dataHash: number[];\n}\n\n/**\n * Merkle tree sequence number.\n */\nexport interface MerkleTreeSequenceNumber {\n    /**\n     * Public key.\n     */\n    pubkey: PublicKey;\n    /**\n     * Sequence number.\n     */\n    seq: BN;\n}\n\n/**\n * Public transaction event.\n */\nexport interface PublicTransactionEvent {\n    /**\n     * Input compressed account hashes.\n     */\n    inputCompressedAccountHashes: number[][];\n    /**\n     * Output compressed account hashes.\n     */\n    outputCompressedAccountHashes: number[][];\n    /**\n     * Output compressed accounts.\n     */\n    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    /**\n     * Output leaf indices.\n     */\n    outputLeafIndices: number[];\n    /**\n     * Sequence numbers.\n     */\n    sequenceNumbers: MerkleTreeSequenceNumber[];\n    /**\n     * Relay fee. Default is null.\n     */\n    relayFee: BN | null;\n    /**\n     * Whether it's a compress or decompress instruction.\n     */\n    isCompress: boolean;\n    /**\n     * If some, it's either a compress or decompress instruction.\n     */\n    compressOrDecompressLamports: BN | null;\n    /**\n     * Public keys.\n     */\n    pubkeyArray: PublicKey[];\n    /**\n     * Message. Default is null.\n     */\n    message: Uint8Array | null;\n}\n\n/**\n * Instruction data for invoke.\n */\nexport interface InstructionDataInvoke {\n    /**\n     * Validity proof.\n     */\n    proof: ValidityProof | null;\n    /**\n     * Input compressed accounts with merkle context.\n     */\n    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];\n    /**\n     * Output compressed accounts.\n     */\n    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    /**\n     * Relay fee. Default is null.\n     */\n    relayFee: BN | null;\n    /**\n     * Params for creating new addresses.\n     */\n    newAddressParams: NewAddressParamsPacked[];\n    /**\n     * If some, it's either a compress or decompress instruction.\n     */\n    compressOrDecompressLamports: BN | null;\n    /**\n     * Whether it's a compress or decompress instruction.\n     */\n    isCompress: boolean;\n}\n\n/**\n * Instruction data for invoking a CPI.\n */\nexport interface InstructionDataInvokeCpi {\n    /**\n     * Validity proof.\n     */\n    proof: ValidityProof | null;\n    /**\n     * Input compressed accounts with merkle context.\n     */\n    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];\n    /**\n     * Output compressed accounts.\n     */\n    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    /**\n     * Relay fee. Default is null.\n     */\n    relayFee: BN | null;\n    /**\n     * Params for creating new addresses.\n     */\n    newAddressParams: NewAddressParamsPacked[];\n    /**\n     * If some, it's either a compress or decompress instruction.\n     */\n    compressOrDecompressLamports: BN | null;\n    /**\n     * If `compressOrDecompressLamports` is some, whether it's a compress or\n     * decompress instruction.\n     */\n    isCompress: boolean;\n    /**\n     * Optional compressed CPI context.\n     */\n    compressedCpiContext: CompressedCpiContext | null;\n}\n\n/**\n * Compressed CPI context.\n *\n * Use if you want to use a single {@link ValidityProof} to update two\n * compressed accounts owned by separate programs.\n */\nexport interface CompressedCpiContext {\n    /**\n     * Is set by the program that is invoking the CPI to signal that it should\n     * set the cpi context.\n     */\n    setContext: boolean;\n    /**\n     * Is set to wipe the cpi context since someone could have set it before\n     * with unrelated data.\n     */\n    firstSetContext: boolean;\n    /**\n     * Index of cpi context account in remaining accounts.\n     */\n    cpiContextAccountIndex: number;\n}\n\n/**\n * @deprecated Use {@link ValidityProof} instead.\n */\nexport interface CompressedProof {\n    /**\n     * 32 bytes.\n     */\n    a: number[];\n    /**\n     * 64 bytes.\n     */\n    b: number[];\n    /**\n     * 32 bytes.\n     */\n    c: number[];\n}\n\n/**\n * Validity proof.\n *\n * You can request proofs via `rpc.getValidityProof` or\n * `rpc.getValidityProofV0`.\n *\n * One proof can prove the existence of N compressed accounts or the uniqueness\n * of N PDAs.\n */\nexport interface ValidityProof {\n    /**\n     * 32 bytes.\n     */\n    a: number[];\n    /**\n     * 64 bytes.\n     */\n    b: number[];\n    /**\n     * 32 bytes.\n     */\n    c: number[];\n}\n\n/**\n * Packed token data for input compressed accounts.\n */\nexport interface InputTokenDataWithContext {\n    /**\n     * Amount of tokens.\n     */\n    amount: BN;\n    /**\n     * Delegate index.\n     */\n    delegateIndex: number | null;\n    /**\n     * Merkle context.\n     */\n    merkleContext: PackedMerkleContextLegacy;\n    /**\n     * Root index.\n     */\n    rootIndex: number;\n    /**\n     * Lamports.\n     */\n    lamports: BN | null;\n    /**\n     * Tlv.\n     */\n    tlv: Buffer | null;\n}\n\n/**\n * Token data.\n */\nexport type TokenData = {\n    /**\n     * The mint associated with this account.\n     */\n    mint: PublicKey;\n    /**\n     * The owner of this account.\n     */\n    owner: PublicKey;\n    /**\n     * The amount of tokens this account holds.\n     */\n    amount: BN;\n    /**\n     * If `delegate` is `Some` then `delegated_amount` represents the amount\n     * authorized by the delegate.\n     */\n    delegate: PublicKey | null;\n    /**\n     * The account's state.\n     */\n    state: number;\n    /**\n     * Token extension tlv.\n     */\n    tlv: Buffer | null;\n};\n","import BN from 'bn.js';\nimport { Buffer } from 'buffer';\nimport { ConfirmOptions, PublicKey } from '@solana/web3.js';\nimport { TreeInfo, TreeType } from './state/types';\n\nexport enum VERSION {\n    V1 = 'V1',\n    V2 = 'V2',\n}\n\n/**\n/**\n * @internal\n * Feature flags. Only use if you know what you are doing.\n */\nexport const featureFlags = {\n    version: ((): VERSION => {\n        // Check if we're in a build environment (replaced by rollup)\n        // eslint-disable-next-line no-constant-condition\n        if ('__BUILD_VERSION__' !== '__BUILD_' + 'VERSION__') {\n            return '__BUILD_VERSION__' as VERSION;\n        }\n        // Otherwise, check runtime environment variable (for tests)\n        if (\n            typeof process !== 'undefined' &&\n            process.env?.LIGHT_PROTOCOL_VERSION\n        ) {\n            return process.env.LIGHT_PROTOCOL_VERSION as VERSION;\n        }\n        // Default to V1\n        return VERSION.V1;\n    })(),\n    isV2: () =>\n        featureFlags.version.replace(/['\"]/g, '').toUpperCase() === 'V2',\n};\n\n/**\n * Returns the correct endpoint name for the current API version. E.g.\n * versionedEndpoint('getCompressedAccount') -> 'getCompressedAccount' (V1)\n * or 'getCompressedAccountV2' (V2)\n */\nexport const versionedEndpoint = (base: string) =>\n    featureFlags.isV2() ? `${base}V2` : base;\n\nexport const FIELD_SIZE = new BN(\n    '21888242871839275222246405745257275088548364400416034343698204186575808495617',\n);\nexport const HIGHEST_ADDRESS_PLUS_ONE = new BN(\n    '452312848583266388373324160190187140051835877600158453279131187530910662655',\n);\n\nexport const COMPUTE_BUDGET_PATTERN = [2, 64, 66, 15, 0];\n\nexport const INVOKE_DISCRIMINATOR = Buffer.from([\n    26, 16, 169, 7, 21, 202, 242, 25,\n]);\n\nexport const INVOKE_CPI_DISCRIMINATOR = Buffer.from([\n    49, 212, 191, 129, 39, 194, 43, 196,\n]);\n\nexport const INVOKE_CPI_WITH_READ_ONLY_DISCRIMINATOR = Buffer.from([\n    86, 47, 163, 166, 21, 223, 92, 8,\n]);\n\nexport const INVOKE_CPI_WITH_ACCOUNT_INFO_DISCRIMINATOR = Buffer.from([\n    228, 34, 128, 84, 47, 139, 86, 240,\n]);\n\nexport const INSERT_INTO_QUEUES_DISCRIMINATOR = Buffer.from([\n    180, 143, 159, 153, 35, 46, 248, 163,\n]);\n\nexport const noopProgram = 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV';\nexport const lightSystemProgram = 'SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7';\nexport const accountCompressionProgram =\n    'compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq';\n\nexport const getRegisteredProgramPda = () =>\n    new PublicKey('35hkDgaAKwMCaxRz2ocSZ6NaUrtKkyNqU6c4RV3tYJRh');\n\nexport const getAccountCompressionAuthority = () =>\n    PublicKey.findProgramAddressSync(\n        [Buffer.from('cpi_authority')],\n        new PublicKey(lightSystemProgram),\n    )[0];\n\nexport const defaultStaticAccounts = () => [\n    new PublicKey(getRegisteredProgramPda()),\n    new PublicKey(noopProgram),\n    new PublicKey(accountCompressionProgram),\n    new PublicKey(getAccountCompressionAuthority()),\n];\n\nexport const defaultStaticAccountsStruct = () => {\n    return {\n        registeredProgramPda: new PublicKey(getRegisteredProgramPda()),\n        noopProgram: new PublicKey(noopProgram),\n        accountCompressionProgram: new PublicKey(accountCompressionProgram),\n        accountCompressionAuthority: new PublicKey(\n            getAccountCompressionAuthority(),\n        ),\n        cpiSignatureAccount: null,\n    };\n};\n\nexport type StateTreeLUTPair = {\n    stateTreeLookupTable: PublicKey;\n    nullifyLookupTable: PublicKey;\n};\n\n/**\n * Returns the Default Public State Tree LUTs for Devnet and Mainnet-Beta.\n */\nexport const defaultStateTreeLookupTables = (): {\n    mainnet: StateTreeLUTPair[];\n    devnet: StateTreeLUTPair[];\n} => {\n    return {\n        mainnet: [\n            {\n                stateTreeLookupTable: new PublicKey(\n                    stateTreeLookupTableMainnet,\n                ),\n                nullifyLookupTable: new PublicKey(\n                    nullifiedStateTreeLookupTableMainnet,\n                ),\n            },\n        ],\n        devnet: [\n            {\n                stateTreeLookupTable: new PublicKey(stateTreeLookupTableDevnet),\n                nullifyLookupTable: new PublicKey(\n                    nullifiedStateTreeLookupTableDevnet,\n                ),\n            },\n        ],\n    };\n};\n\n/**\n * @internal\n */\nexport const isLocalTest = (url: string) => {\n    return url.includes('localhost') || url.includes('127.0.0.1');\n};\n\n/**\n * @internal\n */\nexport const localTestActiveStateTreeInfos = (): TreeInfo[] => {\n    return [\n        {\n            tree: new PublicKey(merkletreePubkey),\n            queue: new PublicKey(nullifierQueuePubkey),\n            cpiContext: new PublicKey(cpiContextPubkey),\n            treeType: TreeType.StateV1,\n            nextTreeInfo: null,\n        },\n        {\n            tree: new PublicKey(merkleTree2Pubkey),\n            queue: new PublicKey(nullifierQueue2Pubkey),\n            cpiContext: new PublicKey(cpiContext2Pubkey),\n            treeType: TreeType.StateV1,\n            nextTreeInfo: null,\n        },\n        {\n            tree: new PublicKey(batchMerkleTree),\n            queue: new PublicKey(batchQueue),\n            cpiContext: PublicKey.default,\n            treeType: TreeType.StateV2,\n            nextTreeInfo: null,\n        },\n    ].filter(info =>\n        featureFlags.isV2() ? true : info.treeType === TreeType.StateV1,\n    );\n};\n\nexport const getDefaultAddressTreeInfo = () => {\n    return {\n        tree: new PublicKey(addressTree),\n        queue: new PublicKey(addressQueue),\n        cpiContext: null,\n        treeType: TreeType.AddressV1,\n        nextTreeInfo: null,\n    };\n};\n/**\n * @deprecated use {@link rpc.getStateTreeInfos} and {@link selectStateTreeInfo} instead.\n * for address trees, use {@link getDefaultAddressTreeInfo} instead.\n * Use only with Localnet testing.\n * For public networks, fetch via {@link defaultStateTreeLookupTables} and {@link getAllStateTreeInfos}.\n */\nexport const defaultTestStateTreeAccounts = () => {\n    return {\n        nullifierQueue: new PublicKey(nullifierQueuePubkey),\n        merkleTree: new PublicKey(merkletreePubkey),\n        merkleTreeHeight: DEFAULT_MERKLE_TREE_HEIGHT,\n        addressTree: new PublicKey(addressTree),\n        addressQueue: new PublicKey(addressQueue),\n    };\n};\n\n/**\n * @internal testing only\n */\nexport const defaultTestStateTreeAccounts2 = () => {\n    return {\n        nullifierQueue2: new PublicKey(nullifierQueue2Pubkey),\n        merkleTree2: new PublicKey(merkleTree2Pubkey),\n    };\n};\n\nexport const COMPRESSED_TOKEN_PROGRAM_ID = new PublicKey(\n    'cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m',\n);\nexport const stateTreeLookupTableMainnet =\n    '7i86eQs3GSqHjN47WdWLTCGMW6gde1q96G2EVnUyK2st';\nexport const nullifiedStateTreeLookupTableMainnet =\n    'H9QD4u1fG7KmkAzn2tDXhheushxFe1EcrjGGyEFXeMqT';\n\nexport const stateTreeLookupTableDevnet =\n    'Dk9mNkbiZXJZ4By8DfSP6HEE4ojZzRvucwpawLeuwq8q';\nexport const nullifiedStateTreeLookupTableDevnet =\n    'AXbHzp1NgjLvpfnD6JRTTovXZ7APUCdtWZFCRr5tCxse';\n\nexport const nullifierQueuePubkey =\n    'nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148';\nexport const cpiContextPubkey = 'cpi1uHzrEhBG733DoEJNgHCyRS3XmmyVNZx5fonubE4';\n\nexport const merkletreePubkey = 'smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT';\nexport const addressTree = 'amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2';\nexport const addressQueue = 'aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F';\n\nexport const merkleTree2Pubkey = 'smt2rJAFdyJJupwMKAqTNAJwvjhmiZ4JYGZmbVRw1Ho';\nexport const nullifierQueue2Pubkey =\n    'nfq2hgS7NYemXsFaFUCe3EMXSDSfnZnAe27jC6aPP1X';\nexport const cpiContext2Pubkey = 'cpi2cdhkH5roePvcudTgUL8ppEBfTay1desGh8G8QxK';\n\n// V2 testing.\nexport const batchMerkleTree = 'HLKs5NJ8FXkJg8BrzJt56adFYYuwg5etzDtBbQYTsixu'; // v2 merkle tree (includes nullifier queue)\nexport const batchQueue = '6L7SzhYB3anwEQ9cphpJ1U7Scwj57bx2xueReg7R9cKU'; // v2 output queue\n\nexport const confirmConfig: ConfirmOptions = {\n    commitment: 'confirmed',\n    preflightCommitment: 'confirmed',\n};\n\nexport const DEFAULT_MERKLE_TREE_HEIGHT = 26;\nexport const DEFAULT_MERKLE_TREE_ROOTS = 2800;\n/** Threshold (per asset) at which new in-UTXOs get merged, in order to reduce UTXO pool size */\nexport const UTXO_MERGE_THRESHOLD = 20;\nexport const UTXO_MERGE_MAXIMUM = 10;\n\n/**\n * Treshold after which the currently used transaction Merkle tree is switched\n * to the next one\n */\nexport const TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD = new BN(\n    Math.floor(2 ** DEFAULT_MERKLE_TREE_HEIGHT * 0.95),\n);\n\n/**\n * Fee to provide continous funding for the state Merkle tree.\n * Once the state Merkle tree is at 95% capacity the accumulated fees\n * will be used to fund the next state Merkle tree with the same parameters.\n *\n * Is charged per output compressed account.\n */\nexport const STATE_MERKLE_TREE_ROLLOVER_FEE = featureFlags.isV2()\n    ? new BN(1)\n    : new BN(300);\n\n/**\n * Fee to provide continous funding for the address queue and address Merkle tree.\n * Once the address Merkle tree is at 95% capacity the accumulated fees\n * will be used to fund the next address queue and address tree with the same parameters.\n *\n * Is charged per newly created address.\n */\nexport const ADDRESS_QUEUE_ROLLOVER_FEE = featureFlags.isV2()\n    ? new BN(392)\n    : new BN(392);\n\n/**\n * Is charged if the transaction nullifies at least one compressed account.\n */\nexport const STATE_MERKLE_TREE_NETWORK_FEE = new BN(5000);\n\n/**\n * Is charged if the transaction creates at least one address.\n */\nexport const ADDRESS_TREE_NETWORK_FEE = new BN(5000);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i256 = exports.u256 = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;\nconst buffer_layout_1 = require(\"buffer-layout\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nvar buffer_layout_2 = require(\"buffer-layout\");\nObject.defineProperty(exports, \"u8\", { enumerable: true, get: function () { return buffer_layout_2.u8; } });\nObject.defineProperty(exports, \"i8\", { enumerable: true, get: function () { return buffer_layout_2.s8; } });\nObject.defineProperty(exports, \"u16\", { enumerable: true, get: function () { return buffer_layout_2.u16; } });\nObject.defineProperty(exports, \"i16\", { enumerable: true, get: function () { return buffer_layout_2.s16; } });\nObject.defineProperty(exports, \"u32\", { enumerable: true, get: function () { return buffer_layout_2.u32; } });\nObject.defineProperty(exports, \"i32\", { enumerable: true, get: function () { return buffer_layout_2.s32; } });\nObject.defineProperty(exports, \"f32\", { enumerable: true, get: function () { return buffer_layout_2.f32; } });\nObject.defineProperty(exports, \"f64\", { enumerable: true, get: function () { return buffer_layout_2.f64; } });\nObject.defineProperty(exports, \"struct\", { enumerable: true, get: function () { return buffer_layout_2.struct; } });\nclass BNLayout extends buffer_layout_1.Layout {\n    constructor(span, signed, property) {\n        super(span, property);\n        this.blob = (0, buffer_layout_1.blob)(span);\n        this.signed = signed;\n    }\n    decode(b, offset = 0) {\n        const num = new bn_js_1.default(this.blob.decode(b, offset), 10, \"le\");\n        if (this.signed) {\n            return num.fromTwos(this.span * 8).clone();\n        }\n        return num;\n    }\n    encode(src, b, offset = 0) {\n        if (this.signed) {\n            src = src.toTwos(this.span * 8);\n        }\n        return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\n    }\n}\nfunction u64(property) {\n    return new BNLayout(8, false, property);\n}\nexports.u64 = u64;\nfunction i64(property) {\n    return new BNLayout(8, true, property);\n}\nexports.i64 = i64;\nfunction u128(property) {\n    return new BNLayout(16, false, property);\n}\nexports.u128 = u128;\nfunction i128(property) {\n    return new BNLayout(16, true, property);\n}\nexports.i128 = i128;\nfunction u256(property) {\n    return new BNLayout(32, false, property);\n}\nexports.u256 = u256;\nfunction i256(property) {\n    return new BNLayout(32, true, property);\n}\nexports.i256 = i256;\nclass WrappedLayout extends buffer_layout_1.Layout {\n    constructor(layout, decoder, encoder, property) {\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nfunction publicKey(property) {\n    return new WrappedLayout((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);\n}\nexports.publicKey = publicKey;\nclass OptionLayout extends buffer_layout_1.Layout {\n    constructor(layout, property) {\n        super(-1, property);\n        this.layout = layout;\n        this.discriminator = (0, buffer_layout_1.u8)();\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.discriminator.encode(0, b, offset);\n        }\n        this.discriminator.encode(1, b, offset);\n        return this.layout.encode(src, b, offset + 1) + 1;\n    }\n    decode(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return null;\n        }\n        else if (discriminator === 1) {\n            return this.layout.decode(b, offset + 1);\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n    getSpan(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return 1;\n        }\n        else if (discriminator === 1) {\n            return this.layout.getSpan(b, offset + 1) + 1;\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n}\nfunction option(layout, property) {\n    return new OptionLayout(layout, property);\n}\nexports.option = option;\nfunction bool(property) {\n    return new WrappedLayout((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);\n}\nexports.bool = bool;\nfunction decodeBool(value) {\n    if (value === 0) {\n        return false;\n    }\n    else if (value === 1) {\n        return true;\n    }\n    throw new Error(\"Invalid bool: \" + value);\n}\nfunction encodeBool(value) {\n    return value ? 1 : 0;\n}\nfunction vec(elementLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);\n}\nexports.vec = vec;\nfunction tagged(tag, layout, property) {\n    const wrappedLayout = (0, buffer_layout_1.struct)([\n        u64(\"tag\"),\n        layout.replicate(\"data\"),\n    ]);\n    function decodeTag({ tag: receivedTag, data }) {\n        if (!receivedTag.eq(tag)) {\n            throw new Error(\"Invalid tag, expected: \" +\n                tag.toString(\"hex\") +\n                \", got: \" +\n                receivedTag.toString(\"hex\"));\n        }\n        return data;\n    }\n    return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);\n}\nexports.tagged = tagged;\nfunction vecU8(property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), \"data\"),\n    ]);\n    return new WrappedLayout(layout, ({ data }) => data, (data) => ({ data }), property);\n}\nexports.vecU8 = vecU8;\nfunction str(property) {\n    return new WrappedLayout(vecU8(), (data) => data.toString(\"utf-8\"), (s) => Buffer.from(s, \"utf-8\"), property);\n}\nexports.str = str;\nfunction rustEnum(variants, property, discriminant) {\n    const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);\n    variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\n    return unionLayout;\n}\nexports.rustEnum = rustEnum;\nfunction array(elementLayout, length, property) {\n    const layout = (0, buffer_layout_1.struct)([\n        (0, buffer_layout_1.seq)(elementLayout, length, \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);\n}\nexports.array = array;\nclass MapEntryLayout extends buffer_layout_1.Layout {\n    constructor(keyLayout, valueLayout, property) {\n        super(keyLayout.span + valueLayout.span, property);\n        this.keyLayout = keyLayout;\n        this.valueLayout = valueLayout;\n    }\n    decode(b, offset) {\n        offset = offset || 0;\n        const key = this.keyLayout.decode(b, offset);\n        const value = this.valueLayout.decode(b, offset + this.keyLayout.getSpan(b, offset));\n        return [key, value];\n    }\n    encode(src, b, offset) {\n        offset = offset || 0;\n        const keyBytes = this.keyLayout.encode(src[0], b, offset);\n        const valueBytes = this.valueLayout.encode(src[1], b, offset + keyBytes);\n        return keyBytes + valueBytes;\n    }\n    getSpan(b, offset) {\n        return (this.keyLayout.getSpan(b, offset) + this.valueLayout.getSpan(b, offset));\n    }\n}\nfunction map(keyLayout, valueLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);\n}\nexports.map = map;\n//# sourceMappingURL=index.js.map","import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (source[psz]) {\n      // Decode character\n      let carry = BASE_MAP[source.charCodeAt(psz)]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n","import { FIELD_SIZE } from '../constants';\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\nimport { Buffer } from 'buffer';\n\n/**\n * bignumber with <254-bit max size. Anchor serialization doesn't support native\n * bigint yet, so we wrap BN. This wrapper has simple base10 encoding which is\n * needed for zk circuit compat, in addition to the base58 encoding that users\n * are used to from working with the web3.js PublicKey type.\n */\nexport type BN254 = BN;\n\n/** Create a bigint instance with <254-bit max size and base58 capabilities */\nexport const createBN254 = (\n    number: string | number | BN | Buffer | Uint8Array | number[],\n    base?: number | 'hex' | 'base58' | undefined,\n): BN254 => {\n    if (base === 'base58') {\n        if (typeof number !== 'string')\n            throw new Error('Must be a base58 string');\n        return createBN254(bs58.decode(number));\n    }\n\n    const bigintNumber = new BN(number, base);\n\n    return enforceSize(bigintNumber);\n};\n\n/**\n * Enforces a maximum size of <254 bits for bigint instances. This is necessary\n * for compatibility with zk-SNARKs, where hashes must be less than the field\n * modulus (~2^254).\n */\nfunction enforceSize(bigintNumber: BN254): BN254 {\n    if (bigintNumber.gte(FIELD_SIZE)) {\n        throw new Error('Value is too large. Max <254 bits');\n    }\n    return bigintNumber;\n}\n\n/** Convert <254-bit bigint to Base58 string.  */\nexport function encodeBN254toBase58(bigintNumber: BN): string {\n    /// enforce size\n    const bn254 = createBN254(bigintNumber);\n    const bn254Buffer = bn254.toArrayLike(Buffer, undefined, 32);\n\n    return bs58.encode(new Uint8Array(bn254Buffer));\n}\n","import BN from 'bn.js';\nimport { Buffer } from 'buffer';\nexport const bn = (\n    number: string | number | BN | Buffer | Uint8Array | number[],\n    base?: number | 'hex' | undefined,\n    endian?: BN.Endianness | undefined,\n): BN => {\n    if (number instanceof Uint8Array && !(number instanceof Buffer)) {\n        return new BN(Buffer.from(number), base, endian);\n    }\n    return new BN(number, base, endian);\n};\n","import { PublicKey } from '@solana/web3.js';\nimport {\n    CompressedAccountData,\n    CompressedAccountLegacy,\n    PackedMerkleContextLegacy,\n    TreeInfo,\n} from './types';\nimport BN from 'bn.js';\nimport { BN254 } from './BN254';\n\n/**\n * @deprecated use {@link CompressedAccount} instead\n */\nexport type CompressedAccountWithMerkleContext = CompressedAccount &\n    MerkleContext & {\n        readOnly: boolean;\n    };\n\n/**\n * @deprecated use {@link CompressedAccount} instead\n */\nexport type CompressedAccountWithMerkleContextLegacy = CompressedAccount &\n    MerkleContext;\n\n/**\n * Compressed account + metadata about the state tree in which the account is\n * stored.\n */\nexport type CompressedAccount = {\n    /**\n     * Public key of program or user owning the account.\n     */\n    owner: PublicKey;\n    /**\n     * Lamports attached to the account.\n     */\n    lamports: BN;\n    /**\n     * Optional unique account ID that is persistent across transactions.\n     */\n    address: number[] | null;\n    /**\n     * Optional data attached to the account.\n     */\n    data: CompressedAccountData | null;\n} & MerkleContext & {\n        /**\n         * Read only.\n         */\n        readOnly: boolean;\n    };\n\n/**\n * @deprecated use {@link MerkleContext} instead.\n *\n * Legacy MerkleContext.\n */\nexport type MerkleContextLegacy = {\n    /**\n     * State tree\n     */\n    merkleTree: PublicKey;\n    /**\n     * Nullifier queue\n     */\n    nullifierQueue: PublicKey;\n    /**\n     * Poseidon hash of the account. Stored as leaf in state tree\n     */\n    hash: number[];\n    /**\n     * Position of `hash` in the State tree\n     */\n    leafIndex: number;\n};\n\n/**\n * Context for compressed account stored in a state tree\n */\nexport type MerkleContext = {\n    /**\n     * Tree info\n     */\n    treeInfo: TreeInfo;\n    /**\n     * Poseidon hash of the account. Stored as leaf in state tree\n     */\n    hash: BN;\n    /**\n     * Position of `hash` in the State tree\n     */\n    leafIndex: number;\n    /**\n     * Whether the account can be proven by index or by merkle proof\n     */\n    proveByIndex: boolean;\n};\n\n/**\n * MerkleContext with merkle proof\n */\nexport type MerkleContextWithMerkleProof = MerkleContext & {\n    /**\n     * Recent valid 'hash' proof path, expires after n slots\n     */\n    merkleProof: BN254[];\n    /**\n     * Index of state root the merkleproof is valid for, expires after n slots\n     */\n    rootIndex: number;\n    /**\n     * Current root\n     */\n    root: BN254;\n};\n\n/**\n * Packed compressed account and state tree info.\n */\nexport type PackedStateTreeInfo = {\n    /**\n     * Recent valid root index.\n     */\n    rootIndex: number;\n    /**\n     * Whether the account can be proven by index or by merkle proof\n     */\n    proveByIndex: boolean;\n    /**\n     * Index of the merkle tree in which the account is stored.\n     */\n    merkleTreePubkeyIndex: number;\n    /**\n     * Index of the queue in which the account is stored.\n     */\n    queuePubkeyIndex: number;\n    /**\n     * Index of the leaf in the state tree.\n     */\n    leafIndex: number;\n};\n\n/**\n * Packed tree info for a new program-derived address (PDA).\n */\nexport type PackedAddressTreeInfo = {\n    /**\n     * Index of the merkle tree in which the account is stored.\n     */\n    addressMerkleTreePubkeyIndex: number;\n    /**\n     * Index of the queue in which the account is stored.\n     */\n    addressQueuePubkeyIndex: number;\n    /**\n     * Recent valid root index.\n     */\n    rootIndex: number;\n};\n\n/**\n * Compressed account meta in instruction.\n *\n */\nexport type CompressedAccountMeta = {\n    /**\n     * Packed Tree info.\n     */\n    treeInfo: PackedStateTreeInfo;\n    /**\n     * Address.\n     */\n    address: number[] | null;\n    /**\n     * Lamports.\n     */\n    lamports: BN | null;\n    /**\n     * index of state tree in which the new account state is stored.\n     */\n    outputStateTreeIndex: number;\n};\n\n/**\n * Create an output compressed account meta for a new account.\n * Client-side only.\n */\nexport const createCompressedAccountMeta = (\n    treeInfo: PackedStateTreeInfo,\n    outputStateTreeIndex: number,\n    address?: number[],\n    lamports?: BN,\n): CompressedAccountMeta => ({\n    treeInfo,\n    outputStateTreeIndex,\n    address: address ?? null,\n    lamports: lamports ?? null,\n});\n\n/**\n * @deprecated Use {@link PackedStateTreeInfo} instead.\n * Packed compressed account with merkle context.\n */\nexport interface PackedCompressedAccountWithMerkleContext {\n    /**\n     * Compressed account.\n     */\n    compressedAccount: CompressedAccountLegacy;\n    /**\n     * Merkle context.\n     */\n    merkleContext: PackedMerkleContextLegacy;\n    /**\n     * Root index.\n     */\n    rootIndex: number;\n    /**\n     * Read only.\n     */\n    readOnly: boolean;\n}\n\n/**\n * @deprecated use {@link createCompressedAccountMeta} instead.\n */\nexport const createCompressedAccountLegacy = (\n    owner: PublicKey,\n    lamports?: BN,\n    data?: CompressedAccountData,\n    address?: number[],\n): CompressedAccountLegacy => ({\n    owner,\n    lamports: lamports ?? new BN(0),\n    address: address ?? null,\n    data: data ?? null,\n});\n/**\n * @deprecated.\n */\nexport const createCompressedAccountWithMerkleContextLegacy = (\n    merkleContext: MerkleContext,\n    owner: PublicKey,\n    lamports?: BN,\n    data?: CompressedAccountData,\n    address?: number[],\n): CompressedAccountWithMerkleContext => ({\n    ...merkleContext,\n    owner,\n    lamports: lamports ?? new BN(0),\n    address: address ?? null,\n    data: data ?? null,\n    readOnly: false,\n});\n\n/**\n * @deprecated use {@link createCompressedAccountMeta} instead.\n */\nexport const createMerkleContextLegacy = (\n    treeInfo: TreeInfo,\n    hash: BN254,\n    leafIndex: number,\n    proveByIndex: boolean = false,\n): MerkleContext => ({\n    treeInfo,\n    hash,\n    leafIndex,\n    proveByIndex,\n});\n","import { Buffer } from 'buffer';\nimport { PublicKey, AccountMeta } from '@solana/web3.js';\nimport {\n    struct,\n    u8,\n    u64,\n    bool,\n    vec,\n    option,\n    publicKey,\n    array,\n    u16,\n    u32,\n    Layout,\n    vecU8,\n} from '@coral-xyz/borsh';\nimport {\n    bn,\n    InstructionDataInvoke,\n    InstructionDataInvokeCpi,\n    PublicTransactionEvent,\n} from '../../state';\nimport { LightSystemProgram } from '.';\nimport {\n    INVOKE_CPI_DISCRIMINATOR,\n    INVOKE_CPI_WITH_READ_ONLY_DISCRIMINATOR,\n    INVOKE_DISCRIMINATOR,\n} from '../../constants';\n\nexport const CompressedAccountLayout = struct(\n    [\n        publicKey('owner'),\n        u64('lamports'),\n        option(array(u8(), 32), 'address'),\n        option(\n            struct([\n                array(u8(), 8, 'discriminator'),\n                vecU8('data'),\n                array(u8(), 32, 'dataHash'),\n            ]),\n            'data',\n        ),\n    ],\n    'compressedAccount',\n);\n\nexport const MerkleContextLayout = struct(\n    [\n        u8('merkleTreePubkeyIndex'),\n        u8('queuePubkeyIndex'),\n        u32('leafIndex'),\n        bool('proveByIndex'),\n    ],\n    'merkleContext',\n);\n\nexport const NewAddressParamsLayout = struct(\n    [\n        array(u8(), 32, 'seed'),\n        u8('addressQueueAccountIndex'),\n        u8('addressMerkleTreeAccountIndex'),\n        u16('addressMerkleTreeRootIndex'),\n    ],\n    'newAddressParams',\n);\n\nexport const InstructionDataInvokeLayout: Layout<InstructionDataInvoke> =\n    struct([\n        option(\n            struct([\n                array(u8(), 32, 'a'),\n                array(u8(), 64, 'b'),\n                array(u8(), 32, 'c'),\n            ]),\n            'proof',\n        ),\n        vec(\n            struct([\n                CompressedAccountLayout,\n                MerkleContextLayout,\n                u16('rootIndex'),\n                bool('readOnly'),\n            ]),\n            'inputCompressedAccountsWithMerkleContext',\n        ),\n        vec(\n            struct([CompressedAccountLayout, u8('merkleTreeIndex')]),\n            'outputCompressedAccounts',\n        ),\n        option(u64(), 'relayFee'),\n        vec(NewAddressParamsLayout, 'newAddressParams'),\n        option(u64(), 'compressOrDecompressLamports'),\n        bool('isCompress'),\n    ]);\n\nexport function encodeInstructionDataInvoke(\n    data: InstructionDataInvoke,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n    const len = InstructionDataInvokeLayout.encode(data, buffer);\n    const dataBuffer = Buffer.from(new Uint8Array(buffer.slice(0, len)));\n    const lengthBuffer = Buffer.alloc(4);\n    lengthBuffer.writeUInt32LE(len, 0);\n    return Buffer.concat([\n        new Uint8Array(INVOKE_DISCRIMINATOR),\n        new Uint8Array(lengthBuffer),\n        new Uint8Array(dataBuffer),\n    ]);\n}\n\nexport const InstructionDataInvokeCpiLayout: Layout<InstructionDataInvokeCpi> =\n    struct([\n        option(\n            struct([\n                array(u8(), 32, 'a'),\n                array(u8(), 64, 'b'),\n                array(u8(), 32, 'c'),\n            ]),\n            'proof',\n        ),\n        vec(NewAddressParamsLayout, 'newAddressParams'),\n        vec(\n            struct([\n                CompressedAccountLayout,\n                MerkleContextLayout,\n                u16('rootIndex'),\n                bool('readOnly'),\n            ]),\n            'inputCompressedAccountsWithMerkleContext',\n        ),\n        vec(\n            struct([CompressedAccountLayout, u8('merkleTreeIndex')]),\n            'outputCompressedAccounts',\n        ),\n        option(u64(), 'relayFee'),\n        option(u64(), 'compressOrDecompressLamports'),\n        bool('isCompress'),\n        option(\n            struct([\n                bool('set_context'),\n                bool('first_set_context'),\n                u8('cpi_context_account_index'),\n            ]),\n            'compressedCpiContext',\n        ),\n    ]);\n\nexport const CompressedProofLayout = struct(\n    [array(u8(), 32, 'a'), array(u8(), 64, 'b'), array(u8(), 32, 'c')],\n    'compressedProof',\n);\n\nexport const CompressedCpiContextLayout = struct(\n    [\n        bool('set_context'),\n        bool('first_set_context'),\n        u8('cpi_context_account_index'),\n    ],\n    'compressedCpiContext',\n);\n\nexport const NewAddressParamsAssignedPackedLayout = struct(\n    [\n        array(u8(), 32, 'seed'),\n        u8('address_queue_account_index'),\n        u8('address_merkle_tree_account_index'),\n        u16('address_merkle_tree_root_index'),\n        bool('assigned_to_account'),\n        u8('assigned_account_index'),\n    ],\n    'newAddressParamsAssignedPacked',\n);\n\nexport const PackedMerkleContextLayout = struct(\n    [\n        u8('merkle_tree_pubkey_index'),\n        u8('queue_pubkey_index'),\n        u32('leaf_index'),\n        bool('prove_by_index'),\n    ],\n    'packedMerkleContext',\n);\n\nexport const InAccountLayout = struct(\n    [\n        array(u8(), 8, 'discriminator'),\n        array(u8(), 32, 'data_hash'),\n        PackedMerkleContextLayout,\n        u16('root_index'),\n        u64('lamports'),\n        option(array(u8(), 32), 'address'),\n    ],\n    'inAccount',\n);\n\nexport const PackedReadOnlyAddressLayout = struct(\n    [\n        array(u8(), 32, 'address'),\n        u16('address_merkle_tree_root_index'),\n        u8('address_merkle_tree_account_index'),\n    ],\n    'packedReadOnlyAddress',\n);\n\nexport const PackedReadOnlyCompressedAccountLayout = struct(\n    [\n        array(u8(), 32, 'account_hash'),\n        PackedMerkleContextLayout,\n        u16('root_index'),\n    ],\n    'packedReadOnlyCompressedAccount',\n);\n\nexport const InstructionDataInvokeCpiWithReadOnlyLayout = struct([\n    u8('mode'),\n    u8('bump'),\n    publicKey('invoking_program_id'),\n    u64('compress_or_decompress_lamports'),\n    bool('is_compress'),\n    bool('with_cpi_context'),\n    bool('with_transaction_hash'),\n    CompressedCpiContextLayout,\n    option(CompressedProofLayout, 'proof'),\n    vec(NewAddressParamsAssignedPackedLayout, 'new_address_params'),\n    vec(InAccountLayout, 'input_compressed_accounts'),\n    vec(\n        struct([CompressedAccountLayout, u8('merkleTreeIndex')]),\n        'output_compressed_accounts',\n    ),\n    vec(PackedReadOnlyAddressLayout, 'read_only_addresses'),\n    vec(PackedReadOnlyCompressedAccountLayout, 'read_only_accounts'),\n]);\n\nexport function decodeInstructionDataInvokeCpiWithReadOnly(buffer: Buffer) {\n    return InstructionDataInvokeCpiWithReadOnlyLayout.decode(\n        buffer.slice(INVOKE_CPI_WITH_READ_ONLY_DISCRIMINATOR.length),\n    );\n}\n\nexport function decodeInstructionDataInvoke(\n    buffer: Buffer,\n): InstructionDataInvoke {\n    return InstructionDataInvokeLayout.decode(\n        buffer.slice(INVOKE_DISCRIMINATOR.length + 4),\n    );\n}\n\nexport function decodeInstructionDataInvokeCpi(\n    buffer: Buffer,\n): InstructionDataInvokeCpi {\n    return InstructionDataInvokeCpiLayout.decode(\n        buffer.slice(INVOKE_CPI_DISCRIMINATOR.length + 4),\n    );\n}\n\nexport type invokeAccountsLayoutParams = {\n    /**\n     * Fee payer.\n     */\n    feePayer: PublicKey;\n    /**\n     * Authority.\n     */\n    authority: PublicKey;\n    /**\n     * The registered program pda\n     */\n    registeredProgramPda: PublicKey;\n    /**\n     * Noop program.\n     */\n    noopProgram: PublicKey;\n    /**\n     * Account compression authority.\n     */\n    accountCompressionAuthority: PublicKey;\n    /**\n     * Account compression program.\n     */\n    accountCompressionProgram: PublicKey;\n    /**\n     * Solana pool pda. Some() if compression or decompression is done.\n     */\n    solPoolPda: PublicKey | null;\n    /**\n     * Decompression recipient.\n     */\n    decompressionRecipient: PublicKey | null;\n    /**\n     * Solana system program.\n     */\n    systemProgram: PublicKey;\n};\n\nexport const invokeAccountsLayout = (\n    accounts: invokeAccountsLayoutParams,\n): AccountMeta[] => {\n    const defaultPubkey = LightSystemProgram.programId;\n    const {\n        feePayer,\n        authority,\n        registeredProgramPda,\n        noopProgram,\n        accountCompressionAuthority,\n        accountCompressionProgram,\n        solPoolPda,\n        decompressionRecipient,\n        systemProgram,\n    } = accounts;\n\n    return [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: authority, isSigner: true, isWritable: false },\n        { pubkey: registeredProgramPda, isSigner: false, isWritable: false },\n        { pubkey: noopProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: accountCompressionAuthority,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: accountCompressionProgram,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: solPoolPda ?? defaultPubkey,\n            isSigner: false,\n            isWritable: solPoolPda !== null,\n        },\n        {\n            pubkey: decompressionRecipient ?? defaultPubkey,\n            isSigner: false,\n            isWritable: true,\n        },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n    ];\n};\n\nexport const PublicTransactionEventLayout: Layout<PublicTransactionEvent> =\n    struct([\n        vec(array(u8(), 32), 'inputCompressedAccountHashes'),\n        vec(array(u8(), 32), 'outputCompressedAccountHashes'),\n        vec(\n            struct([\n                struct(\n                    [\n                        publicKey('owner'),\n                        u64('lamports'),\n                        option(array(u8(), 32), 'address'),\n                        option(\n                            struct([\n                                array(u8(), 8, 'discriminator'),\n                                vecU8('data'),\n                                array(u8(), 32, 'dataHash'),\n                            ]),\n                            'data',\n                        ),\n                    ],\n                    'compressedAccount',\n                ),\n                u8('merkleTreeIndex'),\n            ]),\n            'outputCompressedAccounts',\n        ),\n        vec(u32(), 'outputLeafIndices'),\n        vec(\n            struct([\n                publicKey('tree_pubkey'),\n                publicKey('queue_pubkey'),\n                u64('tree_type'),\n                u64('seq'),\n            ]),\n            'sequenceNumbers',\n        ),\n        option(u64(), 'relayFee'),\n        bool('isCompress'),\n        option(u64(), 'compressOrDecompressLamports'),\n        vec(publicKey(), 'pubkeyArray'),\n        option(vecU8(), 'message'),\n    ]);\n\nexport function encodePublicTransactionEvent(\n    data: PublicTransactionEvent,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n    const len = PublicTransactionEventLayout.encode(data, buffer);\n\n    return buffer.slice(0, len);\n}\n\nexport function decodePublicTransactionEvent(\n    buffer: Buffer,\n): PublicTransactionEvent {\n    return PublicTransactionEventLayout.decode(buffer);\n}\n\nexport const AppendNullifyCreateAddressInputsMetaLayout = struct(\n    [\n        u8('is_invoked_by_program'),\n        u8('bump'),\n        u8('num_queues'),\n        u8('num_output_queues'),\n        u8('start_output_appends'),\n        u8('num_address_queues'),\n        array(u8(), 32, 'tx_hash'),\n    ],\n    'appendNullifyCreateAddressInputsMeta',\n);\n\nexport const AppendLeavesInputLayout = struct(\n    [u8('index'), array(u8(), 32, 'leaf')],\n    'appendLeavesInput',\n);\n\nexport const InsertNullifierInputLayout = struct(\n    [\n        array(u8(), 32, 'account_hash'),\n        u32('leaf_index'),\n        u8('prove_by_index'),\n        u8('tree_index'),\n        u8('queue_index'),\n    ],\n    'insertNullifierInput',\n);\nexport const InsertAddressInputLayout = struct(\n    [array(u8(), 32, 'address'), u8('tree_index'), u8('queue_index')],\n    'insertAddressInput',\n);\n\nexport const MerkleTreeSequenceNumberLayout = struct(\n    [\n        publicKey('tree_pubkey'),\n        publicKey('queue_pubkey'),\n        u64('tree_type'),\n        u64('seq'),\n    ],\n    'merkleTreeSequenceNumber',\n);\n\nexport function deserializeAppendNullifyCreateAddressInputsIndexer(\n    buffer: Buffer,\n) {\n    let offset = 0;\n    const meta = AppendNullifyCreateAddressInputsMetaLayout.decode(\n        buffer,\n        offset,\n    );\n    offset += AppendNullifyCreateAddressInputsMetaLayout.span;\n    const leavesCount = buffer.readUInt8(offset);\n    offset += 1;\n    const leaves = [];\n    for (let i = 0; i < leavesCount; i++) {\n        const leaf = AppendLeavesInputLayout.decode(buffer, offset);\n        leaves.push(leaf);\n        offset += AppendLeavesInputLayout.span;\n    }\n    const nullifiersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const nullifiers = [];\n    for (let i = 0; i < nullifiersCount; i++) {\n        const nullifier = InsertNullifierInputLayout.decode(buffer, offset);\n        nullifiers.push(nullifier);\n        offset += InsertNullifierInputLayout.span;\n    }\n    const addressesCount = buffer.readUInt8(offset);\n    offset += 1;\n    const addresses = [];\n    for (let i = 0; i < addressesCount; i++) {\n        const address = InsertAddressInputLayout.decode(buffer, offset);\n        addresses.push(address);\n        offset += InsertAddressInputLayout.span;\n    }\n    const outputSequenceNumbersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const output_sequence_numbers = [];\n    for (let i = 0; i < outputSequenceNumbersCount; i++) {\n        const seq = MerkleTreeSequenceNumberLayout.decode(buffer, offset);\n        output_sequence_numbers.push(seq);\n        offset += MerkleTreeSequenceNumberLayout.span;\n    }\n    const inputSequenceNumbersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const inputSequence_numbers = [];\n    for (let i = 0; i < inputSequenceNumbersCount; i++) {\n        const seq = MerkleTreeSequenceNumberLayout.decode(buffer, offset);\n        inputSequence_numbers.push(seq);\n        offset += MerkleTreeSequenceNumberLayout.span;\n    }\n    const addressSequenceNumbersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const addressSequence_numbers = [];\n    for (let i = 0; i < addressSequenceNumbersCount; i++) {\n        const seq = MerkleTreeSequenceNumberLayout.decode(buffer, offset);\n        addressSequence_numbers.push(seq);\n        offset += MerkleTreeSequenceNumberLayout.span;\n    }\n    const outputLeafIndicesCount = buffer.readUInt8(offset);\n    offset += 1;\n    const output_leaf_indices = [];\n    for (let i = 0; i < outputLeafIndicesCount; i++) {\n        const index = u32().decode(buffer, offset);\n        output_leaf_indices.push(index);\n        offset += 4;\n    }\n    return {\n        meta,\n        leaves,\n        nullifiers,\n        addresses,\n        sequence_numbers: output_sequence_numbers,\n        output_leaf_indices,\n    };\n}\n\nexport function convertToPublicTransactionEvent(\n    decoded: any,\n    remainingAccounts: PublicKey[],\n    invokeData: InstructionDataInvoke,\n): PublicTransactionEvent {\n    const convertByteArray = (arr: Uint8Array | Buffer): number[] =>\n        Array.from(arr instanceof Buffer ? new Uint8Array(arr) : arr);\n\n    const result = {\n        inputCompressedAccountHashes: decoded.nullifiers.map((n: any) =>\n            convertByteArray(n.account_hash),\n        ),\n        outputCompressedAccountHashes: decoded.leaves.map((l: any) =>\n            convertByteArray(l.leaf),\n        ),\n        outputCompressedAccounts: decoded.leaves.map(\n            (leaf: any, index: number) => ({\n                compressedAccount: {\n                    owner: new PublicKey(\n                        invokeData?.outputCompressedAccounts[index]\n                            ?.compressedAccount.owner || PublicKey.default,\n                    ),\n                    lamports: bn(\n                        invokeData?.outputCompressedAccounts[index]\n                            ?.compressedAccount.lamports || 0,\n                    ),\n                    address:\n                        invokeData?.outputCompressedAccounts[index]\n                            .compressedAccount.address,\n                    data: invokeData?.outputCompressedAccounts[index]\n                        ?.compressedAccount.data\n                        ? {\n                              discriminator: convertByteArray(\n                                  Buffer.from(\n                                      invokeData.outputCompressedAccounts[index]\n                                          .compressedAccount.data\n                                          ?.discriminator,\n                                  ),\n                              ),\n                              data:\n                                  convertByteArray(\n                                      Buffer.from(\n                                          new Uint8Array(\n                                              invokeData.outputCompressedAccounts[\n                                                  index\n                                              ].compressedAccount.data.data,\n                                          ),\n                                      ),\n                                  ) ?? [],\n                              dataHash: convertByteArray(\n                                  Buffer.from(\n                                      invokeData.outputCompressedAccounts[index]\n                                          .compressedAccount.data?.dataHash,\n                                  ),\n                              ),\n                          }\n                        : null,\n                },\n                merkleTreeIndex: leaf.index,\n            }),\n        ),\n        outputLeafIndices: decoded.output_leaf_indices,\n        sequenceNumbers: decoded.sequence_numbers.map((sn: any) => {\n            return {\n                tree_pubkey: sn.tree_pubkey,\n                queue_pubkey: sn.queue_pubkey,\n                tree_type: sn.tree_type,\n                seq: sn.seq,\n            };\n        }),\n        pubkeyArray: remainingAccounts\n            .slice(2)\n            .filter(pk => !pk.equals(PublicKey.default)),\n        isCompress: invokeData?.isCompress || false,\n        relayFee: invokeData?.relayFee ? bn(invokeData.relayFee) : null,\n        compressOrDecompressLamports: invokeData?.compressOrDecompressLamports\n            ? bn(invokeData.compressOrDecompressLamports)\n            : null,\n        message: null,\n    };\n\n    return result;\n}\n","import { AccountMeta, PublicKey } from '@solana/web3.js';\nimport {\n    AccountProofInput,\n    CompressedAccountLegacy,\n    NewAddressProofInput,\n    OutputCompressedAccountWithPackedContext,\n    PackedCompressedAccountWithMerkleContext,\n    TreeInfo,\n    TreeType,\n} from '../../state';\nimport {\n    CompressedAccountWithMerkleContextLegacy,\n    PackedAddressTreeInfo,\n    PackedStateTreeInfo,\n} from '../../state/compressed-account';\nimport { featureFlags } from '../../constants';\n\n/**\n * @internal Finds the index of a PublicKey in an array, or adds it if not\n * present\n * */\nexport function getIndexOrAdd(\n    accountsArray: PublicKey[],\n    key: PublicKey,\n): number {\n    const index = accountsArray.findIndex(existingKey =>\n        existingKey.equals(key),\n    );\n    if (index === -1) {\n        accountsArray.push(key);\n        return accountsArray.length - 1;\n    }\n    return index;\n}\n\n/**\n * @internal\n * Pads output state trees with the 0th state tree of the input state.\n *\n * @param outputStateMerkleTrees                    Optional output state trees\n *                                                  to be inserted into the\n *                                                  output state. Defaults to\n *                                                  the 0th state tree of the\n *                                                  input state. Gets padded to\n *                                                  the length of\n *                                                  outputCompressedAccounts.\n * @param numberOfOutputCompressedAccounts          The number of output\n *                                                  compressed accounts.\n *\n * @returns Padded output state trees.\n */\nexport function padOutputStateMerkleTrees(\n    outputStateMerkleTrees: PublicKey,\n    numberOfOutputCompressedAccounts: number,\n): PublicKey[] {\n    if (numberOfOutputCompressedAccounts <= 0) {\n        return [];\n    }\n\n    return new Array(numberOfOutputCompressedAccounts).fill(\n        outputStateMerkleTrees,\n    );\n}\n\nexport function toAccountMetas(remainingAccounts: PublicKey[]): AccountMeta[] {\n    return remainingAccounts.map(\n        (account): AccountMeta => ({\n            pubkey: account,\n            isWritable: true,\n            isSigner: false,\n        }),\n    );\n}\n\nexport interface PackedStateTreeInfos {\n    packedTreeInfos: PackedStateTreeInfo[];\n    outputTreeIndex: number;\n}\n\nexport interface PackedTreeInfos {\n    stateTrees?: PackedStateTreeInfos;\n    addressTrees: PackedAddressTreeInfo[];\n}\n\nconst INVALID_TREE_INDEX = -1;\n/**\n * Packs TreeInfos. Replaces PublicKey with index pointer to remaining accounts.\n *\n * Only use for MUT, CLOSE, NEW_ADDRESSES. For INIT, pass\n * {@link newAddressParamsPacked} and `outputStateTreeIndex` to your program\n * instead.\n *\n *\n * @param remainingAccounts                 Optional existing array of accounts\n *                                          to append to.\n * @param accountProofInputs                Account proof inputs.\n * @param newAddressProofInputs             New address proof inputs.\n *\n * @returns Remaining accounts, packed state and address tree infos, state tree\n * output index and address tree infos.\n */\nexport function packTreeInfos(\n    remainingAccounts: PublicKey[],\n    accountProofInputs: AccountProofInput[],\n    newAddressProofInputs: NewAddressProofInput[],\n): PackedTreeInfos {\n    const _remainingAccounts = remainingAccounts.slice();\n\n    const stateTreeInfos: PackedStateTreeInfo[] = [];\n    const addressTreeInfos: PackedAddressTreeInfo[] = [];\n    let outputTreeIndex: number = INVALID_TREE_INDEX;\n\n    // Early exit.\n    if (accountProofInputs.length === 0 && newAddressProofInputs.length === 0) {\n        return {\n            stateTrees: undefined,\n            addressTrees: addressTreeInfos,\n        };\n    }\n\n    // input\n    accountProofInputs.forEach((account, index) => {\n        const merkleTreePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.treeInfo.tree,\n        );\n\n        const queuePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.treeInfo.queue,\n        );\n\n        stateTreeInfos.push({\n            rootIndex: account.rootIndex,\n            merkleTreePubkeyIndex,\n            queuePubkeyIndex,\n            leafIndex: account.leafIndex,\n            proveByIndex: account.proveByIndex,\n        });\n    });\n\n    // output\n    if (stateTreeInfos.length > 0) {\n        // Use next tree if available, otherwise fall back to current tree.\n        // `nextTreeInfo` always takes precedence.\n        const activeTreeInfo =\n            accountProofInputs[0].treeInfo.nextTreeInfo ||\n            accountProofInputs[0].treeInfo;\n        let activeTreeOrQueue = activeTreeInfo.tree;\n\n        if (activeTreeInfo.treeType === TreeType.StateV2) {\n            if (featureFlags.isV2()) {\n                activeTreeOrQueue = activeTreeInfo.queue;\n            } else throw new Error('V2 trees are not supported yet');\n        }\n        outputTreeIndex = getIndexOrAdd(_remainingAccounts, activeTreeOrQueue);\n    }\n\n    // new addresses\n    newAddressProofInputs.forEach((account, index) => {\n        const addressMerkleTreePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.treeInfo.tree,\n        );\n        const addressQueuePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.treeInfo.queue,\n        );\n\n        addressTreeInfos.push({\n            rootIndex: account.rootIndex,\n            addressMerkleTreePubkeyIndex,\n            addressQueuePubkeyIndex,\n        });\n    });\n\n    return {\n        stateTrees:\n            stateTreeInfos.length > 0\n                ? {\n                      packedTreeInfos: stateTreeInfos,\n                      outputTreeIndex,\n                  }\n                : undefined,\n        addressTrees: addressTreeInfos,\n    };\n}\n\n/**\n * Packs Compressed Accounts.\n *\n * Replaces PublicKey with index pointer to remaining accounts.\n *\n *\n * @param inputCompressedAccounts           Ix input state to be consumed\n * @param inputStateRootIndices             The recent state root indices of the\n *                                          input state. The expiry is tied to\n *                                          the proof.\n * @param outputCompressedAccounts          Ix output state to be created\n * @param outputStateTreeInfo               The output state tree info. Gets\n *                                          padded to the length of\n *                                          outputCompressedAccounts.\n *\n * @param remainingAccounts                 Optional existing array of accounts\n *                                          to append to.\n **/\nexport function packCompressedAccounts(\n    inputCompressedAccounts: CompressedAccountWithMerkleContextLegacy[],\n    inputStateRootIndices: number[],\n    outputCompressedAccounts: CompressedAccountLegacy[],\n    outputStateTreeInfo?: TreeInfo,\n    remainingAccounts: PublicKey[] = [],\n): {\n    packedInputCompressedAccounts: PackedCompressedAccountWithMerkleContext[];\n    packedOutputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    remainingAccounts: PublicKey[];\n} {\n    const _remainingAccounts = remainingAccounts.slice();\n\n    const packedInputCompressedAccounts: PackedCompressedAccountWithMerkleContext[] =\n        [];\n\n    const packedOutputCompressedAccounts: OutputCompressedAccountWithPackedContext[] =\n        [];\n\n    /// input\n    inputCompressedAccounts.forEach((account, index) => {\n        const merkleTreePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.treeInfo.tree,\n        );\n\n        const queuePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.treeInfo.queue,\n        );\n\n        packedInputCompressedAccounts.push({\n            compressedAccount: {\n                owner: account.owner,\n                lamports: account.lamports,\n                address: account.address,\n                data: account.data,\n            },\n            merkleContext: {\n                merkleTreePubkeyIndex,\n                queuePubkeyIndex,\n                leafIndex: account.leafIndex,\n                proveByIndex: account.proveByIndex,\n            },\n            rootIndex: inputStateRootIndices[index],\n            readOnly: false,\n        });\n    });\n    if (inputCompressedAccounts.length > 0 && outputStateTreeInfo) {\n        throw new Error(\n            'Cannot specify both input accounts and outputStateTreeInfo',\n        );\n    }\n\n    let treeInfo: TreeInfo;\n    if (inputCompressedAccounts.length > 0) {\n        treeInfo = inputCompressedAccounts[0].treeInfo;\n    } else if (outputStateTreeInfo) {\n        treeInfo = outputStateTreeInfo;\n    } else {\n        throw new Error(\n            'Neither input accounts nor outputStateTreeInfo are available',\n        );\n    }\n\n    // Use next tree if available, otherwise fall back to current tree.\n    // `nextTreeInfo` always takes precedence.\n    const activeTreeInfo = treeInfo.nextTreeInfo || treeInfo;\n    let activeTreeOrQueue = activeTreeInfo.tree;\n\n    if (activeTreeInfo.treeType === TreeType.StateV2) {\n        if (featureFlags.isV2()) {\n            activeTreeOrQueue = activeTreeInfo.queue;\n        } else throw new Error('V2 trees are not supported yet');\n    }\n    /// output\n    const paddedOutputStateMerkleTrees = padOutputStateMerkleTrees(\n        activeTreeOrQueue,\n        outputCompressedAccounts.length,\n    );\n\n    outputCompressedAccounts.forEach((account, index) => {\n        const merkleTreePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            paddedOutputStateMerkleTrees[index],\n        );\n        packedOutputCompressedAccounts.push({\n            compressedAccount: {\n                owner: account.owner,\n                lamports: account.lamports,\n                address: account.address,\n                data: account.data,\n            },\n            merkleTreeIndex: merkleTreePubkeyIndex,\n        });\n    });\n\n    return {\n        packedInputCompressedAccounts,\n        packedOutputCompressedAccounts,\n        remainingAccounts: _remainingAccounts,\n    };\n}\n","import BN from 'bn.js';\nimport {\n    CompressedAccountLegacy,\n    CompressedAccountWithMerkleContext,\n    bn,\n} from '../state';\n\nexport const validateSufficientBalance = (balance: BN) => {\n    if (balance.lt(bn(0))) {\n        throw new Error('Insufficient balance for transfer');\n    }\n};\n\nexport const validateSameOwner = (\n    compressedAccounts:\n        | CompressedAccountLegacy[]\n        | CompressedAccountWithMerkleContext[],\n) => {\n    if (compressedAccounts.length === 0) {\n        throw new Error('No accounts provided for validation');\n    }\n    const zerothOwner = compressedAccounts[0].owner;\n    if (\n        !compressedAccounts.every(account => account.owner.equals(zerothOwner))\n    ) {\n        throw new Error('All input accounts must have the same owner');\n    }\n};\n\n/// for V1 circuits.\nexport const validateNumbersForProof = (\n    hashesLength: number,\n    newAddressesLength: number,\n) => {\n    if (hashesLength > 0 && newAddressesLength > 0) {\n        if (hashesLength === 8) {\n            throw new Error(\n                `Invalid number of compressed accounts for proof: ${hashesLength}. Allowed numbers: ${[1, 2, 3, 4].join(', ')}`,\n            );\n        }\n        validateNumbers(hashesLength, [1, 2, 3, 4], 'compressed accounts');\n        validateNumbersForNonInclusionProof(newAddressesLength);\n    } else {\n        if (hashesLength > 0) {\n            validateNumbersForInclusionProof(hashesLength);\n        } else {\n            validateNumbersForNonInclusionProof(newAddressesLength);\n        }\n    }\n};\n\n/// Ensure that the amount if compressed accounts is allowed.\nexport const validateNumbersForInclusionProof = (hashesLength: number) => {\n    validateNumbers(hashesLength, [1, 2, 3, 4, 8], 'compressed accounts');\n};\n\n/// Ensure that the amount if new addresses is allowed.\nexport const validateNumbersForNonInclusionProof = (\n    newAddressesLength: number,\n) => {\n    validateNumbers(newAddressesLength, [1, 2], 'new addresses');\n};\n\n/// V1 circuit safeguards.\nexport const validateNumbers = (\n    length: number,\n    allowedNumbers: number[],\n    type: string,\n) => {\n    if (!allowedNumbers.includes(length)) {\n        throw new Error(\n            `Invalid number of ${type}: ${length}. Allowed numbers: ${allowedNumbers.join(', ')}`,\n        );\n    }\n};\n","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","const isObject = value => typeof value === 'object' && value !== null;\n\n// Customized for this use-case\nconst isObjectCustom = value =>\n\tisObject(value)\n\t&& !(value instanceof RegExp)\n\t&& !(value instanceof Error)\n\t&& !(value instanceof Date);\n\nexport const mapObjectSkip = Symbol('mapObjectSkip');\n\nconst _mapObject = (object, mapper, options, isSeen = new WeakMap()) => {\n\toptions = {\n\t\tdeep: false,\n\t\ttarget: {},\n\t\t...options,\n\t};\n\n\tif (isSeen.has(object)) {\n\t\treturn isSeen.get(object);\n\t}\n\n\tisSeen.set(object, options.target);\n\n\tconst {target} = options;\n\tdelete options.target;\n\n\tconst mapArray = array => array.map(element => isObjectCustom(element) ? _mapObject(element, mapper, options, isSeen) : element);\n\tif (Array.isArray(object)) {\n\t\treturn mapArray(object);\n\t}\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tconst mapResult = mapper(key, value, object);\n\n\t\tif (mapResult === mapObjectSkip) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [newKey, newValue, {shouldRecurse = true} = {}] = mapResult;\n\n\t\t// Drop `__proto__` keys.\n\t\tif (newKey === '__proto__') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (options.deep && shouldRecurse && isObjectCustom(newValue)) {\n\t\t\tnewValue = Array.isArray(newValue)\n\t\t\t\t? mapArray(newValue)\n\t\t\t\t: _mapObject(newValue, mapper, options, isSeen);\n\t\t}\n\n\t\ttarget[newKey] = newValue;\n\t}\n\n\treturn target;\n};\n\nexport default function mapObject(object, mapper, options) {\n\tif (!isObject(object)) {\n\t\tthrow new TypeError(`Expected an object, got \\`${object}\\` (${typeof object})`);\n\t}\n\n\treturn _mapObject(object, mapper, options);\n}\n","const UPPERCASE = /[\\p{Lu}]/u;\nconst LOWERCASE = /[\\p{Ll}]/u;\nconst LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/gu;\nconst IDENTIFIER = /([\\p{Alpha}\\p{N}_]|$)/u;\nconst SEPARATORS = /[_.\\- ]+/;\n\nconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\nconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');\nconst NUMBERS_AND_IDENTIFIER = new RegExp('\\\\d+' + IDENTIFIER.source, 'gu');\n\nconst preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\tlet isLastLastCharPreserved = false;\n\n\tfor (let index = 0; index < string.length; index++) {\n\t\tconst character = string[index];\n\t\tisLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;\n\n\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\tstring = string.slice(0, index) + '-' + string.slice(index);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\tindex++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {\n\t\t\tstring = string.slice(0, index - 1) + '-' + string.slice(index - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst preserveConsecutiveUppercase = (input, toLowerCase) => {\n\tLEADING_CAPITAL.lastIndex = 0;\n\n\treturn input.replaceAll(LEADING_CAPITAL, match => toLowerCase(match));\n};\n\nconst postProcess = (input, toUpperCase) => {\n\tSEPARATORS_AND_IDENTIFIER.lastIndex = 0;\n\tNUMBERS_AND_IDENTIFIER.lastIndex = 0;\n\n\treturn input\n\t\t.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ['_', '-'].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match))\n\t\t.replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));\n};\n\nexport default function camelCase(input, options) {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = {\n\t\tpascalCase: false,\n\t\tpreserveConsecutiveUppercase: false,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tconst toLowerCase = options.locale === false\n\t\t? string => string.toLowerCase()\n\t\t: string => string.toLocaleLowerCase(options.locale);\n\n\tconst toUpperCase = options.locale === false\n\t\t? string => string.toUpperCase()\n\t\t: string => string.toLocaleUpperCase(options.locale);\n\n\tif (input.length === 1) {\n\t\tif (SEPARATORS.test(input)) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn options.pascalCase ? toUpperCase(input) : toLowerCase(input);\n\t}\n\n\tconst hasUpperCase = input !== toLowerCase(input);\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);\n\t}\n\n\tinput = input.replace(LEADING_SEPARATORS, '');\n\tinput = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);\n\n\tif (options.pascalCase) {\n\t\tinput = toUpperCase(input.charAt(0)) + input.slice(1);\n\t}\n\n\treturn postProcess(input, toUpperCase);\n}\n","export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n","import mapObject from 'map-obj';\nimport camelCase from 'camelcase';\nimport QuickLru from 'quick-lru';\n\nconst has = (array, key) => array.some(element => {\n\tif (typeof element === 'string') {\n\t\treturn element === key;\n\t}\n\n\telement.lastIndex = 0;\n\n\treturn element.test(key);\n});\n\nconst cache = new QuickLru({maxSize: 100_000});\n\n// Reproduces behavior from `map-obj`.\nconst isObject = value =>\n\ttypeof value === 'object'\n\t\t&& value !== null\n\t\t&& !(value instanceof RegExp)\n\t\t&& !(value instanceof Error)\n\t\t&& !(value instanceof Date);\n\nconst transform = (input, options = {}) => {\n\tif (!isObject(input)) {\n\t\treturn input;\n\t}\n\n\tconst {\n\t\texclude,\n\t\tpascalCase = false,\n\t\tstopPaths,\n\t\tdeep = false,\n\t\tpreserveConsecutiveUppercase = false,\n\t} = options;\n\n\tconst stopPathsSet = new Set(stopPaths);\n\n\tconst makeMapper = parentPath => (key, value) => {\n\t\tif (deep && isObject(value)) {\n\t\t\tconst path = parentPath === undefined ? key : `${parentPath}.${key}`;\n\n\t\t\tif (!stopPathsSet.has(path)) {\n\t\t\t\tvalue = mapObject(value, makeMapper(path));\n\t\t\t}\n\t\t}\n\n\t\tif (!(exclude && has(exclude, key))) {\n\t\t\tconst cacheKey = pascalCase ? `${key}_` : key;\n\n\t\t\tif (cache.has(cacheKey)) {\n\t\t\t\tkey = cache.get(cacheKey);\n\t\t\t} else {\n\t\t\t\tconst returnValue = camelCase(key, {pascalCase, locale: false, preserveConsecutiveUppercase});\n\n\t\t\t\tif (key.length < 100) { // Prevent abuse\n\t\t\t\t\tcache.set(cacheKey, returnValue);\n\t\t\t\t}\n\n\t\t\t\tkey = returnValue;\n\t\t\t}\n\t\t}\n\n\t\treturn [key, value];\n\t};\n\n\treturn mapObject(input, makeMapper(undefined));\n};\n\nexport default function camelcaseKeys(input, options) {\n\tif (Array.isArray(input)) {\n\t\treturn Object.keys(input).map(key => transform(input[key], options));\n\t}\n\n\treturn transform(input, options);\n}\n","import { Buffer } from 'buffer';\nimport { bn, createBN254 } from '../state';\nimport { FIELD_SIZE } from '../constants';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport camelcaseKeys from 'camelcase-keys';\nimport {\n    InstructionDataInvoke,\n    PackedCompressedAccountWithMerkleContext,\n    CompressedAccountLegacy,\n    OutputCompressedAccountWithPackedContext,\n    PackedMerkleContextLegacy,\n} from '../state';\nimport { NewAddressParamsPacked } from './address';\n\nexport function byteArrayToKeypair(byteArray: number[]): Keypair {\n    return Keypair.fromSecretKey(Uint8Array.from(byteArray));\n}\n/**\n * @internal\n * convert BN to hex with '0x' prefix\n */\nexport function toHex(bn: BN): string {\n    return '0x' + bn.toString('hex');\n}\n\nexport const toArray = <T>(value: T | T[]) =>\n    Array.isArray(value) ? value : [value];\n\nexport const bufToDecStr = (buf: Buffer): string => {\n    return createBN254(buf).toString();\n};\nexport function isSmallerThanBn254FieldSizeBe(bytes: Buffer): boolean {\n    const bigint = bn(bytes, undefined, 'be');\n    return bigint.lt(FIELD_SIZE);\n}\n\nexport const toCamelCase = (object: any) =>\n    camelcaseKeys(object, { deep: true });\n\n/**\n/**\n * Hash the provided `bytes` with Keccak256 and ensure the result fits in the\n * BN254 prime field by repeatedly hashing the inputs with various \"bump seeds\"\n * and truncating the resulting hash to 31 bytes.\n *\n * @deprecated Use `hashvToBn254FieldSizeBe` instead.\n */\nexport function hashToBn254FieldSizeBe(bytes: Buffer): [Buffer, number] | null {\n    // TODO(vadorovsky, affects-onchain): Get rid of the bump mechanism, it\n    // makes no sense. Doing the same as in the `hashvToBn254FieldSizeBe` below\n    // - overwriting the most significant byte with zero - is sufficient for\n    // truncation, it's also faster, doesn't force us to return `Option` and\n    // care about handling an error which is practically never returned.\n    //\n    // The reason we can't do it now is that it would affect on-chain programs.\n    // Once we can update programs, we can get rid of the seed bump (or even of\n    // this function all together in favor of the `hashv` variant).\n    let bumpSeed = 255;\n    while (bumpSeed >= 0) {\n        const inputWithBumpSeed = Buffer.concat([\n            bytes,\n            Buffer.from([bumpSeed]),\n        ]);\n        const hash = keccak_256(inputWithBumpSeed);\n        if (hash.length !== 32) {\n            throw new Error('Invalid hash length');\n        }\n        hash[0] = 0;\n\n        if (isSmallerThanBn254FieldSizeBe(Buffer.from(hash))) {\n            return [Buffer.from(hash), bumpSeed];\n        }\n\n        bumpSeed -= 1;\n    }\n    return null;\n}\n\n/**\n * Hash the provided `bytes` with Keccak256 and ensure that the result fits in\n * the BN254 prime field by truncating the resulting hash to 31 bytes.\n *\n * @param bytes Input bytes\n *\n * @returns     Hash digest\n */\nexport function hashvToBn254FieldSizeBe(bytes: Uint8Array[]): Uint8Array {\n    const hasher = keccak_256.create();\n    for (const input of bytes) {\n        hasher.update(input);\n    }\n    const hash = hasher.digest();\n    hash[0] = 0;\n    return hash;\n}\n\n/** Mutates array in place */\nexport function pushUniqueItems<T>(items: T[], map: T[]): void {\n    items.forEach(item => {\n        if (!map.includes(item)) {\n            map.push(item);\n        }\n    });\n}\n\nexport function convertInvokeCpiWithReadOnlyToInvoke(\n    data: any,\n): InstructionDataInvoke {\n    const proof = data.proof\n        ? {\n              a: data.proof.a,\n              b: data.proof.b,\n              c: data.proof.c,\n          }\n        : null;\n\n    // Convert new address params to NewAddressParamsPacked format\n    const newAddressParams: NewAddressParamsPacked[] =\n        data.new_address_params.map((params: any) => ({\n            seed: params.seed,\n            addressMerkleTreeRootIndex: params.address_merkle_tree_root_index,\n            addressMerkleTreeAccountIndex:\n                params.address_merkle_tree_account_index,\n            addressQueueAccountIndex: params.address_queue_account_index,\n        }));\n\n    // Convert input_compressed_accounts to PackedCompressedAccountWithMerkleContext format\n    const inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[] =\n        data.input_compressed_accounts.map((account: any) => {\n            const compressedAccount: CompressedAccountLegacy = {\n                owner: new PublicKey(Buffer.alloc(32)),\n                lamports: bn(account.lamports),\n                address: account.address,\n                data: null,\n            };\n\n            const merkleContext: PackedMerkleContextLegacy = {\n                merkleTreePubkeyIndex:\n                    account.packedMerkleContext.merkle_tree_pubkey_index,\n                queuePubkeyIndex:\n                    account.packedMerkleContext.queue_pubkey_index,\n                leafIndex: account.packedMerkleContext.leaf_index,\n                proveByIndex: account.packedMerkleContext.prove_by_index,\n            };\n\n            return {\n                compressedAccount,\n                merkleContext,\n                rootIndex: account.root_index,\n                // TODO: confirm this is valid.\n                readOnly: false,\n            };\n        });\n\n    // Convert output_compressed_accounts to OutputCompressedAccountWithPackedContext format\n    const outputCompressedAccounts: OutputCompressedAccountWithPackedContext[] =\n        data.output_compressed_accounts.map((account: any) => ({\n            compressedAccount: {\n                owner: account.compressedAccount.owner,\n                lamports: account.compressedAccount.lamports,\n                address: account.compressedAccount.address,\n                data: account.compressedAccount.data,\n            },\n            merkleTreeIndex: account.merkleTreeIndex,\n        }));\n\n    return {\n        proof,\n        inputCompressedAccountsWithMerkleContext,\n        outputCompressedAccounts,\n        relayFee: null,\n        newAddressParams,\n        compressOrDecompressLamports: data.compress_or_decompress_lamports,\n        isCompress: data.is_compress,\n    };\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { hashToBn254FieldSizeBe, hashvToBn254FieldSizeBe } from './conversion';\nimport { defaultTestStateTreeAccounts } from '../constants';\nimport { getIndexOrAdd } from '../programs/system/pack';\n\nexport function deriveAddressSeed(\n    seeds: Uint8Array[],\n    programId: PublicKey,\n): Uint8Array {\n    const combinedSeeds: Uint8Array[] = [programId.toBytes(), ...seeds];\n    const hash = hashvToBn254FieldSizeBe(combinedSeeds);\n    return hash;\n}\n\n/**\n * Derive an address for a compressed account from a seed and an address Merkle\n * tree public key.\n *\n * @param seed                     Seed to derive the address from\n * @param addressMerkleTreePubkey  Merkle tree public key. Defaults to\n *                                 defaultTestStateTreeAccounts().addressTree\n * @returns                        Derived address\n */\nexport function deriveAddress(\n    seed: Uint8Array,\n    addressMerkleTreePubkey: PublicKey = defaultTestStateTreeAccounts()\n        .addressTree,\n): PublicKey {\n    if (seed.length != 32) {\n        throw new Error('Seed length is not 32 bytes.');\n    }\n    const bytes = addressMerkleTreePubkey.toBytes();\n    const combined = Buffer.from([...bytes, ...seed]);\n    const hash = hashToBn254FieldSizeBe(combined);\n\n    if (hash === null) {\n        throw new Error('DeriveAddressError');\n    }\n    const buf = hash[0];\n    return new PublicKey(buf);\n}\n\nexport interface NewAddressParams {\n    /**\n     * Seed for the compressed account. Must be seed used to derive\n     * newAccountAddress\n     */\n    seed: Uint8Array;\n    /**\n     * Recent state root index of the address tree. The expiry is tied to the\n     * validity proof.\n     */\n    addressMerkleTreeRootIndex: number;\n    /**\n     * Address tree pubkey. Must be base pubkey used to derive new address\n     */\n    addressMerkleTreePubkey: PublicKey;\n    /**\n     * Address space queue pubkey. Associated with the state tree.\n     */\n    addressQueuePubkey: PublicKey;\n}\n\nexport interface NewAddressParamsPacked {\n    /**\n     * Seed for the compressed account. Must be seed used to derive\n     * newAccountAddress\n     */\n    seed: number[];\n    /**\n     * Recent state root index of the address tree. The expiry is tied to the\n     * validity proof.\n     */\n    addressMerkleTreeRootIndex: number;\n    /**\n     * Index of the address merkle tree account in the remaining accounts array\n     */\n    addressMerkleTreeAccountIndex: number;\n    /**\n     * Index of the address queue account in the remaining accounts array\n     */\n    addressQueueAccountIndex: number;\n}\n\n/**\n * Packs new address params for instruction data in TypeScript clients\n *\n * @param newAddressParams      New address params\n * @param remainingAccounts     Remaining accounts\n * @returns                     Packed new address params\n */\nexport function packNewAddressParams(\n    newAddressParams: NewAddressParams[],\n    remainingAccounts: PublicKey[],\n): {\n    newAddressParamsPacked: NewAddressParamsPacked[];\n    remainingAccounts: PublicKey[];\n} {\n    const _remainingAccounts = remainingAccounts.slice();\n\n    const newAddressParamsPacked: NewAddressParamsPacked[] =\n        newAddressParams.map(x => ({\n            seed: Array.from(x.seed),\n            addressMerkleTreeRootIndex: x.addressMerkleTreeRootIndex,\n            addressMerkleTreeAccountIndex: 0, // will be assigned later\n            addressQueueAccountIndex: 0, // will be assigned later\n        }));\n\n    newAddressParams.forEach((params, i) => {\n        newAddressParamsPacked[i].addressMerkleTreeAccountIndex = getIndexOrAdd(\n            _remainingAccounts,\n            params.addressMerkleTreePubkey,\n        );\n    });\n\n    newAddressParams.forEach((params, i) => {\n        newAddressParamsPacked[i].addressQueueAccountIndex = getIndexOrAdd(\n            _remainingAccounts,\n            params.addressQueuePubkey,\n        );\n    });\n\n    return { newAddressParamsPacked, remainingAccounts: _remainingAccounts };\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { it, expect, describe } = import.meta.vitest;\n\n    const programId = new PublicKey(\n        '7yucc7fL3JGbyMwg4neUaenNSdySS39hbAk89Ao3t1Hz',\n    );\n\n    describe('derive address seed', () => {\n        it('should derive a valid address seed', () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('foo'),\n                new TextEncoder().encode('bar'),\n            ];\n            expect(deriveAddressSeed(seeds, programId)).toStrictEqual(\n                new Uint8Array([\n                    0, 246, 150, 3, 192, 95, 53, 123, 56, 139, 206, 179, 253,\n                    133, 115, 103, 120, 155, 251, 72, 250, 47, 117, 217, 118,\n                    59, 174, 207, 49, 101, 201, 110,\n                ]),\n            );\n        });\n\n        it('should derive a valid address seed', () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('ayy'),\n                new TextEncoder().encode('lmao'),\n            ];\n            expect(deriveAddressSeed(seeds, programId)).toStrictEqual(\n                new Uint8Array([\n                    0, 202, 44, 25, 221, 74, 144, 92, 69, 168, 38, 19, 206, 208,\n                    29, 162, 53, 27, 120, 214, 152, 116, 15, 107, 212, 168, 33,\n                    121, 187, 10, 76, 233,\n                ]),\n            );\n        });\n    });\n\n    describe('deriveAddress function', () => {\n        it('should derive a valid address from a seed and a merkle tree public key', async () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('foo'),\n                new TextEncoder().encode('bar'),\n            ];\n            const seed = deriveAddressSeed(seeds, programId);\n            const merkleTreePubkey = new PublicKey(\n                '11111111111111111111111111111111',\n            );\n            const derivedAddress = deriveAddress(seed, merkleTreePubkey);\n            expect(derivedAddress).toBeInstanceOf(PublicKey);\n            expect(derivedAddress).toStrictEqual(\n                new PublicKey('139uhyyBtEh4e1CBDJ68ooK5nCeWoncZf9HPyAfRrukA'),\n            );\n        });\n\n        it('should derive a valid address from a seed and a merkle tree public key', async () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('ayy'),\n                new TextEncoder().encode('lmao'),\n            ];\n            const seed = deriveAddressSeed(seeds, programId);\n            const merkleTreePubkey = new PublicKey(\n                '11111111111111111111111111111111',\n            );\n            const derivedAddress = deriveAddress(seed, merkleTreePubkey);\n            expect(derivedAddress).toBeInstanceOf(PublicKey);\n            expect(derivedAddress).toStrictEqual(\n                new PublicKey('12bhHm6PQjbNmEn3Yu1Gq9k7XwVn2rZpzYokmLwbFazN'),\n            );\n        });\n    });\n\n    describe('packNewAddressParams function', () => {\n        it('should pack new address params correctly', () => {\n            const newAddressParams = [\n                {\n                    seed: new Uint8Array([1, 2, 3, 4]),\n                    addressMerkleTreeRootIndex: 0,\n                    addressMerkleTreePubkey: new PublicKey(\n                        '11111111111111111111111111111111',\n                    ),\n                    addressQueuePubkey: new PublicKey(\n                        '11111111111111111111111111111112',\n                    ),\n                },\n            ];\n            const remainingAccounts = [\n                new PublicKey('11111111111111111111111111111112'),\n                new PublicKey('11111111111111111111111111111111'),\n            ];\n            const packedParams = packNewAddressParams(\n                newAddressParams,\n                remainingAccounts,\n            );\n            expect(\n                packedParams.newAddressParamsPacked[0]\n                    .addressMerkleTreeAccountIndex,\n            ).toBe(1);\n            expect(\n                packedParams.newAddressParamsPacked[0].addressQueueAccountIndex,\n            ).toBe(0);\n        });\n    });\n}\n","import {\n    Commitment,\n    Connection,\n    PublicKey,\n    TransactionConfirmationStrategy,\n} from '@solana/web3.js';\n\nexport async function airdropSol({\n    connection,\n    lamports,\n    recipientPublicKey,\n}: {\n    connection: Connection;\n    lamports: number;\n    recipientPublicKey: PublicKey;\n}) {\n    const txHash = await connection.requestAirdrop(\n        recipientPublicKey,\n        lamports,\n    );\n    await confirmTransaction(connection, txHash);\n    return txHash;\n}\n\nexport async function confirmTransaction(\n    connection: Connection,\n    signature: string,\n    confirmation: Commitment = 'confirmed',\n) {\n    const latestBlockHash = await connection.getLatestBlockhash(confirmation);\n    const strategy: TransactionConfirmationStrategy = {\n        signature: signature.toString(),\n        lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n        blockhash: latestBlockHash.blockhash,\n    };\n    return await connection.confirmTransaction(strategy, confirmation);\n}\n","import { Signer } from '@solana/web3.js';\n\n/** @internal remove signer from signers if part of signers */\nexport function dedupeSigner(signer: Signer, signers: Signer[]): Signer[] {\n    if (signers.includes(signer)) {\n        return signers.filter(\n            s => s.publicKey.toString() !== signer.publicKey.toString(),\n        );\n    }\n    return signers;\n}\n","import BN from 'bn.js';\nimport { FIELD_SIZE } from '../constants';\nimport { bn, ValidityProof } from '../state';\n\ninterface GnarkProofJson {\n    ar: string[];\n    bs: string[][];\n    krs: string[];\n}\n\ntype ProofABC = {\n    a: Uint8Array;\n    b: Uint8Array;\n    c: Uint8Array;\n};\n\nexport const placeholderValidityProof = () => ({\n    a: Array.from({ length: 32 }, (_, i) => i + 1),\n    b: Array.from({ length: 64 }, (_, i) => i + 1),\n    c: Array.from({ length: 32 }, (_, i) => i + 1),\n});\n\nexport const checkValidityProofShape = (proof: ValidityProof) => {\n    if (\n        proof.a.length !== 32 ||\n        proof.b.length !== 64 ||\n        proof.c.length !== 32\n    ) {\n        throw new Error('ValidityProof has invalid shape');\n    }\n};\n\nexport function proofFromJsonStruct(json: GnarkProofJson): ProofABC {\n    const proofAX = deserializeHexStringToBeBytes(json.ar[0]);\n    const proofAY = deserializeHexStringToBeBytes(json.ar[1]);\n    const proofA: Uint8Array = new Uint8Array([...proofAX, ...proofAY]);\n\n    const proofBX0 = deserializeHexStringToBeBytes(json.bs[0][0]);\n    const proofBX1 = deserializeHexStringToBeBytes(json.bs[0][1]);\n    const proofBY0 = deserializeHexStringToBeBytes(json.bs[1][0]);\n    const proofBY1 = deserializeHexStringToBeBytes(json.bs[1][1]);\n    const proofB: Uint8Array = new Uint8Array([\n        ...proofBX0,\n        ...proofBX1,\n        ...proofBY0,\n        ...proofBY1,\n    ]);\n\n    const proofCX = deserializeHexStringToBeBytes(json.krs[0]);\n    const proofCY = deserializeHexStringToBeBytes(json.krs[1]);\n    const proofC: Uint8Array = new Uint8Array([...proofCX, ...proofCY]);\n\n    const proofABC: ProofABC = { a: proofA, b: proofB, c: proofC };\n    return proofABC;\n}\n\n// TODO: add unit test for negation\n// TODO: test if LE BE issue. unit test\nexport function negateAndCompressProof(proof: ProofABC): ValidityProof {\n    const proofA = proof.a;\n    const proofB = proof.b;\n    const proofC = proof.c;\n\n    const aXElement = proofA.slice(0, 32);\n    const aYElement = bn(proofA.slice(32, 64), 32, 'be');\n\n    /// Negate\n    const proofAIsPositive = yElementIsPositiveG1(aYElement) ? false : true;\n    /// First byte of proofA is the bitmask\n    aXElement[0] = addBitmaskToByte(aXElement[0], proofAIsPositive);\n\n    const bXElement = proofB.slice(0, 64);\n    const bYElement = proofB.slice(64, 128);\n\n    const proofBIsPositive = yElementIsPositiveG2(\n        bn(bYElement.slice(0, 32), 32, 'be'),\n        bn(bYElement.slice(32, 64), 32, 'be'),\n    );\n\n    bXElement[0] = addBitmaskToByte(bXElement[0], proofBIsPositive);\n\n    const cXElement = proofC.slice(0, 32);\n    const cYElement = proofC.slice(32, 64);\n    const proofCIsPositive = yElementIsPositiveG1(bn(cYElement, 32, 'be'));\n    cXElement[0] = addBitmaskToByte(cXElement[0], proofCIsPositive);\n\n    const compressedProof: ValidityProof = {\n        a: Array.from(aXElement),\n        b: Array.from(bXElement),\n        c: Array.from(cXElement),\n    };\n\n    return compressedProof;\n}\n\nfunction deserializeHexStringToBeBytes(hexStr: string): Uint8Array {\n    // Using BN for simpler conversion from hex string to byte array\n    const bN = bn(\n        hexStr.startsWith('0x') ? hexStr.substring(2) : hexStr,\n        'hex',\n    );\n    return new Uint8Array(bN.toArray('be', 32));\n}\n\nfunction yElementIsPositiveG1(yElement: BN): boolean {\n    return yElement.lte(FIELD_SIZE.sub(yElement));\n}\n\nfunction yElementIsPositiveG2(yElement1: BN, yElement2: BN): boolean {\n    const fieldMidpoint = FIELD_SIZE.div(bn(2));\n\n    // Compare the first component of the y coordinate\n    if (yElement1.lt(fieldMidpoint)) {\n        return true;\n    } else if (yElement1.gt(fieldMidpoint)) {\n        return false;\n    }\n\n    // If the first component is equal to the midpoint, compare the second component\n    return yElement2.lt(fieldMidpoint);\n}\n// bitmask compatible with solana altbn128 compression syscall and arkworks' implementation\n// https://github.com/arkworks-rs/algebra/blob/master/ff/src/fields/models/fp/mod.rs#L580\n// https://github.com/arkworks-rs/algebra/blob/master/serialize/src/flags.rs#L18\n// fn u8_bitmask(value: u8, inf: bool, neg: bool) -> u8 {\n//     let mut mask = 0;\n//     match self {\n//         inf => mask |= 1 << 6,\n//         neg => mask |= 1 << 7,\n//         _ => (),\n//     }\n//     mask\n// }\nfunction addBitmaskToByte(byte: number, yIsPositive: boolean): number {\n    if (!yIsPositive) {\n        return (byte |= 1 << 7);\n    } else {\n        return byte;\n    }\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { it, expect, describe } = import.meta.vitest;\n\n    // Unit test for addBitmaskToByte function\n    describe('addBitmaskToByte', () => {\n        it('should add a bitmask to the byte if yIsPositive is false', () => {\n            const byte = 0b00000000;\n            const yIsPositive = false;\n            const result = addBitmaskToByte(byte, yIsPositive);\n            expect(result).toBe(0b10000000); // 128 in binary, which is 1 << 7\n        });\n\n        it('should not modify the byte if yIsPositive is true', () => {\n            const byte = 0b00000000;\n            const yIsPositive = true;\n            const result = addBitmaskToByte(byte, yIsPositive);\n            expect(result).toBe(0b00000000);\n        });\n    });\n\n    describe('test prover server', () => {\n        const TEST_JSON = {\n            ar: [\n                '0x22bdaa3187d8fe294925a66fa0165a11bc9e07678fa2fc72402ebfd33d521c69',\n                '0x2d18ff780b69898b4cdd8d7b6ac72d077799399f0f45e52665426456f3903584',\n            ],\n            bs: [\n                [\n                    '0x138cc0962e49f76a701d2871d2799892c9782940095eb0429e979f336d2e162d',\n                    '0x2fe1bfbb15cbfb83d7e00ace23e45f890604003783eaf34affa35e0d6f4822bc',\n                ],\n                [\n                    '0x1a89264f82cc6e8ef1c696bea0b5803c28c0ba6ab61366bcb71e73a4135cae8d',\n                    '0xf778d857b3df01a4100265c9d014ce02d47425f0114685356165fa5ee3f3a26',\n                ],\n            ],\n            krs: [\n                '0x176b6ae9001f66832951e2d43a98a972667447bb1781f534b70cb010270dcdd3',\n                '0xb748d5fac1686db28d94c02250af7eb4f28dfdabc8983305c45bcbc6e163eeb',\n            ],\n        };\n        const COMPRESSED_PROOF_A = [\n            34, 189, 170, 49, 135, 216, 254, 41, 73, 37, 166, 111, 160, 22, 90,\n            17, 188, 158, 7, 103, 143, 162, 252, 114, 64, 46, 191, 211, 61, 82,\n            28, 105,\n        ];\n        const COMPRESSED_PROOF_B = [\n            147, 140, 192, 150, 46, 73, 247, 106, 112, 29, 40, 113, 210, 121,\n            152, 146, 201, 120, 41, 64, 9, 94, 176, 66, 158, 151, 159, 51, 109,\n            46, 22, 45, 47, 225, 191, 187, 21, 203, 251, 131, 215, 224, 10, 206,\n            35, 228, 95, 137, 6, 4, 0, 55, 131, 234, 243, 74, 255, 163, 94, 13,\n            111, 72, 34, 188,\n        ];\n        const COMPRESSED_PROOF_C = [\n            23, 107, 106, 233, 0, 31, 102, 131, 41, 81, 226, 212, 58, 152, 169,\n            114, 102, 116, 71, 187, 23, 129, 245, 52, 183, 12, 176, 16, 39, 13,\n            205, 211,\n        ];\n\n        it('should execute a compressed token mint', async () => {\n            const proof = proofFromJsonStruct(TEST_JSON);\n            const compressedProof = negateAndCompressProof(proof);\n            expect(compressedProof.a).toEqual(COMPRESSED_PROOF_A);\n            expect(compressedProof.b).toEqual(COMPRESSED_PROOF_B);\n            expect(compressedProof.c).toEqual(COMPRESSED_PROOF_C);\n        });\n    });\n    describe('Validity Proof Functions', () => {\n        describe('placeholderValidityProof', () => {\n            it('should create a validity proof with correct shape', () => {\n                const validityProof = placeholderValidityProof();\n                expect(validityProof.a.length).toBe(32);\n                expect(validityProof.b.length).toBe(64);\n                expect(validityProof.c.length).toBe(32);\n            });\n        });\n\n        describe('checkValidityProofShape', () => {\n            it('should not throw an error for valid proof shape', () => {\n                const validProof = {\n                    a: Array.from(new Uint8Array(32)),\n                    b: Array.from(new Uint8Array(64)),\n                    c: Array.from(new Uint8Array(32)),\n                };\n                expect(() => checkValidityProofShape(validProof)).not.toThrow();\n            });\n\n            it('should throw an error for an invalid proof', () => {\n                const invalidProof = {\n                    a: Array.from(new Uint8Array(31)), // incorrect length\n                    b: Array.from(new Uint8Array(64)),\n                    c: Array.from(new Uint8Array(32)),\n                };\n                expect(() => checkValidityProofShape(invalidProof)).toThrow(\n                    'ValidityProof has invalid shape',\n                );\n            });\n        });\n    });\n}\n","import {\n    VersionedTransaction,\n    SignatureResult,\n    RpcResponseAndContext,\n    Signer,\n    TransactionInstruction,\n    TransactionMessage,\n    ConfirmOptions,\n    TransactionSignature,\n    PublicKey,\n    AddressLookupTableAccount,\n} from '@solana/web3.js';\nimport { Rpc } from '../rpc';\nimport { isLocalTest } from '../constants';\n\n/**\n * Builds a versioned Transaction from instructions.\n *\n * @param instructions          instructions to include\n * @param payerPublicKey        fee payer public key\n * @param blockhash             blockhash to use\n * @param lookupTableAccounts   lookup table accounts to include\n *\n * @return VersionedTransaction\n */\nexport function buildTx(\n    instructions: TransactionInstruction[],\n    payerPublicKey: PublicKey,\n    blockhash: string,\n    lookupTableAccounts?: AddressLookupTableAccount[],\n): VersionedTransaction {\n    const messageV0 = new TransactionMessage({\n        payerKey: payerPublicKey,\n        recentBlockhash: blockhash,\n        instructions,\n    }).compileToV0Message(lookupTableAccounts);\n\n    return new VersionedTransaction(messageV0);\n}\n\n/**\n * Sends a versioned transaction and confirms it.\n *\n * @param rpc               connection to use\n * @param tx                versioned transaction to send\n * @param confirmOptions    confirmation options\n * @param blockHashCtx      blockhash context for confirmation\n *\n * @return TransactionSignature\n */\nexport async function sendAndConfirmTx(\n    rpc: Rpc,\n    tx: VersionedTransaction,\n    confirmOptions?: ConfirmOptions,\n    blockHashCtx?: { blockhash: string; lastValidBlockHeight: number },\n): Promise<TransactionSignature> {\n    const txId = await rpc.sendTransaction(tx, confirmOptions);\n\n    await confirmTx(rpc, txId, confirmOptions, blockHashCtx);\n\n    return txId;\n}\n\n/**\n * Confirms a transaction with a given txId.\n *\n * @param rpc               connection to use\n * @param txId              transaction signature to confirm\n * @param confirmOptions    confirmation options\n * @param blockHashCtx      blockhash context for confirmation\n * @return SignatureResult\n */\nexport async function confirmTx(\n    rpc: Rpc,\n    txId: string,\n    confirmOptions?: ConfirmOptions,\n    _blockHashCtx?: { blockhash: string; lastValidBlockHeight: number }, // TODO: add this back in.\n): Promise<RpcResponseAndContext<SignatureResult>> {\n    const commitment =\n        confirmOptions?.commitment || rpc.commitment || 'confirmed';\n    const timeout = 80_000;\n    const interval = isLocalTest(rpc.rpcEndpoint) ? 200 : 1000;\n\n    let elapsed = 0;\n\n    const res = await new Promise<TransactionSignature>((resolve, reject) => {\n        const intervalId = setInterval(async () => {\n            elapsed += interval;\n\n            if (elapsed >= timeout) {\n                clearInterval(intervalId);\n                reject(\n                    new Error(`Transaction ${txId}'s confirmation timed out`),\n                );\n            }\n\n            const status = await rpc.getSignatureStatuses([txId]);\n\n            if (status?.value[0]?.confirmationStatus === commitment) {\n                clearInterval(intervalId);\n                resolve(txId);\n            }\n        }, interval);\n    });\n\n    const slot = await rpc.getSlot();\n    await rpc.confirmTransactionIndexed(slot);\n\n    return { context: { slot }, value: { err: null } };\n}\n\n/**\n * Builds a versioned Transaction from instructions and signs it.\n *\n * @param instructions          instructions to include in the transaction\n * @param payer                 payer of the transaction\n * @param blockhash             recent blockhash to use in the transaction\n * @param additionalSigners     non-feepayer signers to include in the\n *                              transaction\n * @param lookupTableAccounts   lookup table accounts to include in the\n *                              transaction\n */\nexport function buildAndSignTx(\n    instructions: TransactionInstruction[],\n    payer: Signer,\n    blockhash: string,\n    additionalSigners: Signer[] = [],\n    lookupTableAccounts?: AddressLookupTableAccount[],\n): VersionedTransaction {\n    if (additionalSigners.includes(payer))\n        throw new Error('payer must not be in additionalSigners');\n    const allSigners = [payer, ...additionalSigners];\n\n    const tx = buildTx(\n        instructions,\n        payer.publicKey,\n        blockhash,\n        lookupTableAccounts,\n    );\n\n    tx.sign(allSigners);\n\n    return tx;\n}\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { TreeInfo, TreeType } from '../state/types';\nimport { featureFlags, StateTreeLUTPair } from '../constants';\n\n/**\n * @deprecated use {@link getTreeInfoByPubkey} instead\n */\nexport function getStateTreeInfoByPubkey(\n    treeInfos: TreeInfo[],\n    treeOrQueue: PublicKey,\n): TreeInfo {\n    return getTreeInfoByPubkey(treeInfos, treeOrQueue);\n}\n\nexport function getTreeInfoByPubkey(\n    treeInfos: TreeInfo[],\n    treeOrQueue: PublicKey,\n): TreeInfo {\n    const treeInfo = treeInfos.find(\n        info => info.tree.equals(treeOrQueue) || info.queue.equals(treeOrQueue),\n    );\n    if (!treeInfo) {\n        throw new Error(\n            `No associated TreeInfo found for tree or queue. Please set activeStateTreeInfos with latest Tree accounts. If you use custom state trees, set manually. Pubkey: ${treeOrQueue.toBase58()}`,\n        );\n    }\n    if (!treeInfo.queue) {\n        throw new Error(\n            'Queue must not be null for state tree. Please set activeStateTreeInfos with latest Tree accounts. If you use custom state trees, set manually. Pubkey: ' +\n                treeOrQueue.toBase58(),\n        );\n    }\n\n    return treeInfo;\n}\n\n/**\n * @deprecated use {@link selectStateTreeInfo} instead.\n *\n * Get a random tree and queue from a set of provided state tree infos.\n *\n * @param infos Set of state tree infos\n * @returns A random tree and queue\n */\nexport function pickRandomTreeAndQueue(infos: TreeInfo[]): {\n    tree: PublicKey;\n    queue: PublicKey;\n} {\n    const length = infos.length;\n    const index = Math.floor(Math.random() * length);\n\n    let selectedIndex: number;\n    if (index !== undefined) {\n        if (index < 0 || index >= infos.length) {\n            throw new Error(\n                `Index ${index} out of bounds for infos array of length ${infos.length}`,\n            );\n        }\n        selectedIndex = index;\n    } else {\n        selectedIndex = Math.floor(Math.random() * infos.length);\n    }\n\n    return infos[selectedIndex];\n}\n\nconst MAX_HOTSPOTS = 5;\n\n/**\n * Select a pseudo-random active state tree info from the set of provided state\n * tree infos.\n *\n * Using this reduces write-lock contention on state trees.\n *\n * @param infos                 Set of state tree infos\n *\n * @param treeType              Optional: Only use if you know what you are\n *                              doing. The type of tree.\n * @param useMaxConcurrency     Optional: Only use if you know what you are\n *                              doing. If true, select from all infos.\n *\n * @returns A pseudo-randomly selected tree info\n */\nexport function selectStateTreeInfo(\n    infos: TreeInfo[],\n    treeType: TreeType = featureFlags.isV2()\n        ? TreeType.StateV2\n        : TreeType.StateV1,\n    useMaxConcurrency: boolean = false,\n): TreeInfo {\n    const activeInfos = infos.filter(t => !t.nextTreeInfo);\n    const filteredInfos = activeInfos.filter(t => t.treeType === treeType);\n\n    if (filteredInfos.length === 0) {\n        throw new Error(\n            'No active state tree infos found for the specified tree type',\n        );\n    }\n\n    const length = useMaxConcurrency\n        ? filteredInfos.length\n        : Math.min(MAX_HOTSPOTS, filteredInfos.length);\n    const index = Math.floor(Math.random() * length);\n\n    if (!filteredInfos[index].queue) {\n        throw new Error('Queue must not be null for state tree');\n    }\n\n    return filteredInfos[index];\n}\n\n/**\n * Get active state tree infos from LUTs.\n *\n * @param connection            The connection to the cluster\n * @param stateTreeLUTPairs     The state tree lookup table pairs\n *\n * @returns The active state tree infos\n */\nexport async function getAllStateTreeInfos({\n    connection,\n    stateTreeLUTPairs,\n}: {\n    connection: Connection;\n    stateTreeLUTPairs: StateTreeLUTPair[];\n}): Promise<TreeInfo[]> {\n    const stateTreeLookupTablesAndNullifyLookupTables = await Promise.all(\n        stateTreeLUTPairs.map(async lutPair => {\n            return {\n                stateTreeLookupTable: await connection.getAddressLookupTable(\n                    lutPair.stateTreeLookupTable,\n                ),\n                nullifyLookupTable: await connection.getAddressLookupTable(\n                    lutPair.nullifyLookupTable,\n                ),\n            };\n        }),\n    );\n\n    const contexts: TreeInfo[] = [];\n\n    for (const {\n        stateTreeLookupTable,\n        nullifyLookupTable,\n    } of stateTreeLookupTablesAndNullifyLookupTables) {\n        if (!stateTreeLookupTable.value) {\n            throw new Error('State tree lookup table not found');\n        }\n\n        if (!nullifyLookupTable.value) {\n            throw new Error('Nullify table not found');\n        }\n\n        const stateTreePubkeys = stateTreeLookupTable.value.state.addresses;\n        const nullifyLookupTablePubkeys =\n            nullifyLookupTable.value.state.addresses;\n\n        if (stateTreePubkeys.length % 3 !== 0) {\n            throw new Error(\n                'State tree lookup table must have a multiple of 3 addresses',\n            );\n        }\n\n        for (let i = 0; i < stateTreePubkeys.length; i += 3) {\n            const tree = stateTreePubkeys[i];\n            const queue = stateTreePubkeys[i + 1];\n            const cpiContext = stateTreePubkeys[i + 2];\n            let nextTreeInfo: TreeInfo | null = null;\n\n            if (!tree || !queue || !cpiContext) {\n                throw new Error('Invalid state tree pubkeys structure');\n            }\n            if (\n                nullifyLookupTablePubkeys\n                    .map(addr => addr.toBase58())\n                    .includes(tree.toBase58())\n            ) {\n                // we assign a valid tree later\n                nextTreeInfo = {\n                    tree: PublicKey.default,\n                    queue: PublicKey.default,\n                    cpiContext: PublicKey.default,\n                    treeType: TreeType.StateV1,\n                    nextTreeInfo: null,\n                };\n            }\n            contexts.push({\n                tree,\n                queue,\n                cpiContext,\n                treeType: TreeType.StateV1,\n                nextTreeInfo,\n            });\n        }\n\n        /// for each context, check if the tree is in the nullifyLookupTable\n        for (const context of contexts) {\n            if (context.nextTreeInfo?.tree.equals(PublicKey.default)) {\n                const nextAvailableTreeInfo = contexts.find(\n                    ctx => !ctx.nextTreeInfo,\n                );\n                if (!nextAvailableTreeInfo) {\n                    throw new Error(\n                        'No available tree info found to assign as next tree',\n                    );\n                }\n                context.nextTreeInfo = nextAvailableTreeInfo;\n            }\n        }\n    }\n\n    return contexts;\n}\n","import BN from 'bn.js';\nimport {\n    PublicKey,\n    TransactionInstruction,\n    SystemProgram,\n} from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport {\n    CompressedAccountWithMerkleContext,\n    ValidityProof,\n    InstructionDataInvoke,\n    TreeInfo,\n    bn,\n    createCompressedAccountLegacy,\n    CompressedAccountLegacy,\n} from '../../state';\nimport {\n    packCompressedAccounts,\n    toAccountMetas,\n} from '../../programs/system/pack';\nimport { defaultStaticAccountsStruct } from '../../constants';\nimport {\n    validateSameOwner,\n    validateSufficientBalance,\n} from '../../utils/validation';\nimport { packNewAddressParams, NewAddressParams } from '../../utils';\nimport { encodeInstructionDataInvoke, invokeAccountsLayout } from './layout';\n\nexport const sumUpLamports = (\n    accounts: CompressedAccountWithMerkleContext[],\n): BN => {\n    return accounts.reduce(\n        (acc, account) => acc.add(bn(account.lamports)),\n        bn(0),\n    );\n};\n\n/**\n * Create compressed account system transaction params\n */\ntype CreateAccountWithSeedParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * Address params for the new compressed account.\n     */\n    newAddressParams: NewAddressParams;\n    /**\n     * Address of the new compressed account\n     */\n    newAddress: number[];\n    /**\n     * Recent validity proof proving that there's no existing compressed account\n     * registered with newAccountAddress\n     */\n    recentValidityProof: ValidityProof | null;\n    /**\n     * State tree pubkey. Defaults to a public state tree if unspecified.\n     */\n    outputStateTreeInfo?: TreeInfo;\n    /**\n     * Public key of the program to assign as the owner of the created account.\n     */\n    programId?: PublicKey;\n    /**\n     * Optional input accounts to transfer lamports from into the new compressed\n     * account.\n     */\n    inputCompressedAccounts?: CompressedAccountWithMerkleContext[];\n    /**\n     * Optional input state root indices of 'inputCompressedAccounts'. The\n     * expiry is tied to the 'recentValidityProof'.\n     */\n    inputStateRootIndices?: number[];\n    /**\n     * Optional lamports to transfer into the new compressed account.\n     */\n    lamports?: number | BN;\n};\n\n/**\n * Defines the parameters for the transfer method\n */\ntype TransferParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * The input state to be consumed.\n     */\n    inputCompressedAccounts: CompressedAccountWithMerkleContext[];\n    /**\n     * Recipient address.\n     */\n    toAddress: PublicKey;\n    /**\n     * Amount of lamports to transfer.\n     */\n    lamports: number | BN;\n    /**\n     * The recent state root indices of the input state. The expiry is tied to\n     * the proof.\n     */\n    recentInputStateRootIndices: number[];\n    /**\n     * The recent validity proof for state inclusion of the input state. Expires\n     * after n slots.\n     */\n    recentValidityProof: ValidityProof | null;\n};\n\n/**\n * Defines the parameters for the transfer method\n */\ntype CompressParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * address that the lamports are attached to. also defaults to the recipient owner\n     */\n    toAddress: PublicKey;\n    /**\n     * amount of lamports to compress.\n     */\n    lamports: number | BN;\n    /**\n     * The state tree that the tx output should be inserted into.\n     */\n    outputStateTreeInfo: TreeInfo;\n};\n\n/**\n * Defines the parameters for the transfer method\n */\ntype DecompressParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * The input state to be consumed.\n     */\n    inputCompressedAccounts: CompressedAccountWithMerkleContext[];\n    /**\n     * Recipient address of uncompressed lamports\n     */\n    toAddress: PublicKey;\n    /**\n     * amount of lamports to decompress.\n     */\n    lamports: number | BN;\n    /**\n     * The recent state root indices of the input state. The expiry is tied to\n     * the proof.\n     */\n    recentInputStateRootIndices: number[];\n    /**\n     * The recent validity proof for state inclusion of the input state. It\n     * expires after n slots.\n     */\n    recentValidityProof: ValidityProof | null;\n};\n\nconst SOL_POOL_PDA_SEED = Buffer.from('sol_pool_pda');\n\nexport class LightSystemProgram {\n    /**\n     * @internal\n     */\n    constructor() {}\n\n    /**\n     * The LightSystemProgram program ID.\n     */\n    static programId: PublicKey = new PublicKey(\n        'SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7',\n    );\n\n    /**\n     * @internal\n     * Cwct1kQLwJm8Z3HetLu8m4SXkhD6FZ5fXbJQCxTxPnGY\n     *\n     */\n    static deriveCompressedSolPda(): PublicKey {\n        const seeds = [SOL_POOL_PDA_SEED];\n        const [address, _] = PublicKey.findProgramAddressSync(\n            seeds,\n            this.programId,\n        );\n        return address;\n    }\n\n    static createTransferOutputState(\n        inputCompressedAccounts: CompressedAccountWithMerkleContext[],\n        toAddress: PublicKey,\n        lamports: number | BN,\n    ): CompressedAccountLegacy[] {\n        lamports = bn(lamports);\n        const inputLamports = sumUpLamports(inputCompressedAccounts);\n        const changeLamports = inputLamports.sub(lamports);\n\n        validateSufficientBalance(changeLamports);\n\n        if (changeLamports.eq(bn(0))) {\n            return [createCompressedAccountLegacy(toAddress, lamports)];\n        }\n\n        validateSameOwner(inputCompressedAccounts);\n\n        const outputCompressedAccounts: CompressedAccountLegacy[] = [\n            createCompressedAccountLegacy(\n                inputCompressedAccounts[0].owner,\n                changeLamports,\n            ),\n            createCompressedAccountLegacy(toAddress, lamports),\n        ];\n        return outputCompressedAccounts;\n    }\n\n    static createDecompressOutputState(\n        inputCompressedAccounts: CompressedAccountWithMerkleContext[],\n        lamports: number | BN,\n    ): CompressedAccountLegacy[] {\n        lamports = bn(lamports);\n        const inputLamports = sumUpLamports(inputCompressedAccounts);\n        const changeLamports = inputLamports.sub(lamports);\n\n        validateSufficientBalance(changeLamports);\n\n        /// lamports gets decompressed\n        if (changeLamports.eq(bn(0))) {\n            return [];\n        }\n\n        validateSameOwner(inputCompressedAccounts);\n\n        const outputCompressedAccounts: CompressedAccountLegacy[] = [\n            createCompressedAccountLegacy(\n                inputCompressedAccounts[0].owner,\n                changeLamports,\n            ),\n        ];\n        return outputCompressedAccounts;\n    }\n\n    /**\n     * No data by default\n     */\n    static createNewAddressOutputState(\n        address: number[],\n        owner: PublicKey,\n        lamports?: BN | number,\n        inputCompressedAccounts?: CompressedAccountWithMerkleContext[],\n    ): CompressedAccountLegacy[] {\n        lamports = bn(lamports ?? 0);\n        const inputLamports = sumUpLamports(inputCompressedAccounts ?? []);\n        const changeLamports = inputLamports.sub(lamports);\n\n        validateSufficientBalance(changeLamports);\n\n        if (changeLamports.eq(bn(0)) || !inputCompressedAccounts) {\n            return [\n                createCompressedAccountLegacy(\n                    owner,\n                    lamports,\n                    undefined,\n                    address,\n                ),\n            ];\n        }\n\n        validateSameOwner(inputCompressedAccounts);\n        const outputCompressedAccounts: CompressedAccountLegacy[] = [\n            createCompressedAccountLegacy(\n                inputCompressedAccounts[0].owner,\n                changeLamports,\n            ),\n            createCompressedAccountLegacy(owner, lamports, undefined, address),\n        ];\n        return outputCompressedAccounts;\n    }\n\n    /**\n     * Creates instruction to create compressed account with PDA.\n     * Cannot write data.\n     */\n    static async createAccount({\n        payer,\n        newAddressParams,\n        newAddress,\n        recentValidityProof,\n        outputStateTreeInfo,\n        inputCompressedAccounts,\n        inputStateRootIndices,\n        lamports,\n    }: CreateAccountWithSeedParams): Promise<TransactionInstruction> {\n        const outputCompressedAccounts = this.createNewAddressOutputState(\n            newAddress,\n            payer,\n            lamports,\n            inputCompressedAccounts,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts: _remainingAccounts,\n        } = packCompressedAccounts(\n            inputCompressedAccounts ?? [],\n            inputStateRootIndices ?? [],\n            outputCompressedAccounts,\n            !inputCompressedAccounts || inputCompressedAccounts.length === 0\n                ? outputStateTreeInfo\n                : undefined,\n        );\n\n        const { newAddressParamsPacked, remainingAccounts } =\n            packNewAddressParams([newAddressParams], _remainingAccounts);\n\n        const rawData: InstructionDataInvoke = {\n            proof: recentValidityProof,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            newAddressParams: newAddressParamsPacked,\n            compressOrDecompressLamports: null,\n            isCompress: false,\n        };\n        const data = encodeInstructionDataInvoke(rawData);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: null,\n            decompressionRecipient: null,\n            systemProgram: SystemProgram.programId,\n        });\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Creates a transaction instruction that transfers compressed lamports from\n     * one owner to another.\n     */\n    static async transfer({\n        payer,\n        inputCompressedAccounts,\n        toAddress,\n        lamports,\n        recentInputStateRootIndices,\n        recentValidityProof,\n    }: TransferParams): Promise<TransactionInstruction> {\n        /// Create output state\n        const outputCompressedAccounts = this.createTransferOutputState(\n            inputCompressedAccounts,\n            toAddress,\n            lamports,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts,\n        } = packCompressedAccounts(\n            inputCompressedAccounts,\n            recentInputStateRootIndices,\n            outputCompressedAccounts,\n        );\n\n        /// Encode instruction data\n        const rawInputs: InstructionDataInvoke = {\n            proof: recentValidityProof,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            newAddressParams: [],\n            compressOrDecompressLamports: null,\n            isCompress: false,\n        };\n\n        const data = encodeInstructionDataInvoke(rawInputs);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: null,\n            decompressionRecipient: null,\n            systemProgram: SystemProgram.programId,\n        });\n\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Creates a transaction instruction that transfers compressed lamports from\n     * one owner to another.\n     */\n    static async compress({\n        payer,\n        toAddress,\n        lamports,\n        outputStateTreeInfo,\n    }: CompressParams): Promise<TransactionInstruction> {\n        /// Create output state\n        lamports = bn(lamports);\n\n        const outputCompressedAccount = createCompressedAccountLegacy(\n            toAddress,\n            lamports,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts,\n        } = packCompressedAccounts(\n            [],\n            [],\n            [outputCompressedAccount],\n            outputStateTreeInfo,\n        );\n\n        /// Encode instruction data\n        const rawInputs: InstructionDataInvoke = {\n            proof: null,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            newAddressParams: [],\n            compressOrDecompressLamports: lamports,\n            isCompress: true,\n        };\n\n        const data = encodeInstructionDataInvoke(rawInputs);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: LightSystemProgram.deriveCompressedSolPda(),\n            decompressionRecipient: null,\n            systemProgram: SystemProgram.programId,\n        });\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Creates a transaction instruction that transfers compressed lamports from\n     * one owner to another.\n     */\n    static async decompress({\n        payer,\n        inputCompressedAccounts,\n        toAddress,\n        lamports,\n        recentInputStateRootIndices,\n        recentValidityProof,\n    }: DecompressParams): Promise<TransactionInstruction> {\n        /// Create output state\n        lamports = bn(lamports);\n\n        const outputCompressedAccounts = this.createDecompressOutputState(\n            inputCompressedAccounts,\n            lamports,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts,\n        } = packCompressedAccounts(\n            inputCompressedAccounts,\n            recentInputStateRootIndices,\n            outputCompressedAccounts,\n        );\n        /// Encode instruction data\n        const rawInputs: InstructionDataInvoke = {\n            proof: recentValidityProof,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            newAddressParams: [],\n            compressOrDecompressLamports: lamports,\n            isCompress: false,\n        };\n        const data = encodeInstructionDataInvoke(rawInputs);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: LightSystemProgram.deriveCompressedSolPda(),\n            decompressionRecipient: toAddress,\n            systemProgram: SystemProgram.programId,\n        });\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n}\n","import BN from 'bn.js';\n\nimport { CompressedAccountWithMerkleContext } from '../../state';\n\nimport { bn } from '../../state';\n\n/**\n * Selects the minimal number of compressed SOL accounts for a transfer.\n *\n * 1. Sorts the accounts by amount in descending order\n * 2. Accumulates the amount until it is greater than or equal to the transfer\n *    amount\n */\nexport function selectMinCompressedSolAccountsForTransfer(\n    accounts: CompressedAccountWithMerkleContext[],\n    transferLamports: BN | number,\n): [selectedAccounts: CompressedAccountWithMerkleContext[], total: BN] {\n    let accumulatedLamports = bn(0);\n    transferLamports = bn(transferLamports);\n\n    const selectedAccounts: CompressedAccountWithMerkleContext[] = [];\n\n    accounts.sort((a, b) => b.lamports.cmp(a.lamports));\n\n    for (const account of accounts) {\n        if (accumulatedLamports.gte(bn(transferLamports))) break;\n        accumulatedLamports = accumulatedLamports.add(account.lamports);\n        selectedAccounts.push(account);\n    }\n\n    if (accumulatedLamports.lt(bn(transferLamports))) {\n        throw new Error(\n            `Insufficient balance for transfer. Required: ${transferLamports.toString()}, available: ${accumulatedLamports.toString()}`,\n        );\n    }\n\n    return [selectedAccounts, accumulatedLamports];\n}\n","import { LightWasm } from '../test-rpc/test-rpc';\nimport BN from 'bn.js';\nimport { bn } from '../../state';\nimport { HIGHEST_ADDRESS_PLUS_ONE } from '../../constants';\n\nexport class IndexedElement {\n    public index: number;\n    public value: BN;\n    public nextIndex: number;\n\n    constructor(index: number, value: BN, nextIndex: number) {\n        this.index = index;\n        this.value = value;\n        this.nextIndex = nextIndex;\n    }\n\n    public equals(other: IndexedElement): boolean {\n        return this.value.eq(other.value);\n    }\n\n    public compareTo(other: IndexedElement): number {\n        return this.value.cmp(other.value);\n    }\n\n    public hash(lightWasm: LightWasm, nextValue: BN): Uint8Array {\n        try {\n            const hash = lightWasm.poseidonHash([\n                bn(this.value.toArray('be', 32)).toString(),\n                bn(this.nextIndex).toString(),\n                bn(nextValue.toArray('be', 32)).toString(),\n            ]);\n            return hash;\n        } catch (error) {\n            throw new Error('Hashing failed');\n        }\n    }\n}\n\nexport class IndexedElementBundle {\n    public newLowElement: IndexedElement;\n    public newElement: IndexedElement;\n    public newElementNextValue: BN;\n\n    constructor(\n        newLowElement: IndexedElement,\n        newElement: IndexedElement,\n        newElementNextValue: BN,\n    ) {\n        this.newLowElement = newLowElement;\n        this.newElement = newElement;\n        this.newElementNextValue = newElementNextValue;\n    }\n}\n\n/**\n * This indexed array implementation mirrors the rust implementation of the\n * indexed merkle tree. It stores the elements of the indexed merkle tree.\n */\nexport class IndexedArray {\n    public elements: Array<IndexedElement>;\n    public currentNodeIndex: number;\n    public highestElementIndex: number;\n\n    constructor(\n        elements: Array<IndexedElement>,\n        currentNodeIndex: number,\n        highestElementIndex: number,\n    ) {\n        this.elements = elements;\n        this.currentNodeIndex = currentNodeIndex;\n        this.highestElementIndex = highestElementIndex;\n    }\n\n    public static default(): IndexedArray {\n        return new IndexedArray([new IndexedElement(0, bn(0), 0)], 0, 0);\n    }\n\n    public get(index: number): IndexedElement | undefined {\n        return this.elements[index];\n    }\n\n    public length(): number {\n        return Number(this.currentNodeIndex);\n    }\n\n    public isEmpty(): boolean {\n        return this.currentNodeIndex === 0;\n    }\n\n    public findElement(value: BN): IndexedElement | undefined {\n        return this.elements\n            .slice(0, this.length() + 1)\n            .find(node => node.value === value);\n    }\n\n    public init(): IndexedElementBundle {\n        try {\n            const init_value = HIGHEST_ADDRESS_PLUS_ONE;\n            return this.append(init_value);\n        } catch (error) {\n            throw new Error(`Failed to initialize IndexedArray: ${error}`);\n        }\n    }\n\n    /**\n     * Finds the index of the low element for the given `value` which should not be part of the array.\n     * Low element is the greatest element which still has a lower value than the provided one.\n     * Low elements are used in non-membership proofs.\n     */\n    public findLowElementIndex(value: BN): number | undefined {\n        // Try to find element whose next element is higher than the provided value.\n        for (let i = 0; i <= this.length(); i++) {\n            const node = this.elements[i];\n            if (\n                this.elements[node.nextIndex].value.gt(value) &&\n                node.value.lt(value)\n            ) {\n                return i;\n            } else if (node.value.eq(value)) {\n                throw new Error('Element already exists in the array');\n            }\n        }\n        // If no such element was found, it means that our value is going to be the greatest in the array.\n        // This means that the currently greatest element is going to be the low element of our value.\n        return this.highestElementIndex;\n    }\n\n    /**\n     * Returns the low element for the given value and the next value for that low element.\n     * Low element is the greatest element which still has lower value than the provided one.\n     * Low elements are used in non-membership proofs.\n     */\n    public findLowElement(\n        value: BN,\n    ): [IndexedElement | undefined, BN | undefined] {\n        const lowElementIndex = this.findLowElementIndex(value);\n        if (lowElementIndex === undefined) return [undefined, undefined];\n        const lowElement = this.elements[lowElementIndex];\n        return [lowElement, this.elements[lowElement.nextIndex].value];\n    }\n\n    // /**\n    //  * Returns the index of the low element for the given `value`, which should be the part of the array.\n    //  * Low element is the greatest element which still has lower value than the provided one.\n    //  * Low elements are used in non-membership proofs.\n    //  */\n    // public findLowElementIndexForExistingElement(\n    //     value: BN,\n    // ): number | undefined {\n    //     for (let i = 0; i <= this.length(); i++) {\n    //         const node = this.elements[i];\n    //         if (this.elements[node.nextIndex].value === value) {\n    //             return i;\n    //         }\n    //     }\n    //     return undefined;\n    // }\n\n    /**\n     * Returns the hash of the given element. That hash consists of:\n     * - The value of the given element.\n     * - The `nextIndex` of the given element.\n     * - The value of the element pointed by `nextIndex`.\n     */\n    public hashElement(\n        lightWasm: LightWasm,\n        index: number,\n    ): Uint8Array | undefined {\n        const element = this.elements[index];\n        if (!element) return undefined;\n        const nextElement = this.elements[element.nextIndex];\n        if (!nextElement) return undefined;\n\n        const hash = lightWasm.poseidonHash([\n            bn(element.value.toArray('be', 32)).toString(),\n            bn(element.nextIndex).toString(),\n            bn(nextElement.value.toArray('be', 32)).toString(),\n        ]);\n\n        return hash;\n    }\n\n    /**\n     * Appends a new element with the given value to the indexed array.\n     * It finds the low element index and uses it to append the new element correctly.\n     * @param value The value of the new element to append.\n     * @returns The new element and its low element after insertion.\n     */\n    public append(value: BN): IndexedElementBundle {\n        const lowElementIndex = this.findLowElementIndex(value);\n        if (lowElementIndex === undefined) {\n            throw new Error('Low element index not found.');\n        }\n        return this.appendWithLowElementIndex(lowElementIndex, value);\n    }\n\n    /**\n     * Appends a new element with the given value to the indexed array using a specific low element index.\n     * This method ensures the new element is placed correctly relative to the low element.\n     * @param lowElementIndex The index of the low element.\n     * @param value The value of the new element to append.\n     * @returns The new element and its updated low element.\n     */\n    public appendWithLowElementIndex(\n        lowElementIndex: number,\n        value: BN,\n    ): IndexedElementBundle {\n        const lowElement = this.elements[lowElementIndex];\n\n        if (lowElement.nextIndex === 0) {\n            if (value.lte(lowElement.value)) {\n                throw new Error(\n                    'New element value must be greater than the low element value.',\n                );\n            }\n        } else {\n            const nextElement = this.elements[lowElement.nextIndex];\n\n            if (value.lte(lowElement.value)) {\n                throw new Error(\n                    'New element value must be greater than the low element value.',\n                );\n            }\n\n            if (value.gte(nextElement.value)) {\n                throw new Error(\n                    'New element value must be less than the next element value.',\n                );\n            }\n        }\n\n        const newElementBundle = this.newElementWithLowElementIndex(\n            lowElementIndex,\n            value,\n        );\n\n        // If the old low element wasn't pointing to any element, it means that:\n        //\n        // * It used to be the highest element.\n        // * Our new element, which we are appending, is going the be the\n        //   highest element.\n        //\n        // Therefore, we need to save the new element index as the highest\n        // index.\n        if (lowElement.nextIndex === 0) {\n            this.highestElementIndex = newElementBundle.newElement.index;\n        }\n\n        // Insert new node.\n        this.currentNodeIndex = newElementBundle.newElement.index;\n        this.elements[this.length()] = newElementBundle.newElement;\n\n        // Update low element.\n        this.elements[lowElementIndex] = newElementBundle.newLowElement;\n\n        return newElementBundle;\n    }\n\n    /**\n     * Finds the lowest element in the array.\n     * @returns The lowest element or undefined if the array is empty.\n     */\n    public lowest(): IndexedElement | undefined {\n        return this.elements.length > 0 ? this.elements[0] : undefined;\n    }\n\n    /**\n     * Creates a new element with the specified value and updates the low element index accordingly.\n     * @param lowElementIndex The index of the low element.\n     * @param value The value for the new element.\n     * @returns A bundle containing the new element, the updated low element, and the value of the next element.\n     */\n    public newElementWithLowElementIndex(\n        lowElementIndex: number,\n        value: BN,\n    ): IndexedElementBundle {\n        const newLowElement = this.elements[lowElementIndex];\n\n        const newElementIndex = this.currentNodeIndex + 1;\n        const newElement = new IndexedElement(\n            newElementIndex,\n            value,\n            newLowElement.nextIndex,\n        );\n        newLowElement.nextIndex = newElementIndex;\n\n        const newElementNextValue = this.elements[newElement.nextIndex].value;\n\n        return new IndexedElementBundle(\n            newLowElement,\n            newElement,\n            newElementNextValue,\n        );\n    }\n\n    /**\n     * Creates a new element with the specified value by first finding the appropriate low element index.\n     * @param value The value for the new element.\n     * @returns A bundle containing the new element, the updated low element, and the value of the next element.\n     */\n    public newElement(value: BN): IndexedElementBundle {\n        const lowElementIndex = this.findLowElementIndex(value);\n        if (lowElementIndex === undefined) {\n            throw new Error('Low element index not found.');\n        }\n        return this.newElementWithLowElementIndex(lowElementIndex, value);\n    }\n}\n","import { LightWasm } from '../test-rpc/test-rpc';\n\nexport const DEFAULT_ZERO = '0';\n\n/**\n * @callback hashFunction\n * @param left Left leaf\n * @param right Right leaf\n */\n/**\n * Merkle tree\n */\nexport class MerkleTree {\n    /**\n     * Constructor\n     * @param {number} levels Number of levels in the tree\n     * @param {Array} [elements] Initial elements\n     * @param {Object} options\n     * @param {hashFunction} [options.hashFunction] Function used to hash 2 leaves\n     * @param [options.zeroElement] Value for non-existent leaves\n     */\n    levels: number;\n    capacity: number;\n    zeroElement;\n    _zeros: string[];\n    _layers: string[][];\n    _lightWasm: LightWasm;\n\n    constructor(\n        levels: number,\n        lightWasm: LightWasm,\n        elements: string[] = [],\n        { zeroElement = DEFAULT_ZERO } = {},\n    ) {\n        this.levels = levels;\n        this.capacity = 2 ** levels;\n        this.zeroElement = zeroElement;\n        this._lightWasm = lightWasm;\n        if (elements.length > this.capacity) {\n            throw new Error('Tree is full');\n        }\n        this._zeros = [];\n        this._layers = [];\n        this._layers[0] = elements;\n        this._zeros[0] = this.zeroElement;\n\n        for (let i = 1; i <= levels; i++) {\n            this._zeros[i] = this._lightWasm.poseidonHashString([\n                this._zeros[i - 1],\n                this._zeros[i - 1],\n            ]);\n        }\n        this._rebuild();\n    }\n\n    _rebuild() {\n        for (let level = 1; level <= this.levels; level++) {\n            this._layers[level] = [];\n            for (\n                let i = 0;\n                i < Math.ceil(this._layers[level - 1].length / 2);\n                i++\n            ) {\n                this._layers[level][i] = this._lightWasm.poseidonHashString([\n                    this._layers[level - 1][i * 2],\n                    i * 2 + 1 < this._layers[level - 1].length\n                        ? this._layers[level - 1][i * 2 + 1]\n                        : this._zeros[level - 1],\n                ]);\n            }\n        }\n    }\n\n    /**\n     * Get tree root\n     * @returns {*}\n     */\n    root() {\n        return this._layers[this.levels].length > 0\n            ? this._layers[this.levels][0]\n            : this._zeros[this.levels];\n    }\n\n    /**\n     * Insert new element into the tree\n     * @param element Element to insert\n     */\n\n    insert(element: string) {\n        if (this._layers[0].length >= this.capacity) {\n            throw new Error('Tree is full');\n        }\n        this.update(this._layers[0].length, element);\n    }\n\n    /**\n     * Insert multiple elements into the tree. Tree will be fully rebuilt during this operation.\n     * @param {Array} elements Elements to insert\n     */\n    bulkInsert(elements: string[]) {\n        if (this._layers[0].length + elements.length > this.capacity) {\n            throw new Error('Tree is full');\n        }\n        this._layers[0].push(...elements);\n        this._rebuild();\n    }\n\n    // TODO: update does not work debug\n    /**\n     * Change an element in the tree\n     * @param {number} index Index of element to change\n     * @param element Updated element value\n     */\n    update(index: number, element: string) {\n        // index 0 and 1 and element is the commitment hash\n        if (\n            isNaN(Number(index)) ||\n            index < 0 ||\n            index > this._layers[0].length ||\n            index >= this.capacity\n        ) {\n            throw new Error('Insert index out of bounds: ' + index);\n        }\n        this._layers[0][index] = element;\n        for (let level = 1; level <= this.levels; level++) {\n            index >>= 1;\n            this._layers[level][index] = this._lightWasm.poseidonHashString([\n                this._layers[level - 1][index * 2],\n                index * 2 + 1 < this._layers[level - 1].length\n                    ? this._layers[level - 1][index * 2 + 1]\n                    : this._zeros[level - 1],\n            ]);\n        }\n    }\n\n    /**\n     * Get merkle path to a leaf\n     * @param {number} index Leaf index to generate path for\n     * @returns {{pathElements: number[], pathIndex: number[]}} An object containing adjacent elements and left-right index\n     */\n    path(index: number) {\n        if (\n            isNaN(Number(index)) ||\n            index < 0 ||\n            index >= this._layers[0].length\n        ) {\n            throw new Error('Index out of bounds: ' + index);\n        }\n        const pathElements: string[] = [];\n        const pathIndices: number[] = [];\n        for (let level = 0; level < this.levels; level++) {\n            pathIndices[level] = index % 2;\n            pathElements[level] =\n                (index ^ 1) < this._layers[level].length\n                    ? this._layers[level][index ^ 1]\n                    : this._zeros[level];\n            index >>= 1;\n        }\n        return {\n            pathElements,\n            pathIndices,\n        };\n    }\n\n    /**\n     * Find an element in the tree\n     * @param element An element to find\n     * @param comparator A function that checks leaf value equality\n     * @returns {number} Index if element is found, otherwise -1\n     */\n    indexOf(\n        element: string,\n        comparator: ((element: string, el: string) => boolean) | null = null,\n    ) {\n        if (comparator) {\n            return this._layers[0].findIndex((el: string) =>\n                comparator(element, el),\n            );\n        } else {\n            return this._layers[0].indexOf(element);\n        }\n    }\n\n    /**\n     * Returns a copy of non-zero tree elements\n     * @returns {Object[]}\n     */\n    elements() {\n        return this._layers[0].slice();\n    }\n\n    /**\n     * Serialize entire tree state including intermediate layers into a plain object\n     * Deserializing it back will not require to recompute any hashes\n     * Elements are not converted to a plain type, this is responsibility of the caller\n     */\n    serialize() {\n        return {\n            levels: this.levels,\n            _zeros: this._zeros,\n            _layers: this._layers,\n        };\n    }\n\n    /**\n     * Deserialize data into a MerkleTree instance\n     * Make sure to provide the same hashFunction as was used in the source tree,\n     * otherwise the tree state will be invalid\n     *\n     * @param data\n     * @param hashFunction\n     * @returns {MerkleTree}\n     */\n    static deserialize(\n        data: any,\n        hashFunction: (left: string, right: string) => string,\n    ) {\n        const instance = Object.assign(Object.create(this.prototype), data);\n        instance._hash = hashFunction;\n        instance.capacity = 2 ** instance.levels;\n        instance.zeroElement = instance._zeros[0];\n        return instance;\n    }\n}\n","import {\n    ParsedMessageAccount,\n    ParsedTransactionWithMeta,\n    PublicKey,\n} from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport {\n    COMPUTE_BUDGET_PATTERN,\n    defaultStaticAccountsStruct,\n    INSERT_INTO_QUEUES_DISCRIMINATOR,\n    INVOKE_CPI_DISCRIMINATOR,\n    INVOKE_CPI_WITH_READ_ONLY_DISCRIMINATOR,\n    INVOKE_DISCRIMINATOR,\n} from '../../constants';\nimport {\n    convertToPublicTransactionEvent,\n    decodeInstructionDataInvoke,\n    decodeInstructionDataInvokeCpi,\n    deserializeAppendNullifyCreateAddressInputsIndexer,\n} from '../../programs';\nimport { Rpc } from '../../rpc';\nimport { InstructionDataInvoke, PublicTransactionEvent } from '../../state';\nimport {\n    decodeInstructionDataInvokeCpiWithReadOnly,\n    decodePublicTransactionEvent,\n} from '../../programs/system/layout';\nimport { Buffer } from 'buffer';\nimport { convertInvokeCpiWithReadOnlyToInvoke } from '../../utils';\n\ntype Deserializer<T> = (data: Buffer, tx: ParsedTransactionWithMeta) => T;\n\n/**\n * @internal\n * Returns newest first.\n *\n * */\nexport async function getParsedEvents(\n    rpc: Rpc,\n): Promise<PublicTransactionEvent[]> {\n    const events: PublicTransactionEvent[] = [];\n\n    const { noopProgram, accountCompressionProgram } =\n        defaultStaticAccountsStruct();\n\n    const signatures = (\n        await rpc.getSignaturesForAddress(\n            accountCompressionProgram,\n            undefined,\n            'confirmed',\n        )\n    ).map(s => s.signature);\n    const txs = await rpc.getParsedTransactions(signatures, {\n        maxSupportedTransactionVersion: 0,\n        commitment: 'confirmed',\n    });\n\n    for (const txParsed of txs) {\n        if (!txParsed || !txParsed.transaction || !txParsed.meta) continue;\n\n        if (\n            !txParsed.meta.innerInstructions ||\n            txParsed.meta.innerInstructions.length == 0\n        ) {\n            continue;\n        }\n\n        const messageV0 = txParsed.transaction.message;\n        const accKeys = messageV0.accountKeys;\n\n        const allAccounts = accKeys.map(a => a.pubkey);\n        const dataVec: Uint8Array[] = [];\n\n        // get tx wth sig\n        const txRaw = await rpc.getTransaction(\n            txParsed.transaction.signatures[0],\n            {\n                commitment: 'confirmed',\n                maxSupportedTransactionVersion: 0,\n            },\n        );\n\n        for (const ix of txRaw?.transaction.message.compiledInstructions ||\n            []) {\n            if (ix.data && ix.data.length > 0) {\n                const decodedData = Uint8Array.from(ix.data);\n                if (\n                    decodedData.length === COMPUTE_BUDGET_PATTERN.length &&\n                    COMPUTE_BUDGET_PATTERN.every(\n                        (byte, idx) => byte === decodedData[idx],\n                    )\n                ) {\n                    continue;\n                }\n                dataVec.push(decodedData);\n            }\n        }\n\n        const groupedAccountVec: PublicKey[][] = [];\n\n        if (\n            txRaw!.meta!.innerInstructions &&\n            txRaw!.meta!.innerInstructions.length > 0\n        ) {\n            for (const innerGroup of txRaw!.meta!.innerInstructions) {\n                for (const ix of innerGroup.instructions) {\n                    const group = ix.accounts.map(\n                        (accountIdx: number) => allAccounts[accountIdx],\n                    );\n                    groupedAccountVec.push(group);\n                    if (ix.data && ix.data.length > 0) {\n                        const decodedData = bs58.decode(ix.data);\n                        dataVec.push(decodedData);\n                    }\n                }\n            }\n        }\n\n        // const event = parseLightTransaction(dataVec, groupedAccountVec);\n        // if (event) {\n        //     events.push(event);\n        // }\n    }\n\n    if (events.length > 0) {\n        return events;\n    }\n\n    /// Filter by NOOP program\n    const transactionEvents = txs.filter(\n        (tx: ParsedTransactionWithMeta | null) => {\n            if (!tx) {\n                return false;\n            }\n            const accountKeys = tx.transaction.message.accountKeys;\n\n            const hasSplNoopAddress = accountKeys.some(\n                (item: ParsedMessageAccount) => {\n                    const itemStr =\n                        typeof item === 'string'\n                            ? item\n                            : item.pubkey.toBase58();\n                    return itemStr === noopProgram.toBase58();\n                },\n            );\n\n            return hasSplNoopAddress;\n        },\n    );\n\n    return parseEvents(transactionEvents, parsePublicTransactionEventWithIdl);\n}\n\nexport const parseEvents = <T>(\n    indexerEventsTransactions: (ParsedTransactionWithMeta | null)[],\n    deserializeFn: Deserializer<T>,\n): NonNullable<T>[] => {\n    const { noopProgram } = defaultStaticAccountsStruct();\n\n    const transactions: NonNullable<T>[] = [];\n    indexerEventsTransactions.forEach(tx => {\n        if (\n            !tx ||\n            !tx.meta ||\n            tx.meta.err ||\n            !tx.meta.innerInstructions ||\n            tx.meta.innerInstructions.length <= 0\n        ) {\n            return;\n        }\n\n        /// We only care about the very last inner instruction as it contains the\n        /// PublicTransactionEvent\n        tx.meta.innerInstructions.forEach(ix => {\n            if (ix.instructions.length > 0) {\n                const ixInner = ix.instructions[ix.instructions.length - 1];\n                // Type guard for partially parsed web3js types.\n                if (\n                    'data' in ixInner &&\n                    ixInner.data &&\n                    ixInner.programId.toBase58() === noopProgram.toBase58()\n                ) {\n                    const data = bs58.decode(ixInner.data);\n\n                    const decodedEvent = deserializeFn(Buffer.from(data), tx);\n\n                    if (decodedEvent !== null && decodedEvent !== undefined) {\n                        transactions.push(decodedEvent as NonNullable<T>);\n                    }\n                }\n            }\n        });\n    });\n\n    return transactions;\n};\n\n// TODO: make it type safe. have to reimplement the types from the IDL.\nexport const parsePublicTransactionEventWithIdl = (\n    data: Buffer,\n): PublicTransactionEvent | null => {\n    const numericData = Buffer.from(data.map(byte => byte));\n\n    try {\n        return decodePublicTransactionEvent(numericData);\n    } catch (error) {\n        console.error('Error deserializing event:', error);\n        return null;\n    }\n};\n\nexport function parseLightTransaction(\n    dataVec: Uint8Array[],\n    accountKeys: PublicKey[][],\n): PublicTransactionEvent | null | undefined {\n    let foundSystemInstruction = false;\n\n    let invokeData: InstructionDataInvoke | null = null;\n    let appendInputsData = null;\n\n    // First pass for system instructions\n    for (const data of dataVec) {\n        const discriminator = data.slice(0, 8);\n        const discriminatorStr = bs58.encode(discriminator);\n        const invokeDiscriminatorStr = bs58.encode(INVOKE_DISCRIMINATOR);\n        const invokeCpiDiscriminatorStr = bs58.encode(INVOKE_CPI_DISCRIMINATOR);\n        const invokeCpiWithReadOnlyDiscriminatorStr = bs58.encode(\n            INVOKE_CPI_WITH_READ_ONLY_DISCRIMINATOR,\n        );\n        if (discriminatorStr === invokeDiscriminatorStr) {\n            invokeData = decodeInstructionDataInvoke(Buffer.from(data));\n            foundSystemInstruction = true;\n            break;\n        }\n        if (discriminatorStr == invokeCpiDiscriminatorStr) {\n            invokeData = decodeInstructionDataInvokeCpi(Buffer.from(data));\n            foundSystemInstruction = true;\n            break;\n        }\n        if (discriminatorStr == invokeCpiWithReadOnlyDiscriminatorStr) {\n            const decoded = decodeInstructionDataInvokeCpiWithReadOnly(\n                Buffer.from(data),\n            );\n            invokeData = convertInvokeCpiWithReadOnlyToInvoke(decoded);\n            foundSystemInstruction = true;\n            break;\n        }\n    }\n    if (!foundSystemInstruction) return null;\n\n    for (const data of dataVec) {\n        const discriminator = data.slice(0, 8);\n        const discriminatorStr = bs58.encode(discriminator);\n        const insertIntoQueuesDiscriminatorStr = bs58.encode(\n            INSERT_INTO_QUEUES_DISCRIMINATOR,\n        );\n        console.log(discriminatorStr, insertIntoQueuesDiscriminatorStr);\n        if (discriminatorStr === insertIntoQueuesDiscriminatorStr) {\n            const dataSlice = data.slice(12);\n            appendInputsData =\n                deserializeAppendNullifyCreateAddressInputsIndexer(\n                    Buffer.from(dataSlice),\n                );\n        }\n    }\n\n    console.log(\"appendInputsData\", appendInputsData);\n    if (invokeData) {\n        return convertToPublicTransactionEvent(\n            appendInputsData,\n            accountKeys[accountKeys.length - 1],\n            invokeData,\n        );\n    } else {\n        return null;\n    }\n}\n","import { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { getParsedEvents } from './get-parsed-events';\nimport { Rpc } from '../../rpc';\nimport {\n    CompressedAccountWithMerkleContext,\n    bn,\n    MerkleContext,\n    createCompressedAccountWithMerkleContextLegacy,\n    TreeType,\n} from '../../state';\nimport { getStateTreeInfoByPubkey } from '../../utils/get-state-tree-infos';\n\nexport async function getCompressedAccountsByOwnerTest(\n    rpc: Rpc,\n    owner: PublicKey,\n) {\n    const unspentAccounts = await getCompressedAccountsForTest(rpc);\n    const byOwner = unspentAccounts.filter(acc => acc.owner.equals(owner));\n    return byOwner;\n}\n\nexport async function getCompressedAccountByHashTest(\n    rpc: Rpc,\n    hash: BN,\n): Promise<CompressedAccountWithMerkleContext | undefined> {\n    const unspentAccounts = await getCompressedAccountsForTest(rpc);\n    return unspentAccounts.find(acc => bn(acc.hash).eq(hash));\n}\n\nexport async function getMultipleCompressedAccountsByHashTest(\n    rpc: Rpc,\n    hashes: BN[],\n): Promise<CompressedAccountWithMerkleContext[]> {\n    const unspentAccounts = await getCompressedAccountsForTest(rpc);\n    return unspentAccounts\n        .filter(acc => hashes.some(hash => bn(acc.hash).eq(hash)))\n        .sort((a, b) => b.leafIndex - a.leafIndex);\n}\n\n/// Returns all unspent compressed accounts\nasync function getCompressedAccountsForTest(rpc: Rpc) {\n    const events = (await getParsedEvents(rpc)).reverse();\n    const allOutputAccounts: CompressedAccountWithMerkleContext[] = [];\n    const allInputAccountHashes: BN[] = [];\n    const infos = await rpc.getStateTreeInfos();\n\n    for (const event of events) {\n        for (\n            let index = 0;\n            index < event.outputCompressedAccounts.length;\n            index++\n        ) {\n            const maybeTree =\n                event.pubkeyArray[\n                    event.outputCompressedAccounts[index].merkleTreeIndex\n                ];\n\n            const treeInfo = getStateTreeInfoByPubkey(infos, maybeTree);\n\n            const account = event.outputCompressedAccounts[index];\n            const merkleContext: MerkleContext = {\n                treeInfo,\n                hash: bn(event.outputCompressedAccountHashes[index]),\n                leafIndex: event.outputLeafIndices[index],\n                // V2 trees always have proveByIndex = true in test-rpc.\n                proveByIndex: treeInfo.treeType === TreeType.StateV2,\n            };\n            const withCtx: CompressedAccountWithMerkleContext =\n                createCompressedAccountWithMerkleContextLegacy(\n                    merkleContext,\n                    account.compressedAccount.owner,\n                    account.compressedAccount.lamports,\n                    account.compressedAccount.data ?? undefined,\n                    account.compressedAccount.address ?? undefined,\n                );\n            allOutputAccounts.push(withCtx);\n        }\n        for (\n            let index = 0;\n            index < event.inputCompressedAccountHashes.length;\n            index++\n        ) {\n            const hash = event.inputCompressedAccountHashes[index];\n            allInputAccountHashes.push(bn(hash));\n        }\n    }\n\n    const unspentAccounts = allOutputAccounts.filter(\n        account =>\n            !allInputAccountHashes.some(hash => hash.eq(bn(account.hash))),\n    );\n    unspentAccounts.sort((a, b) => b.leafIndex - a.leafIndex);\n\n    return unspentAccounts;\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { getParsedEvents } from './get-parsed-events';\nimport BN from 'bn.js';\nimport { COMPRESSED_TOKEN_PROGRAM_ID, featureFlags } from '../../constants';\nimport { Rpc } from '../../rpc';\nimport { getStateTreeInfoByPubkey } from '../../utils/get-state-tree-infos';\nimport { ParsedTokenAccount, WithCursor } from '../../rpc-interface';\nimport {\n    PublicTransactionEvent,\n    MerkleContext,\n    createCompressedAccountWithMerkleContextLegacy,\n    bn,\n    TreeType,\n    CompressedAccountLegacy,\n} from '../../state';\nimport {\n    struct,\n    publicKey,\n    u64,\n    option,\n    vecU8,\n    u8,\n    Layout,\n} from '@coral-xyz/borsh';\n\ntype TokenData = {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: BN;\n    delegate: PublicKey | null;\n    state: number;\n    tlv: Buffer | null;\n};\n\n// for test-rpc\nexport const TokenDataLayout: Layout<TokenData> = struct([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    option(publicKey(), 'delegate'),\n    u8('state'),\n    option(vecU8(), 'tlv'),\n]);\n\nexport type EventWithParsedTokenTlvData = {\n    inputCompressedAccountHashes: number[][];\n    outputCompressedAccounts: ParsedTokenAccount[];\n};\n\n/**\n * Manually parse the compressed token layout for a given compressed account.\n * @param compressedAccount - The compressed account\n * @returns The parsed token data\n */\nexport function parseTokenLayoutWithIdl(\n    compressedAccount: CompressedAccountLegacy,\n    programId: PublicKey = COMPRESSED_TOKEN_PROGRAM_ID,\n): TokenData | null {\n    if (compressedAccount.data === null) return null;\n\n    const { data } = compressedAccount.data;\n\n    if (data.length === 0) return null;\n\n    if (compressedAccount.owner.toBase58() !== programId.toBase58()) {\n        throw new Error(\n            `Invalid owner ${compressedAccount.owner.toBase58()} for token layout`,\n        );\n    }\n    try {\n        const decoded = TokenDataLayout.decode(Buffer.from(data));\n        return decoded;\n    } catch (error) {\n        console.error('Decoding error:', error);\n        throw error;\n    }\n}\n\n/**\n * parse compressed accounts of an event with token layout\n * @internal\n */\nasync function parseEventWithTokenTlvData(\n    event: PublicTransactionEvent,\n    rpc: Rpc,\n): Promise<EventWithParsedTokenTlvData> {\n    const pubkeyArray = event.pubkeyArray;\n    const infos = await rpc.getStateTreeInfos();\n    const outputHashes = event.outputCompressedAccountHashes;\n    const outputCompressedAccountsWithParsedTokenData: ParsedTokenAccount[] =\n        event.outputCompressedAccounts.map((compressedAccount, i) => {\n            const maybeTree =\n                pubkeyArray[event.outputCompressedAccounts[i].merkleTreeIndex];\n\n            const treeInfo = getStateTreeInfoByPubkey(infos, maybeTree);\n\n            if (\n                !treeInfo.tree.equals(\n                    pubkeyArray[\n                        event.outputCompressedAccounts[i].merkleTreeIndex\n                    ],\n                ) &&\n                (featureFlags.isV2()\n                    ? !treeInfo.queue.equals(\n                          pubkeyArray[\n                              event.outputCompressedAccounts[i].merkleTreeIndex\n                          ],\n                      )\n                    : true)\n            ) {\n                throw new Error('Invalid tree');\n            }\n            const merkleContext: MerkleContext = {\n                treeInfo,\n                hash: bn(outputHashes[i]),\n                leafIndex: event.outputLeafIndices[i],\n                // V2 trees are always proveByIndex in test-rpc.\n                proveByIndex: treeInfo.treeType === TreeType.StateV2,\n            };\n            if (!compressedAccount.compressedAccount.data)\n                throw new Error('No data');\n            const parsedData = parseTokenLayoutWithIdl(\n                compressedAccount.compressedAccount,\n            );\n            if (!parsedData) throw new Error('Invalid token data');\n            const withMerkleContext =\n                createCompressedAccountWithMerkleContextLegacy(\n                    merkleContext,\n                    compressedAccount.compressedAccount.owner,\n                    compressedAccount.compressedAccount.lamports,\n                    compressedAccount.compressedAccount.data,\n                    compressedAccount.compressedAccount.address ?? undefined,\n                );\n            return {\n                compressedAccount: withMerkleContext,\n                parsed: parsedData,\n            };\n        });\n\n    return {\n        inputCompressedAccountHashes: event.inputCompressedAccountHashes,\n        outputCompressedAccounts: outputCompressedAccountsWithParsedTokenData,\n    };\n}\n\n/**\n * Retrieves all compressed token accounts for a given mint and owner.\n *\n * Note: This function is intended for testing purposes only. For production, use rpc.getCompressedTokenAccounts.\n *\n * @param events    Public transaction events\n * @param owner     PublicKey of the token owner\n * @param mint      PublicKey of the token mint\n */\nexport async function getCompressedTokenAccounts(\n    events: PublicTransactionEvent[],\n    rpc: Rpc,\n): Promise<ParsedTokenAccount[]> {\n    const eventsWithParsedTokenTlvData: EventWithParsedTokenTlvData[] =\n        await Promise.all(\n            events.map(event => parseEventWithTokenTlvData(event, rpc)),\n        );\n    /// strip spent compressed accounts if an output compressed account of tx n is\n    /// an input compressed account of tx n+m, it is spent\n    const allOutCompressedAccounts = eventsWithParsedTokenTlvData.flatMap(\n        event => event.outputCompressedAccounts,\n    );\n    const allInCompressedAccountHashes = eventsWithParsedTokenTlvData.flatMap(\n        event => event.inputCompressedAccountHashes,\n    );\n\n    const unspentCompressedAccounts = allOutCompressedAccounts.filter(\n        outputCompressedAccount =>\n            !allInCompressedAccountHashes.some(hash => {\n                return bn(hash).eq(\n                    outputCompressedAccount.compressedAccount.hash,\n                );\n            }),\n    );\n\n    return unspentCompressedAccounts;\n}\n\n/** @internal */\nexport async function getCompressedTokenAccountsByOwnerTest(\n    rpc: Rpc,\n    owner: PublicKey,\n    mint: PublicKey,\n): Promise<WithCursor<ParsedTokenAccount[]>> {\n    const events = await getParsedEvents(rpc);\n    const compressedTokenAccounts = await getCompressedTokenAccounts(\n        events,\n        rpc,\n    );\n    const accounts = compressedTokenAccounts.filter(\n        acc => acc.parsed.owner.equals(owner) && acc.parsed.mint.equals(mint),\n    );\n    return {\n        items: accounts.sort(\n            (a, b) =>\n                a.compressedAccount.leafIndex - b.compressedAccount.leafIndex,\n        ),\n        cursor: null,\n    };\n}\n\nexport async function getCompressedTokenAccountsByDelegateTest(\n    rpc: Rpc,\n    delegate: PublicKey,\n    mint: PublicKey,\n): Promise<WithCursor<ParsedTokenAccount[]>> {\n    const events = await getParsedEvents(rpc);\n\n    const compressedTokenAccounts = await getCompressedTokenAccounts(\n        events,\n        rpc,\n    );\n    return {\n        items: compressedTokenAccounts.filter(\n            acc =>\n                acc.parsed.delegate?.equals(delegate) &&\n                acc.parsed.mint.equals(mint),\n        ),\n        cursor: null,\n    };\n}\n\nexport async function getCompressedTokenAccountByHashTest(\n    rpc: Rpc,\n    hash: BN,\n): Promise<ParsedTokenAccount> {\n    const events = await getParsedEvents(rpc);\n\n    const compressedTokenAccounts = await getCompressedTokenAccounts(\n        events,\n        rpc,\n    );\n\n    const filtered = compressedTokenAccounts.filter(acc =>\n        bn(acc.compressedAccount.hash).eq(hash),\n    );\n    if (filtered.length === 0) {\n        throw new Error('No compressed account found');\n    }\n    return filtered[0];\n}\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch, mask };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = { ...value };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for (const key in coerced) {\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value, ctx) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask,\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","import { PublicKey, MemcmpFilter, DataSlice } from '@solana/web3.js';\nimport {\n    type as pick,\n    number,\n    string,\n    array,\n    literal,\n    union,\n    coerce,\n    instance,\n    create,\n    unknown,\n    any,\n    nullable,\n    Struct,\n    boolean,\n    optional,\n} from 'superstruct';\nimport {\n    BN254,\n    createBN254,\n    ValidityProof,\n    CompressedAccountWithMerkleContext,\n    MerkleContextWithMerkleProof,\n    bn,\n    TokenData,\n    TreeInfo,\n    AddressTreeInfo,\n    CompressedProof,\n} from './state';\nimport BN from 'bn.js';\n\nexport interface LatestNonVotingSignatures {\n    context: { slot: number };\n    value: {\n        items: {\n            signature: string;\n            slot: number;\n            blockTime: number;\n            error: string | null;\n        }[];\n    };\n}\n\nexport interface GetCompressedAccountsByOwnerConfig {\n    filters?: GetCompressedAccountsFilter[];\n    dataSlice?: DataSlice;\n    cursor?: string;\n    limit?: BN;\n}\n\nexport interface CompressedMintTokenHolders {\n    balance: BN;\n    owner: PublicKey;\n}\n\nexport interface LatestNonVotingSignaturesPaginated {\n    context: { slot: number };\n    value: {\n        items: {\n            signature: string;\n            slot: number;\n            blockTime: number;\n        }[];\n        cursor: string | null;\n    };\n}\n\nexport interface SignatureWithMetadata {\n    blockTime: number;\n    signature: string;\n    slot: number;\n}\n\n/**\n * Account hash and associated state tree info.\n */\nexport interface HashWithTreeInfo {\n    /**\n     * Account hash.\n     */\n    hash: BN254;\n    /**\n     * State tree info.\n     */\n    stateTreeInfo: TreeInfo;\n}\n\n/**\n * Address and associated address tree info.\n */\nexport interface AddressWithTreeInfo {\n    /**\n     * Address.\n     */\n    address: BN254;\n    /**\n     * Address tree info.\n     */\n    addressTreeInfo: AddressTreeInfo;\n}\n\nexport interface HashWithTree {\n    hash: BN254;\n    tree: PublicKey;\n    queue: PublicKey;\n}\n\nexport interface AddressWithTree {\n    address: BN254;\n    tree: PublicKey;\n    queue: PublicKey;\n}\n\nexport interface AddressWithTreeInfo {\n    address: BN254;\n    treeInfo: AddressTreeInfo;\n}\n\nexport interface CompressedTransaction {\n    compressionInfo: {\n        closedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[];\n        openedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[];\n        preTokenBalances?: {\n            owner: PublicKey;\n            mint: PublicKey;\n            amount: BN;\n        }[];\n        postTokenBalances?: {\n            owner: PublicKey;\n            mint: PublicKey;\n            amount: BN;\n        }[];\n    };\n    transaction: any;\n}\n\nexport interface HexBatchInputsForProver {\n    'input-compressed-accounts': HexInputsForProver[];\n}\n\nexport interface HexInputsForProver {\n    root: string;\n    pathIndex: number;\n    pathElements: string[];\n    leaf: string;\n}\n\n/**\n * Validity proof with context.\n *\n * You can request proofs via `rpc.getValidityProof` or\n * `rpc.getValidityProofV0`.\n */\nexport type ValidityProofWithContext = {\n    /**\n     * Validity proof.\n     */\n    compressedProof: ValidityProof | null;\n    /**\n     * Roots.\n     */\n    roots: BN[];\n    /**\n     * Root indices.\n     */\n    rootIndices: number[];\n    /**\n     * Leaf indices.\n     */\n    leafIndices: number[];\n    /**\n     * Leaves.\n     */\n    leaves: BN[];\n    /**\n     * Tree infos.\n     */\n    treeInfos: TreeInfo[];\n    /**\n     * Whether to prove by indices.\n     */\n    proveByIndices: boolean[];\n};\n\n/**\n * @deprecated use {@link ValidityProofWithContext} instead\n */\nexport type CompressedProofWithContext = {\n    compressedProof: CompressedProof;\n    roots: BN[];\n    rootIndices: number[];\n    leafIndices: number[];\n    leaves: BN[];\n    merkleTrees: PublicKey[];\n    nullifierQueues: PublicKey[];\n};\n\nexport interface GetCompressedTokenAccountsByOwnerOrDelegateOptions {\n    mint?: PublicKey;\n    cursor?: string;\n    limit?: BN;\n}\nexport type TokenBalance = { balance: BN; mint: PublicKey };\n\n/**\n * **Cursor** is a unique identifier for a page of results by which the next page can be fetched.\n *\n * **Limit** is the maximum number of results to return per page.\n */\nexport interface PaginatedOptions {\n    cursor?: string;\n    limit?: BN;\n}\n\n/**\n * Note, DataSizeFilter is currently not available.\n */\nexport type GetCompressedAccountsFilter = MemcmpFilter; // | DataSizeFilter;\n\nexport type GetCompressedAccountConfig = {\n    encoding?: string;\n};\n\nexport type GetCompressedAccountsConfig = {\n    dataSlice: DataSlice;\n    filters?: GetCompressedAccountsFilter[];\n};\n\nexport interface ParsedTokenAccount {\n    compressedAccount: CompressedAccountWithMerkleContext;\n    parsed: TokenData;\n}\n\nexport type WithContext<T> = {\n    /** context */\n    context: {\n        slot: number;\n    };\n    /** response value */\n    value: T;\n};\n\nexport type WithCursor<T> = {\n    /** context */\n    cursor: string | null;\n    /** response value */\n    items: T;\n};\n\n/**\n * @internal\n */\nconst PublicKeyFromString = coerce(\n    instance(PublicKey),\n    string(),\n    value => new PublicKey(value),\n);\n\n/**\n * @internal\n */\nconst ArrayFromString = coerce(instance(Array<number>), string(), value =>\n    Array.from(new PublicKey(value).toBytes()),\n);\n\n/**\n * @internal\n */\nconst BN254FromString = coerce(instance(BN), string(), value => {\n    return createBN254(value, 'base58');\n});\n\n/**\n *\n * @internal\n * expects bigints to be supplied as strings.\n */\nconst BNFromStringOrNumber = coerce(\n    instance(BN),\n    union([string(), number()]),\n    value => {\n        if (typeof value === 'number') {\n            if (!Number.isSafeInteger(value)) {\n                throw new Error(`Unsafe integer. Precision loss: ${value}`);\n            }\n            return bn(value); // Safe number  BN\n        }\n        return bn(value, 10); // String  BN\n    },\n);\n\n/**\n *\n * @internal\n */\nconst Base64EncodedCompressedAccountDataResult = coerce(\n    string(),\n    string(),\n    value => (value === '' ? null : value),\n);\n/**\n * @internal\n */\nexport function createRpcResult<T, U>(result: Struct<T, U>) {\n    return union([\n        pick({\n            jsonrpc: literal('2.0'),\n            id: string(),\n            result,\n        }),\n        pick({\n            jsonrpc: literal('2.0'),\n            id: string(),\n            error: pick({\n                code: unknown(),\n                message: string(),\n                data: nullable(any()),\n            }),\n        }),\n    ]) as Struct<RpcResult<T>, null>;\n}\n\n/**\n * @internal\n */\nconst UnknownRpcResult = createRpcResult(unknown());\n\n/**\n * @internal\n */\nexport function jsonRpcResult<T, U>(schema: Struct<T, U>) {\n    return coerce(createRpcResult(schema), UnknownRpcResult, value => {\n        if ('error' in value) {\n            return value as RpcResultError;\n        } else {\n            return {\n                ...value,\n                result: create(value.result, schema),\n            } as RpcResultSuccess<T>;\n        }\n    }) as Struct<RpcResult<T>, null>;\n}\n\n// Add this type for the context wrapper\nexport type WithRpcContext<T> = {\n    context: {\n        slot: number;\n    };\n    value: T;\n};\n\n/**\n * @internal\n */\nexport function jsonRpcResultAndContext<T, U>(value: Struct<T, U>) {\n    return jsonRpcResult(\n        pick({\n            context: pick({\n                slot: number(),\n            }),\n            value,\n        }),\n    ) as Struct<RpcResult<WithRpcContext<T>>, null>;\n}\n\nconst NextTreeInfoResultV2 = pick({\n    treeType: number(),\n    tree: PublicKeyFromString,\n    queue: PublicKeyFromString,\n    cpiContext: nullable(PublicKeyFromString),\n});\nconst TreeInfoResultV2 = pick({\n    treeType: number(),\n    tree: PublicKeyFromString,\n    queue: PublicKeyFromString,\n    cpiContext: nullable(PublicKeyFromString),\n    nextTreeContext: optional(nullable(NextTreeInfoResultV2)),\n});\n\n/**\n * @internal\n */\nexport const CompressedAccountResult = pick({\n    address: nullable(ArrayFromString),\n    hash: BN254FromString,\n    data: nullable(\n        pick({\n            data: Base64EncodedCompressedAccountDataResult,\n            dataHash: BN254FromString,\n            discriminator: BNFromStringOrNumber,\n        }),\n    ),\n    lamports: BNFromStringOrNumber,\n    owner: PublicKeyFromString,\n    leafIndex: number(),\n    tree: PublicKeyFromString,\n    seq: nullable(BNFromStringOrNumber),\n    slotCreated: BNFromStringOrNumber,\n});\n\nexport const CompressedAccountResultV2 = pick({\n    address: nullable(ArrayFromString),\n    hash: BN254FromString,\n    data: nullable(\n        pick({\n            data: Base64EncodedCompressedAccountDataResult,\n            dataHash: BN254FromString,\n            discriminator: BNFromStringOrNumber,\n        }),\n    ),\n    lamports: BNFromStringOrNumber,\n    owner: PublicKeyFromString,\n    leafIndex: number(),\n    seq: nullable(BNFromStringOrNumber),\n    slotCreated: BNFromStringOrNumber,\n    merkleContext: TreeInfoResultV2,\n    proveByIndex: boolean(),\n});\n\nexport const TokenDataResult = pick({\n    mint: PublicKeyFromString,\n    owner: PublicKeyFromString,\n    amount: BNFromStringOrNumber,\n    delegate: nullable(PublicKeyFromString),\n    state: string(),\n});\n\n/**\n * @internal\n */\nexport const CompressedTokenAccountResult = pick({\n    tokenData: TokenDataResult,\n    account: CompressedAccountResult,\n});\n\n/**\n * @internal\n */\nexport const CompressedTokenAccountResultV2 = pick({\n    tokenData: TokenDataResult,\n    account: CompressedAccountResultV2,\n});\n\n/**\n * @internal\n */\nexport const MultipleCompressedAccountsResult = pick({\n    items: array(CompressedAccountResult),\n});\n\n/**\n * @internal\n */\nexport const MultipleCompressedAccountsResultV2 = pick({\n    items: array(CompressedAccountResultV2),\n});\n\n/**\n * @internal\n */\nexport const CompressedAccountsByOwnerResult = pick({\n    items: array(CompressedAccountResult),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nexport const CompressedAccountsByOwnerResultV2 = pick({\n    items: array(CompressedAccountResultV2),\n    cursor: nullable(string()),\n});\n/**\n * @internal\n */\nexport const CompressedTokenAccountsByOwnerOrDelegateResult = pick({\n    items: array(CompressedTokenAccountResult),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nexport const CompressedTokenAccountsByOwnerOrDelegateResultV2 = pick({\n    items: array(CompressedTokenAccountResultV2),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nexport const SlotResult = number();\n\n/**\n * @internal\n */\nexport const HealthResult = string();\n\n/**\n * @internal\n */\nexport const LatestNonVotingSignaturesResult = pick({\n    items: array(\n        pick({\n            signature: string(),\n            slot: number(),\n            blockTime: number(),\n            error: nullable(string()),\n        }),\n    ),\n});\n\n/**\n * @internal\n */\nexport const LatestNonVotingSignaturesResultPaginated = pick({\n    items: array(\n        pick({\n            signature: string(),\n            slot: number(),\n            blockTime: number(),\n        }),\n    ),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nexport const MerkleProofResult = pick({\n    hash: BN254FromString,\n    leafIndex: number(),\n    merkleTree: PublicKeyFromString,\n    proof: array(BN254FromString),\n    rootSeq: number(),\n    root: BN254FromString,\n});\n\n/**\n * @internal\n */\nexport const MerkleProofResultV2 = pick({\n    hash: BN254FromString,\n    leafIndex: number(),\n    proof: array(BN254FromString),\n    root: BN254FromString,\n    rootSeq: number(),\n    proveByIndex: boolean(),\n    treeContext: TreeInfoResultV2,\n});\n\n/**\n * @internal\n */\nexport const NewAddressProofResult = pick({\n    address: BN254FromString,\n    nextIndex: number(),\n    merkleTree: PublicKeyFromString,\n    proof: array(BN254FromString), // this is: merkleProofHashedIndexedElementLeaf\n    rootSeq: number(),\n    root: BN254FromString,\n    lowerRangeAddress: BN254FromString, // this is: leafLowerRangeValue.\n    higherRangeAddress: BN254FromString, // this is: leafHigherRangeValue\n    lowElementLeafIndex: number(), // this is: indexHashedIndexedElementLeaf\n});\n\n/**\n * @internal\n */\nconst CompressedProofResult = pick({\n    a: array(number()),\n    b: array(number()),\n    c: array(number()),\n});\n\n/**\n * @internal\n */\nexport const RootIndexResultV2 = pick({\n    rootIndex: number(),\n    proveByIndex: boolean(),\n});\n\n/**\n * @internal\n */\nexport const ValidityProofResult = pick({\n    compressedProof: CompressedProofResult,\n    leafIndices: array(number()),\n    leaves: array(BN254FromString),\n    rootIndices: array(number()),\n    roots: array(BN254FromString),\n    merkleTrees: array(PublicKeyFromString),\n    // TODO: enable nullifierQueues\n    // nullifierQueues: array(PublicKeyFromString),\n});\n\nconst AccountProofInputsResult = pick({\n    hash: BN254FromString,\n    root: BN254FromString,\n    rootIndex: RootIndexResultV2,\n    merkleContext: TreeInfoResultV2,\n    leafIndex: number(),\n});\nconst AddressProofInputsResult = pick({\n    address: BN254FromString,\n    root: BN254FromString,\n    rootIndex: number(),\n    merkleContext: TreeInfoResultV2,\n});\n\nexport const ValidityProofResultV2 = pick({\n    compressedProof: nullable(CompressedProofResult),\n    accounts: array(AccountProofInputsResult),\n    addresses: array(AddressProofInputsResult),\n});\n\n/**\n * @internal\n */\nexport const MultipleMerkleProofsResult = array(MerkleProofResult);\n\n/**\n * @internal\n */\nexport const MultipleMerkleProofsResultV2 = array(MerkleProofResultV2);\n\n/**\n * @internal\n */\nexport const BalanceResult = pick({\n    amount: BNFromStringOrNumber,\n});\n\nexport const NativeBalanceResult = BNFromStringOrNumber;\n\nexport const TokenBalanceResult = pick({\n    balance: BNFromStringOrNumber,\n    mint: PublicKeyFromString,\n});\n\nexport const TokenBalanceListResult = pick({\n    tokenBalances: array(TokenBalanceResult),\n    cursor: nullable(string()),\n});\n\nexport const TokenBalanceListResultV2 = pick({\n    items: array(TokenBalanceResult),\n    cursor: nullable(string()),\n});\n\nexport const CompressedMintTokenHoldersResult = pick({\n    cursor: nullable(string()),\n    items: array(\n        pick({\n            balance: BNFromStringOrNumber,\n            owner: PublicKeyFromString,\n        }),\n    ),\n});\n\nexport const AccountProofResult = pick({\n    hash: array(number()),\n    root: array(number()),\n    proof: array(array(number())),\n});\n\nexport const toUnixTimestamp = (blockTime: string): number => {\n    return new Date(blockTime).getTime();\n};\n\nexport const SignatureListResult = pick({\n    items: array(\n        pick({\n            blockTime: number(),\n            signature: string(),\n            slot: number(),\n        }),\n    ),\n});\n\nexport const SignatureListWithCursorResult = pick({\n    items: array(\n        pick({\n            blockTime: number(),\n            signature: string(),\n            slot: number(),\n        }),\n    ),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nconst ClosedAccountResultV2 = pick({\n    account: CompressedAccountResultV2,\n    txHash: BN254FromString,\n    nullifier: BN254FromString,\n});\n\n/**\n * @internal\n */\n\nexport const CompressedTransactionResult = pick({\n    compressionInfo: pick({\n        closedAccounts: array(\n            pick({\n                account: CompressedAccountResult,\n                optionalTokenData: nullable(TokenDataResult),\n            }),\n        ),\n        openedAccounts: array(\n            pick({\n                account: CompressedAccountResult,\n                optionalTokenData: nullable(TokenDataResult),\n            }),\n        ),\n    }),\n    /// TODO: add transaction struct\n    /// https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/transaction-status/src/lib.rs#L1061\n    transaction: any(),\n});\n\n/**\n * @internal\n */\nexport const CompressedTransactionResultV2 = pick({\n    compressionInfo: pick({\n        closedAccounts: array(\n            pick({\n                account: ClosedAccountResultV2,\n                optionalTokenData: nullable(TokenDataResult),\n            }),\n        ),\n        openedAccounts: array(\n            pick({\n                account: CompressedAccountResultV2,\n                optionalTokenData: nullable(TokenDataResult),\n            }),\n        ),\n    }),\n    /// TODO: add transaction struct\n    /// https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/transaction-status/src/lib.rs#L1061\n    transaction: any(),\n});\n\nexport interface CompressionApiInterface {\n    getCompressedAccount(\n        address?: BN254,\n        hash?: BN254,\n    ): Promise<CompressedAccountWithMerkleContext | null>;\n\n    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN | null>;\n\n    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;\n\n    getCompressedAccountProof(\n        hash: BN254,\n    ): Promise<MerkleContextWithMerkleProof>;\n\n    getMultipleCompressedAccounts(\n        hashes: BN254[],\n    ): Promise<CompressedAccountWithMerkleContext[]>;\n\n    getMultipleCompressedAccountProofs(\n        hashes: BN254[],\n    ): Promise<MerkleContextWithMerkleProof[]>;\n\n    getValidityProof(\n        hashes: BN254[],\n        newAddresses: BN254[],\n    ): Promise<ValidityProofWithContext>;\n\n    getValidityProofV0(\n        hashes: HashWithTree[],\n        newAddresses: AddressWithTree[],\n    ): Promise<ValidityProofWithContext>;\n\n    getValidityProofAndRpcContext(\n        hashes: HashWithTree[],\n        newAddresses: AddressWithTree[],\n    ): Promise<WithContext<ValidityProofWithContext>>;\n\n    getCompressedAccountsByOwner(\n        owner: PublicKey,\n        config?: GetCompressedAccountsByOwnerConfig,\n    ): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;\n\n    getCompressedMintTokenHolders(\n        mint: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;\n\n    getCompressedTokenAccountsByOwner(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>>;\n\n    getCompressedTokenAccountsByDelegate(\n        delegate: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>>;\n\n    getCompressedTokenAccountBalance(hash: BN254): Promise<{ amount: BN }>;\n\n    getCompressedTokenBalancesByOwner(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<TokenBalance[]>>;\n\n    getCompressedTokenBalancesByOwnerV2(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithContext<WithCursor<TokenBalance[]>>>;\n\n    getTransactionWithCompressionInfo(\n        signature: string,\n    ): Promise<CompressedTransaction | null>;\n\n    getCompressionSignaturesForAccount(\n        hash: BN254,\n    ): Promise<SignatureWithMetadata[]>;\n\n    getCompressionSignaturesForAddress(\n        address: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>>;\n\n    getCompressionSignaturesForOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>>;\n\n    getCompressionSignaturesForTokenOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>>;\n\n    getLatestNonVotingSignatures(\n        limit?: number,\n        cursor?: string,\n    ): Promise<LatestNonVotingSignatures>;\n\n    getLatestCompressionSignatures(\n        cursor?: string,\n        limit?: number,\n    ): Promise<LatestNonVotingSignaturesPaginated>;\n\n    getIndexerHealth(): Promise<string>;\n\n    getIndexerSlot(): Promise<number>;\n}\n\n// Public types for consumers\nexport type RpcResultSuccess<T> = {\n    jsonrpc: '2.0';\n    id: string;\n    result: T;\n};\n\nexport type RpcResultError = {\n    jsonrpc: '2.0';\n    id: string;\n    error: {\n        code: unknown;\n        message: string;\n        data?: any;\n    };\n};\n\nexport type RpcResult<T> = RpcResultSuccess<T> | RpcResultError;\n","import {\n    Connection,\n    ConnectionConfig,\n    PublicKey,\n    SolanaJSONRPCError,\n} from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport {\n    BalanceResult,\n    CompressedAccountResult,\n    CompressedAccountsByOwnerResult,\n    CompressedAccountsByOwnerResultV2,\n    ValidityProofWithContext,\n    CompressedTokenAccountsByOwnerOrDelegateResult,\n    CompressedTransaction,\n    CompressedTransactionResult,\n    CompressedTransactionResultV2,\n    CompressionApiInterface,\n    GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    HealthResult,\n    HexInputsForProver,\n    MerkleProofResult,\n    MerkleProofResultV2,\n    MultipleCompressedAccountsResult,\n    MultipleCompressedAccountsResultV2,\n    NativeBalanceResult,\n    ParsedTokenAccount,\n    SignatureListResult,\n    SignatureListWithCursorResult,\n    SignatureWithMetadata,\n    SlotResult,\n    TokenBalanceListResult,\n    jsonRpcResult,\n    jsonRpcResultAndContext,\n    ValidityProofResult,\n    ValidityProofResultV2,\n    NewAddressProofResult,\n    LatestNonVotingSignaturesResult,\n    LatestNonVotingSignatures,\n    LatestNonVotingSignaturesResultPaginated,\n    LatestNonVotingSignaturesPaginated,\n    WithContext,\n    GetCompressedAccountsByOwnerConfig,\n    WithCursor,\n    AddressWithTree,\n    HashWithTree,\n    CompressedMintTokenHoldersResult,\n    CompressedMintTokenHolders,\n    TokenBalance,\n    TokenBalanceListResultV2,\n    PaginatedOptions,\n    CompressedAccountResultV2,\n    CompressedTokenAccountsByOwnerOrDelegateResultV2,\n} from './rpc-interface';\nimport {\n    MerkleContextWithMerkleProof,\n    BN254,\n    bn,\n    CompressedAccountWithMerkleContext,\n    encodeBN254toBase58,\n    createCompressedAccountWithMerkleContextLegacy,\n    createMerkleContextLegacy,\n    TokenData,\n    ValidityProof,\n    TreeType,\n    AddressTreeInfo,\n    CompressedAccount,\n} from './state';\nimport { array, create, nullable } from 'superstruct';\nimport {\n    defaultTestStateTreeAccounts,\n    localTestActiveStateTreeInfos,\n    isLocalTest,\n    defaultStateTreeLookupTables,\n    versionedEndpoint,\n    featureFlags,\n} from './constants';\nimport BN from 'bn.js';\nimport { toCamelCase, toHex } from './utils/conversion';\n\nimport {\n    proofFromJsonStruct,\n    negateAndCompressProof,\n} from './utils/parse-validity-proof';\nimport { LightWasm } from './test-helpers';\nimport {\n    getAllStateTreeInfos,\n    getStateTreeInfoByPubkey,\n    getTreeInfoByPubkey,\n} from './utils/get-state-tree-infos';\nimport { TreeInfo } from './state/types';\nimport { validateNumbersForProof } from './utils';\n\n/** @internal */\nexport function parseAccountData({\n    discriminator,\n    data,\n    dataHash,\n}: {\n    discriminator: BN;\n    data: string;\n    dataHash: BN;\n}) {\n    return {\n        discriminator: discriminator.toArray('le', 8),\n        data: Buffer.from(data, 'base64'),\n        dataHash: dataHash.toArray('le', 32),\n    };\n}\n\n/** @internal */\nasync function getCompressedTokenAccountsByOwnerOrDelegate(\n    rpc: Rpc,\n    ownerOrDelegate: PublicKey,\n    options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    filterByDelegate: boolean = false,\n): Promise<WithCursor<ParsedTokenAccount[]>> {\n    const endpoint = filterByDelegate\n        ? versionedEndpoint('getCompressedTokenAccountsByDelegate')\n        : versionedEndpoint('getCompressedTokenAccountsByOwner');\n    const propertyToCheck = filterByDelegate ? 'delegate' : 'owner';\n\n    const unsafeRes = await rpcRequest(rpc.compressionApiEndpoint, endpoint, {\n        [propertyToCheck]: ownerOrDelegate.toBase58(),\n        mint: options.mint?.toBase58(),\n        limit: options.limit?.toNumber(),\n        cursor: options.cursor,\n    });\n    let res;\n    if (featureFlags.isV2()) {\n        res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(\n                CompressedTokenAccountsByOwnerOrDelegateResultV2,\n            ),\n        );\n    } else {\n        res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(\n                CompressedTokenAccountsByOwnerOrDelegateResult,\n            ),\n        );\n    }\n    if ('error' in res) {\n        throw new SolanaJSONRPCError(\n            res.error,\n            `failed to get info for compressed accounts by ${propertyToCheck} ${ownerOrDelegate.toBase58()}`,\n        );\n    }\n    if (res.result.value === null) {\n        throw new Error('not implemented: NULL result');\n    }\n    const accounts: ParsedTokenAccount[] = [];\n\n    const activeStateTreeInfos = await rpc.getStateTreeInfos();\n\n    res.result.value.items.map(item => {\n        const _account = item.account;\n        const _tokenData = item.tokenData;\n\n        const tree = featureFlags.isV2()\n            ? (_account as any).merkleContext.tree\n            : (_account as any).tree;\n\n        const proveByIndex = featureFlags.isV2()\n            ? (_account as any).proveByIndex\n            : false;\n        const stateTreeInfo = getStateTreeInfoByPubkey(\n            activeStateTreeInfos,\n            tree,\n        );\n\n        const compressedAccount: CompressedAccountWithMerkleContext =\n            createCompressedAccountWithMerkleContextLegacy(\n                createMerkleContextLegacy(\n                    stateTreeInfo,\n                    _account.hash,\n                    _account.leafIndex,\n                    proveByIndex,\n                ),\n                _account.owner,\n                bn(_account.lamports),\n                _account.data ? parseAccountData(_account.data) : undefined,\n                _account.address || undefined,\n            );\n\n        const parsed: TokenData = {\n            mint: _tokenData.mint,\n            owner: _tokenData.owner,\n            amount: _tokenData.amount,\n            delegate: _tokenData.delegate,\n            state: ['uninitialized', 'initialized', 'frozen'].indexOf(\n                _tokenData.state,\n            ),\n            tlv: null,\n        };\n\n        if (\n            parsed[propertyToCheck]?.toBase58() !== ownerOrDelegate.toBase58()\n        ) {\n            throw new Error(\n                `RPC returned token account with ${propertyToCheck} different from requested ${propertyToCheck}`,\n            );\n        }\n\n        accounts.push({\n            compressedAccount,\n            parsed,\n        });\n    });\n    /// TODO: consider custom or different sort. Most recent here.\n    return {\n        items: accounts.sort(\n            (a, b) =>\n                b.compressedAccount.leafIndex - a.compressedAccount.leafIndex,\n        ),\n        cursor: res.result.value.cursor,\n    };\n}\n\n/**\n * Establish a Compression-compatible JSON RPC connection\n *\n * @param endpointOrWeb3JsConnection    endpoint to the solana cluster or\n *                                      Connection object\n * @param compressionApiEndpoint        Endpoint to the compression server\n * @param proverEndpoint                Endpoint to the prover server. defaults\n *                                      to endpoint\n * @param connectionConfig              Optional connection config\n */\nexport function createRpc(\n    endpointOrWeb3JsConnection?: string | Connection,\n    compressionApiEndpoint?: string,\n    proverEndpoint?: string,\n    config?: ConnectionConfig,\n): Rpc {\n    const localEndpoint = 'http://127.0.0.1:8899';\n    const localCompressionApiEndpoint = 'http://127.0.0.1:8784';\n    const localProverEndpoint = 'http://127.0.0.1:3001';\n\n    let endpoint: string;\n\n    if (!endpointOrWeb3JsConnection) {\n        // Local as default\n        endpoint = localEndpoint;\n        compressionApiEndpoint =\n            compressionApiEndpoint || localCompressionApiEndpoint;\n        proverEndpoint = proverEndpoint || localProverEndpoint;\n    } else if (typeof endpointOrWeb3JsConnection === 'string') {\n        endpoint = endpointOrWeb3JsConnection;\n        compressionApiEndpoint = compressionApiEndpoint || endpoint;\n        proverEndpoint = proverEndpoint || endpoint;\n    } else if (endpointOrWeb3JsConnection instanceof Connection) {\n        endpoint = endpointOrWeb3JsConnection.rpcEndpoint;\n        compressionApiEndpoint = compressionApiEndpoint || endpoint;\n        proverEndpoint = proverEndpoint || endpoint;\n    }\n    // 3\n    else {\n        throw new Error('Invalid endpoint or connection type');\n    }\n\n    return new Rpc(endpoint, compressionApiEndpoint, proverEndpoint, config);\n}\n\n/**\n * Helper function to preprocess the response to wrap numbers as strings\n * @param {string} text - The JSON string to preprocess\n * @returns {string} - The preprocessed JSON string with numbers wrapped as strings\n */\nexport function wrapBigNumbersAsStrings(text: string): string {\n    return text.replace(/(\":\\s*)(-?\\d+)(\\s*[},])/g, (match, p1, p2, p3) => {\n        const num = Number(p2);\n        if (\n            !Number.isNaN(num) &&\n            (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER)\n        ) {\n            return `${p1}\"${p2}\"${p3}`;\n        }\n        return match;\n    });\n}\n\n/** @internal */\nexport const rpcRequest = async (\n    rpcEndpoint: string,\n    method: string,\n    params: any = [],\n    convertToCamelCase = true,\n    debug = false,\n): Promise<any> => {\n    const body = JSON.stringify({\n        jsonrpc: '2.0',\n        id: 'test-account',\n        method: method,\n        params: params,\n    });\n\n    if (debug) {\n        const generateCurlSnippet = () => {\n            const escapedBody = body.replace(/\"/g, '\\\\\"');\n            return `curl -X POST ${rpcEndpoint} \\\\\n     -H \"Content-Type: application/json\" \\\\\n     -d \"${escapedBody}\"`;\n        };\n\n        console.log('Debug: Stack trace:');\n        console.log(new Error().stack);\n        console.log('\\nDebug: curl:');\n        console.log(generateCurlSnippet());\n        console.log('\\n');\n    }\n\n    const response = await fetch(rpcEndpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: body,\n    });\n\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const text = await response.text();\n\n    const wrappedJsonString = wrapBigNumbersAsStrings(text);\n\n    if (convertToCamelCase) {\n        return toCamelCase(JSON.parse(wrappedJsonString));\n    }\n\n    return JSON.parse(wrappedJsonString);\n};\n\n/** @internal */\nexport const proverRequest = async (\n    proverEndpoint: string,\n    method: 'inclusion' | 'new-address' | 'combined',\n    params: any = [],\n    log = false,\n    _publicInputHash: BN | undefined = undefined, // Not supported.\n): Promise<ValidityProof> => {\n    let logMsg: string = '';\n\n    if (log) {\n        logMsg = `Proof generation for method:${method}`;\n        console.time(logMsg);\n    }\n\n    let body;\n    if (method === 'inclusion') {\n        body = JSON.stringify({\n            circuitType: 'inclusion',\n            stateTreeHeight: 26,\n            inputCompressedAccounts: params,\n        });\n    } else if (method === 'new-address') {\n        body = JSON.stringify({\n            circuitType: 'non-inclusion',\n            addressTreeHeight: 26,\n            newAddresses: params,\n        });\n    } else if (method === 'combined') {\n        body = JSON.stringify({\n            circuitType: 'combined',\n\n            stateTreeHeight: 26,\n            addressTreeHeight: 26,\n            inputCompressedAccounts: params[0],\n            newAddresses: params[1],\n        });\n    }\n\n    const response = await fetch(`${proverEndpoint}/prove`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: body,\n    });\n\n    if (!response.ok) {\n        throw new Error(`Error fetching proof: ${response.statusText}`);\n    }\n    const data: any = await response.json();\n    const parsed = proofFromJsonStruct(data);\n    const compressedProof = negateAndCompressProof(parsed);\n\n    if (log) console.timeEnd(logMsg);\n\n    return compressedProof;\n};\n\nexport type NonInclusionMerkleProofInputs = {\n    root: BN;\n    value: BN;\n    leaf_lower_range_value: BN;\n    leaf_higher_range_value: BN;\n    nextIndex: BN;\n    merkle_proof_hashed_indexed_element_leaf: BN[];\n    index_hashed_indexed_element_leaf: BN;\n};\n\nexport type MerkleContextWithNewAddressProof = {\n    root: BN;\n    rootIndex: number;\n    value: BN;\n    leafLowerRangeValue: BN;\n    leafHigherRangeValue: BN;\n    nextIndex: BN;\n    merkleProofHashedIndexedElementLeaf: BN[];\n    indexHashedIndexedElementLeaf: BN;\n    treeInfo: AddressTreeInfo;\n};\n\nexport type NonInclusionJsonStruct = {\n    root: string;\n    value: string;\n    pathIndex: number;\n    pathElements: string[];\n    leafLowerRangeValue: string;\n    leafHigherRangeValue: string;\n    nextIndex: number;\n};\n\nexport function convertMerkleProofsWithContextToHex(\n    merkleProofsWithContext: MerkleContextWithMerkleProof[],\n): HexInputsForProver[] {\n    const inputs: HexInputsForProver[] = [];\n\n    for (let i = 0; i < merkleProofsWithContext.length; i++) {\n        const input: HexInputsForProver = {\n            root: toHex(merkleProofsWithContext[i].root),\n            pathIndex: merkleProofsWithContext[i].leafIndex,\n            pathElements: merkleProofsWithContext[i].merkleProof.map(hex =>\n                toHex(hex),\n            ),\n            leaf: toHex(bn(merkleProofsWithContext[i].hash)),\n        };\n        inputs.push(input);\n    }\n\n    return inputs;\n}\n\nexport function convertNonInclusionMerkleProofInputsToHex(\n    nonInclusionMerkleProofInputs: MerkleContextWithNewAddressProof[],\n): NonInclusionJsonStruct[] {\n    const inputs: NonInclusionJsonStruct[] = [];\n    for (let i = 0; i < nonInclusionMerkleProofInputs.length; i++) {\n        const input: NonInclusionJsonStruct = {\n            root: toHex(nonInclusionMerkleProofInputs[i].root),\n            value: toHex(nonInclusionMerkleProofInputs[i].value),\n            pathIndex:\n                nonInclusionMerkleProofInputs[\n                    i\n                ].indexHashedIndexedElementLeaf.toNumber(),\n            pathElements: nonInclusionMerkleProofInputs[\n                i\n            ].merkleProofHashedIndexedElementLeaf.map(hex => toHex(hex)),\n            nextIndex: nonInclusionMerkleProofInputs[i].nextIndex.toNumber(),\n            leafLowerRangeValue: toHex(\n                nonInclusionMerkleProofInputs[i].leafLowerRangeValue,\n            ),\n            leafHigherRangeValue: toHex(\n                nonInclusionMerkleProofInputs[i].leafHigherRangeValue,\n            ),\n        };\n        inputs.push(input);\n    }\n    return inputs;\n}\n\nfunction calculateTwoInputsHashChain(\n    hashesFirst: BN[],\n    hashesSecond: BN[],\n    lightWasm: LightWasm,\n): BN {\n    if (hashesFirst.length !== hashesSecond.length) {\n        throw new Error('Input lengths must match.');\n    }\n    if (hashesFirst.length === 0) {\n        return bn(0);\n    }\n\n    let hashChain = lightWasm.poseidonHashBN([\n        hashesFirst[0].toString(),\n        hashesSecond[0].toString(),\n    ]);\n\n    for (let i = 1; i < hashesFirst.length; i++) {\n        hashChain = lightWasm.poseidonHashBN([\n            hashChain.toString(),\n            hashesFirst[i].toString(),\n            hashesSecond[i].toString(),\n        ]);\n    }\n\n    return hashChain;\n}\n\nexport function getPublicInputHash(\n    accountProofs: MerkleContextWithMerkleProof[],\n    accountHashes: BN254[],\n    newAddressProofs: MerkleContextWithNewAddressProof[],\n    lightWasm: LightWasm,\n): BN {\n    const accountRoots = accountProofs.map(x => x.root);\n    const inclusionHashChain = calculateTwoInputsHashChain(\n        accountRoots,\n        accountHashes,\n        lightWasm,\n    );\n\n    const newAddressHashes = newAddressProofs.map(x => x.value);\n    const newAddressRoots = newAddressProofs.map(x => x.root);\n    const nonInclusionHashChain = calculateTwoInputsHashChain(\n        newAddressRoots,\n        newAddressHashes,\n        lightWasm,\n    );\n\n    if (!nonInclusionHashChain.isZero()) {\n        return nonInclusionHashChain;\n    } else if (!inclusionHashChain.isZero()) {\n        return inclusionHashChain;\n    } else {\n        return calculateTwoInputsHashChain(\n            [inclusionHashChain],\n            [nonInclusionHashChain],\n            lightWasm,\n        );\n    }\n}\n\nexport interface NullifierMetadata {\n    nullifier: BN254;\n    txHash: BN254;\n}\n\n/** @internal */\nfunction buildCompressedAccountWithMaybeTokenDataFromClosedAccountResultV2(\n    closedAccountResultV2: any,\n): {\n    account: CompressedAccountWithMerkleContext;\n    maybeTokenData: TokenData | null;\n    maybeNullifierMetadata: NullifierMetadata | null;\n} {\n    const v1type = {\n        account: closedAccountResultV2.account.account,\n        optionalTokenData: closedAccountResultV2.optionalTokenData,\n    };\n\n    const v2NullifierMetadata = {\n        nullifier: closedAccountResultV2.account.nullifier,\n        txHash: closedAccountResultV2.account.txHash,\n    };\n\n    const x = buildCompressedAccountWithMaybeTokenData(v1type);\n    const y = {\n        account: x.account,\n        maybeTokenData: x.maybeTokenData,\n        maybeNullifierMetadata: v2NullifierMetadata,\n    };\n    return y;\n}\n\n/** @internal */\nfunction buildCompressedAccountWithMaybeTokenData(\n    accountStructWithOptionalTokenData: any,\n): {\n    account: CompressedAccountWithMerkleContext;\n    maybeTokenData: TokenData | null;\n} {\n    const compressedAccountResult = accountStructWithOptionalTokenData.account;\n    const tokenDataResult =\n        accountStructWithOptionalTokenData.optionalTokenData;\n\n    const compressedAccount: CompressedAccountWithMerkleContext =\n        createCompressedAccountWithMerkleContextLegacy(\n            createMerkleContextLegacy(\n                compressedAccountResult.treeInfo,\n                compressedAccountResult.hash.toArray('be', 32),\n                compressedAccountResult.leafIndex,\n                compressedAccountResult.proveByIndex,\n            ),\n            compressedAccountResult.owner,\n            bn(compressedAccountResult.lamports),\n            compressedAccountResult.data\n                ? parseAccountData(compressedAccountResult.data)\n                : undefined,\n            compressedAccountResult.address || undefined,\n        );\n\n    if (tokenDataResult === null) {\n        return { account: compressedAccount, maybeTokenData: null };\n    }\n\n    const parsed: TokenData = {\n        mint: tokenDataResult.mint,\n        owner: tokenDataResult.owner,\n        amount: tokenDataResult.amount,\n        delegate: tokenDataResult.delegate,\n        state: ['uninitialized', 'initialized', 'frozen'].indexOf(\n            tokenDataResult.state,\n        ),\n        tlv: null,\n    };\n\n    return { account: compressedAccount, maybeTokenData: parsed };\n}\n/**\n *\n */\nexport class Rpc extends Connection implements CompressionApiInterface {\n    compressionApiEndpoint: string;\n    proverEndpoint: string;\n    allStateTreeInfos: TreeInfo[] | null = null;\n    lastStateTreeFetchTime: number | null = null;\n    CACHE_TTL = 1000 * 60 * 60; // 1 hour in ms\n    fetchPromise: Promise<TreeInfo[]> | null = null;\n\n    constructor(\n        endpoint: string,\n        compressionApiEndpoint: string,\n        proverEndpoint: string,\n        config?: ConnectionConfig,\n    ) {\n        super(endpoint, config || 'confirmed');\n        this.compressionApiEndpoint = compressionApiEndpoint;\n        this.proverEndpoint = proverEndpoint;\n    }\n    /**\n     * @deprecated Use {@link getStateTreeInfos} instead\n     */\n    async getCachedActiveStateTreeInfo() {}\n    /**\n     * @deprecated Use {@link getStateTreeInfos} instead\n     */\n    async getCachedActiveStateTreeInfos() {}\n\n    /**\n     * Get a list of all state tree infos. If not already cached, fetches from\n     * the cluster.\n     */\n    async getStateTreeInfos(): Promise<TreeInfo[]> {\n        if (isLocalTest(this.rpcEndpoint)) {\n            return localTestActiveStateTreeInfos();\n        }\n\n        // return cached\n        if (this.allStateTreeInfos && this.lastStateTreeFetchTime) {\n            const now = Date.now();\n            if (now - this.lastStateTreeFetchTime <= this.CACHE_TTL) {\n                return this.allStateTreeInfos;\n            }\n        }\n\n        if (this.fetchPromise) {\n            return this.fetchPromise;\n        }\n\n        let info: TreeInfo[] | undefined;\n        try {\n            this.fetchPromise = this.doFetch();\n            info = await this.fetchPromise;\n            this.allStateTreeInfos = info;\n            this.lastStateTreeFetchTime = Date.now();\n            return info;\n        } finally {\n            this.fetchPromise = null;\n        }\n    }\n\n    /**\n     * @internal\n     */\n    async doFetch(): Promise<TreeInfo[]> {\n        const { mainnet, devnet } = defaultStateTreeLookupTables();\n\n        /// Mainnet keys are not available on devnet and vice versa. Chaining\n        /// the requests lets us get the state tree infos from the correct\n        /// network.\n        try {\n            const res = await getAllStateTreeInfos({\n                connection: this,\n                stateTreeLUTPairs: [mainnet[0]],\n            });\n            return res;\n        } catch (mainnetError) {\n            try {\n                const res = await getAllStateTreeInfos({\n                    connection: this,\n                    stateTreeLUTPairs: [devnet[0]],\n                });\n                return res;\n            } catch (devnetError) {\n                throw new Error(\n                    `Failed to fetch state tree infos from both mainnet and devnet. ` +\n                        `Mainnet error: ${mainnetError}. Devnet error: ${devnetError}`,\n                );\n            }\n        }\n    }\n\n    /**\n     * Fetch the compressed account for the specified account address or hash\n     */\n    async getCompressedAccount(\n        address?: BN254,\n        hash?: BN254,\n    ): Promise<CompressedAccountWithMerkleContext | null> {\n        if (!hash && !address) {\n            throw new Error('Either hash or address must be provided');\n        }\n        if (hash && address) {\n            throw new Error('Only one of hash or address must be provided');\n        }\n        const activeStateTreeInfo = await this.getStateTreeInfos();\n\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            versionedEndpoint('getCompressedAccount'),\n            {\n                hash: hash ? encodeBN254toBase58(hash) : undefined,\n                address: address ? encodeBN254toBase58(address) : undefined,\n            },\n        );\n\n        let res;\n        if (featureFlags.isV2()) {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(nullable(CompressedAccountResultV2)),\n            );\n        } else {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(nullable(CompressedAccountResult)),\n            );\n        }\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get info for compressed account ${hash ? hash.toString() : address ? address.toString() : ''}`,\n            );\n        }\n        if (res.result.value === null) {\n            return null;\n        }\n\n        const tree = featureFlags.isV2()\n            ? (res.result.value as any).merkleContext.tree\n            : (res.result.value as any).tree!;\n        const stateTreeInfo = getStateTreeInfoByPubkey(\n            activeStateTreeInfo,\n            tree,\n        );\n        const item = res.result.value;\n\n        return createCompressedAccountWithMerkleContextLegacy(\n            createMerkleContextLegacy(stateTreeInfo, item.hash, item.leafIndex),\n            item.owner,\n            bn(item.lamports),\n            item.data ? parseAccountData(item.data) : undefined,\n            item.address || undefined,\n        );\n    }\n\n    /**\n     * Fetch the compressed balance for the specified account address or hash\n     */\n    async getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN> {\n        if (!hash && !address) {\n            throw new Error('Either hash or address must be provided');\n        }\n        if (hash && address) {\n            throw new Error('Only one of hash or address must be provided');\n        }\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedBalance',\n            {\n                hash: hash ? encodeBN254toBase58(hash) : undefined,\n                address: address ? encodeBN254toBase58(address) : undefined,\n            },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(NativeBalanceResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get balance for compressed account ${hash ? hash.toString() : address ? address.toString() : ''}`,\n            );\n        }\n        if (res.result.value === null) {\n            return bn(0);\n        }\n\n        return bn(res.result.value);\n    }\n\n    /**\n     * Fetch the total compressed balance for the specified owner public key\n     */\n    async getCompressedBalanceByOwner(owner: PublicKey): Promise<BN> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedBalanceByOwner',\n            { owner: owner.toBase58() },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(NativeBalanceResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get balance for compressed account ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            return bn(0);\n        }\n        return bn(res.result.value);\n    }\n\n    /**\n     * Fetch the latest merkle proof for the specified account hash from the\n     * cluster\n     */\n    async getCompressedAccountProof(\n        hash: BN254,\n    ): Promise<MerkleContextWithMerkleProof> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            versionedEndpoint('getCompressedAccountProof'),\n            { hash: encodeBN254toBase58(hash) },\n        );\n\n        let res;\n        if (featureFlags.isV2()) {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(MerkleProofResultV2),\n            );\n        } else {\n            res = create(unsafeRes, jsonRpcResultAndContext(MerkleProofResult));\n        }\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get proof for compressed account ${hash.toString()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get proof for compressed account ${hash.toString()}`,\n            );\n        }\n        const activeStateTreeInfo = await this.getStateTreeInfos();\n        const tree = featureFlags.isV2()\n            ? (res.result.value as any).treeContext.tree\n            : (res.result.value as any).tree!;\n        const treeInfo = getStateTreeInfoByPubkey(activeStateTreeInfo, tree);\n\n        const value: MerkleContextWithMerkleProof = {\n            hash: bn((res.result.value as any).hash.toArray('be', 32)),\n            treeInfo,\n            leafIndex: (res.result.value as any).leafIndex,\n            merkleProof: (res.result.value as any).proof,\n            rootIndex: (res.result.value as any).rootSeq % 2400,\n            root: (res.result.value as any).root,\n            proveByIndex: featureFlags.isV2()\n                ? (res.result.value as any).proveByIndex\n                : false,\n        };\n        return value;\n    }\n\n    /**\n     * Fetch all the account info for multiple compressed accounts specified by\n     * an array of account hashes\n     */\n    async getMultipleCompressedAccounts(\n        hashes: BN254[],\n    ): Promise<CompressedAccountWithMerkleContext[]> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            versionedEndpoint('getMultipleCompressedAccounts'),\n            { hashes: hashes.map(hash => encodeBN254toBase58(hash)) },\n        );\n\n        let res;\n        if (featureFlags.isV2()) {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(MultipleCompressedAccountsResultV2),\n            );\n        } else {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(MultipleCompressedAccountsResult),\n            );\n        }\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get info for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get info for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n        const activeStateTreeInfo = await this.getStateTreeInfos();\n        const accounts: CompressedAccountWithMerkleContext[] = [];\n        // TODO: fix type\n        res.result.value.items.map((item: any) => {\n            const tree = featureFlags.isV2()\n                ? item.merkleContext.tree\n                : item.tree!;\n            const stateTreeInfo = getStateTreeInfoByPubkey(\n                activeStateTreeInfo,\n                tree,\n            );\n            const account = createCompressedAccountWithMerkleContextLegacy(\n                createMerkleContextLegacy(\n                    stateTreeInfo,\n                    bn(item.hash.toArray('be', 32)),\n                    item.leafIndex,\n                ),\n                item.owner,\n                bn(item.lamports),\n                item.data ? parseAccountData(item.data) : undefined,\n                item.address || undefined,\n            );\n            accounts.push(account);\n        });\n\n        return accounts.sort((a, b) => b.leafIndex - a.leafIndex);\n    }\n\n    /**\n     * Fetch the latest merkle proofs for multiple compressed accounts specified\n     * by an array account hashes\n     */\n    async getMultipleCompressedAccountProofs(\n        hashes: BN254[],\n    ): Promise<MerkleContextWithMerkleProof[]> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            versionedEndpoint('getMultipleCompressedAccountProofs'),\n            hashes.map(hash => encodeBN254toBase58(hash)),\n        );\n\n        let res;\n        if (featureFlags.isV2()) {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(array(MerkleProofResultV2)),\n            );\n        } else {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(array(MerkleProofResult)),\n            );\n        }\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get proofs for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get proofs for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n\n        const merkleProofs: MerkleContextWithMerkleProof[] = [];\n\n        const treeInfos = await this.getStateTreeInfos();\n        for (const proof of res.result.value) {\n            const treeInfo = getStateTreeInfoByPubkey(\n                treeInfos,\n                featureFlags.isV2()\n                    ? (proof as any).treeContext.tree\n                    : (proof as any).merkleTree,\n            );\n            const value: MerkleContextWithMerkleProof = {\n                hash: bn(proof.hash.toArray('be', 32)),\n                treeInfo,\n                leafIndex: proof.leafIndex,\n                merkleProof: proof.proof,\n                rootIndex: proof.rootSeq % 2400,\n                root: proof.root,\n                proveByIndex: featureFlags.isV2()\n                    ? (proof as any).proveByIndex\n                    : false,\n            };\n            merkleProofs.push(value);\n        }\n        return merkleProofs;\n    }\n\n    /**\n     * Fetch all the compressed accounts owned by the specified public key.\n     * Owner can be a program or user account\n     */\n    async getCompressedAccountsByOwner(\n        owner: PublicKey,\n        config?: GetCompressedAccountsByOwnerConfig | undefined,\n    ): Promise<WithCursor<CompressedAccountWithMerkleContext[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            versionedEndpoint('getCompressedAccountsByOwner'),\n            {\n                owner: owner.toBase58(),\n                filters: config?.filters || [],\n                dataSlice: config?.dataSlice,\n                cursor: config?.cursor,\n                limit: config?.limit?.toNumber(),\n            },\n        );\n\n        let res;\n        if (featureFlags.isV2()) {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(CompressedAccountsByOwnerResultV2),\n            );\n        } else {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(CompressedAccountsByOwnerResult),\n            );\n        }\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get info for compressed accounts owned by ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            return {\n                items: [],\n                cursor: null,\n            };\n        }\n        const accounts: CompressedAccountWithMerkleContext[] = [];\n        const activeStateTreeInfo = await this.getStateTreeInfos();\n\n        (res.result.value as any).items.map((item: any) => {\n            const stateTreeInfo = getStateTreeInfoByPubkey(\n                activeStateTreeInfo,\n                featureFlags.isV2() ? item.merkleContext.tree : item.tree,\n            );\n            const account = createCompressedAccountWithMerkleContextLegacy(\n                createMerkleContextLegacy(\n                    stateTreeInfo,\n                    bn(item.hash.toArray('be', 32)),\n                    item.leafIndex,\n                    featureFlags.isV2() ? item.proveByIndex : false,\n                ),\n                item.owner,\n                bn(item.lamports),\n                item.data ? parseAccountData(item.data) : undefined,\n                item.address || undefined,\n            );\n\n            accounts.push(account);\n        });\n\n        return {\n            items: accounts.sort((a, b) => b.leafIndex - a.leafIndex),\n            cursor: (res.result.value as any).cursor,\n        };\n    }\n\n    /**\n     * Fetch all the compressed token accounts owned by the specified public\n     * key. Owner can be a program or user account\n     */\n    async getCompressedTokenAccountsByOwner(\n        owner: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        if (!options) options = {};\n\n        return await getCompressedTokenAccountsByOwnerOrDelegate(\n            this,\n            owner,\n            options,\n            false,\n        );\n    }\n\n    /**\n     * Fetch all the compressed accounts delegated to the specified public key.\n     */\n    async getCompressedTokenAccountsByDelegate(\n        delegate: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        if (!options) options = {};\n\n        return await getCompressedTokenAccountsByOwnerOrDelegate(\n            this,\n            delegate,\n            options,\n            true,\n        );\n    }\n\n    /**\n     * Fetch the compressed token balance for the specified account hash\n     */\n    async getCompressedTokenAccountBalance(\n        hash: BN254,\n    ): Promise<{ amount: BN }> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedTokenAccountBalance',\n            { hash: encodeBN254toBase58(hash) },\n        );\n        const res = create(unsafeRes, jsonRpcResultAndContext(BalanceResult));\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get balance for compressed token account ${hash.toString()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get balance for compressed token account ${hash.toString()}`,\n            );\n        }\n\n        return { amount: bn(res.result.value.amount) };\n    }\n\n    /**\n     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2} instead.\n     *\n     * Fetch all the compressed token balances owned by the specified public\n     * key. Can filter by mint. Returns without context.\n     */\n    async getCompressedTokenBalancesByOwner(\n        owner: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<TokenBalance[]>> {\n        if (!options) options = {};\n\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedTokenBalancesByOwner',\n            {\n                owner: owner.toBase58(),\n                mint: options.mint?.toBase58(),\n                limit: options.limit?.toNumber(),\n                cursor: options.cursor,\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(TokenBalanceListResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n\n        const maybeFiltered = options.mint\n            ? res.result.value.tokenBalances.filter(\n                  tokenBalance =>\n                      tokenBalance.mint.toBase58() === options.mint!.toBase58(),\n              )\n            : res.result.value.tokenBalances;\n\n        return {\n            items: maybeFiltered,\n            cursor: res.result.value.cursor,\n        };\n    }\n\n    /**\n     * Fetch the compressed token balances owned by the specified public\n     * key. Paginated. Can filter by mint. Returns with context.\n     */\n    async getCompressedTokenBalancesByOwnerV2(\n        owner: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithContext<WithCursor<TokenBalance[]>>> {\n        if (!options) options = {};\n\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedTokenBalancesByOwnerV2',\n            {\n                owner: owner.toBase58(),\n                mint: options.mint?.toBase58(),\n                limit: options.limit?.toNumber(),\n                cursor: options.cursor,\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(TokenBalanceListResultV2),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n\n        const maybeFiltered = options.mint\n            ? res.result.value.items.filter(\n                  tokenBalance =>\n                      tokenBalance.mint.toBase58() === options.mint!.toBase58(),\n              )\n            : res.result.value.items;\n\n        return {\n            context: res.result.context,\n            value: {\n                items: maybeFiltered,\n                cursor: res.result.value.cursor,\n            },\n        };\n    }\n\n    /**\n     * Returns confirmed compression signatures for transactions involving the specified\n     * account hash forward in time from genesis to the most recent confirmed\n     * block\n     *\n     * @param hash queried account hash\n     */\n    async getCompressionSignaturesForAccount(\n        hash: BN254,\n    ): Promise<SignatureWithMetadata[]> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForAccount',\n            { hash: encodeBN254toBase58(hash) },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListResult),\n        );\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for compressed account ${hash.toString()}`,\n            );\n        }\n        return res.result.value.items;\n    }\n\n    /**\n     * Fetch a confirmed or finalized transaction from the cluster. Return with\n     * CompressionInfo\n     */\n    async getTransactionWithCompressionInfo(\n        signature: string,\n    ): Promise<CompressedTransaction | null> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            versionedEndpoint('getTransactionWithCompressionInfo'),\n            { signature },\n        );\n\n        let res;\n        if (featureFlags.isV2()) {\n            res = create(\n                unsafeRes,\n                jsonRpcResult(CompressedTransactionResultV2),\n            );\n        } else {\n            res = create(unsafeRes, jsonRpcResult(CompressedTransactionResult));\n        }\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n        }\n\n        if (res.result.transaction === null) return null;\n\n        const closedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[] = [];\n\n        const openedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[] = [];\n\n        const activeStateTreeInfo = await this.getStateTreeInfos();\n\n        if (featureFlags.isV2()) {\n            res.result.compressionInfo.closedAccounts.map(item => {\n                closedAccounts.push(\n                    buildCompressedAccountWithMaybeTokenDataFromClosedAccountResultV2(\n                        item,\n                    ),\n                );\n            });\n            res.result.compressionInfo.openedAccounts.map(item => {\n                openedAccounts.push(\n                    buildCompressedAccountWithMaybeTokenData(item),\n                );\n            });\n        } else {\n            res.result.compressionInfo.closedAccounts.map((item: any) => {\n                const stateTreeInfo = getStateTreeInfoByPubkey(\n                    activeStateTreeInfo,\n                    item.account.tree,\n                );\n                const account = createCompressedAccountWithMerkleContextLegacy(\n                    createMerkleContextLegacy(\n                        stateTreeInfo,\n                        bn(item.account.hash.toArray('be', 32)),\n                        item.account.leafIndex,\n                    ),\n                    item.account.owner,\n                    bn(item.account.lamports),\n                    item.account.data\n                        ? parseAccountData(item.account.data)\n                        : undefined,\n                    item.account.address || undefined,\n                );\n                closedAccounts.push({\n                    account,\n                    maybeTokenData: item.optionalTokenData,\n                });\n            });\n\n            res.result.compressionInfo.openedAccounts.map((item: any) => {\n                const stateTreeInfo = getStateTreeInfoByPubkey(\n                    activeStateTreeInfo,\n                    item.account.tree,\n                );\n                const account = createCompressedAccountWithMerkleContextLegacy(\n                    createMerkleContextLegacy(\n                        stateTreeInfo,\n                        bn(item.account.hash.toArray('be', 32)),\n                        item.account.leafIndex,\n                    ),\n                    item.account.owner,\n                    bn(item.account.lamports),\n                    item.account.data\n                        ? parseAccountData(item.account.data)\n                        : undefined,\n                    item.account.address || undefined,\n                );\n                openedAccounts.push({\n                    account,\n                    maybeTokenData: item.optionalTokenData,\n                });\n            });\n        }\n\n        const calculateTokenBalances = (\n            accounts: Array<{\n                account: CompressedAccountWithMerkleContext;\n                maybeTokenData: TokenData | null;\n            }>,\n        ):\n            | Array<{\n                  owner: PublicKey;\n                  mint: PublicKey;\n                  amount: BN;\n              }>\n            | undefined => {\n            const balances = Object.values(\n                accounts.reduce(\n                    (acc, { maybeTokenData }) => {\n                        if (maybeTokenData) {\n                            const { owner, mint, amount } = maybeTokenData;\n                            const key = `${owner.toBase58()}_${mint.toBase58()}`;\n                            if (key in acc) {\n                                acc[key].amount = acc[key].amount.add(amount);\n                            } else {\n                                acc[key] = { owner, mint, amount };\n                            }\n                        }\n                        return acc;\n                    },\n                    {} as {\n                        [key: string]: {\n                            owner: PublicKey;\n                            mint: PublicKey;\n                            amount: BN;\n                        };\n                    },\n                ),\n            );\n            return balances.length > 0 ? balances : undefined;\n        };\n\n        const preTokenBalances = calculateTokenBalances(closedAccounts);\n        const postTokenBalances = calculateTokenBalances(openedAccounts);\n\n        return {\n            compressionInfo: {\n                closedAccounts,\n                openedAccounts,\n                preTokenBalances,\n                postTokenBalances,\n            },\n            transaction: res.result.transaction,\n        };\n    }\n\n    /**\n     * Returns confirmed signatures for transactions involving the specified\n     * address forward in time from genesis to the most recent confirmed block\n     *\n     * @param address queried compressed account address\n     */\n    async getCompressionSignaturesForAddress(\n        address: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForAddress',\n            {\n                address: address.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListWithCursorResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for address ${address.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get signatures for address ${address.toBase58()}`,\n            );\n        }\n\n        return res.result.value;\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified account owner forward in time from genesis to the\n     * most recent confirmed block\n     *\n     * @param owner queried owner public key\n     */\n    async getCompressionSignaturesForOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForOwner',\n            {\n                owner: owner.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListWithCursorResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n\n        return res.result.value;\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified token account owner forward in time from genesis to the most\n     * recent confirmed block\n     */\n    async getCompressionSignaturesForTokenOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForTokenOwner',\n            {\n                owner: owner.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListWithCursorResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n\n        return res.result.value;\n    }\n\n    /**\n     * Fetch the current indexer health status\n     */\n    async getIndexerHealth(): Promise<string> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getIndexerHealth',\n        );\n        const res = create(unsafeRes, jsonRpcResult(HealthResult));\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(res.error, 'failed to get health');\n        }\n        return res.result;\n    }\n\n    /**\n     * Ensure that the Compression Indexer has already indexed the transaction\n     */\n    async confirmTransactionIndexed(slot: number): Promise<boolean> {\n        const timeout = isLocalTest(this.rpcEndpoint) ? 10000 : 20000;\n        const interval = isLocalTest(this.rpcEndpoint) ? 100 : 200;\n        const startTime = Date.now();\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const indexerSlot = await this.getIndexerSlot();\n\n            if (indexerSlot >= slot) {\n                return true;\n            }\n            if (Date.now() - startTime > timeout) {\n                throw new Error(\n                    `Timeout: Indexer slot did not reach the required slot within ${timeout / 1000}s`,\n                );\n            }\n            await new Promise(resolve => setTimeout(resolve, interval));\n        }\n    }\n\n    /**\n     * Fetch the current slot that the node is processing\n     */\n    async getIndexerSlot(): Promise<number> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getIndexerSlot',\n        );\n        const res = create(unsafeRes, jsonRpcResult(SlotResult));\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n        }\n        return res.result;\n    }\n\n    /**\n     * Fetch all the compressed token holders for a given mint. Paginated.\n     */\n    async getCompressedMintTokenHolders(\n        mint: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedMintTokenHolders',\n            {\n                mint: mint.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(CompressedMintTokenHoldersResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                'failed to get mint token holders',\n            );\n        }\n\n        return res.result;\n    }\n    /**\n     * Fetch the latest compression signatures on the cluster. Results are\n     * paginated.\n     */\n    async getLatestCompressionSignatures(\n        cursor?: string,\n        limit?: number,\n    ): Promise<LatestNonVotingSignaturesPaginated> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getLatestCompressionSignatures',\n            { limit, cursor },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(LatestNonVotingSignaturesResultPaginated),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                'failed to get latest non-voting signatures',\n            );\n        }\n        return res.result;\n    }\n\n    /**\n     * Fetch all non-voting signatures\n     */\n    async getLatestNonVotingSignatures(\n        limit?: number,\n        cursor?: string,\n    ): Promise<LatestNonVotingSignatures> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getLatestNonVotingSignatures',\n            { limit, cursor },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(LatestNonVotingSignaturesResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                'failed to get latest non-voting signatures',\n            );\n        }\n        return res.result;\n    }\n\n    /**\n     * Fetch the latest address proofs for new unique addresses specified by an\n     * array of addresses.\n     *\n     * the proof states that said address have not yet been created in\n     * respective address tree.\n     * @param addresses Array of BN254 new addresses\n     * @returns Array of validity proofs for new addresses\n     */\n    async getMultipleNewAddressProofs(addresses: BN254[]) {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getMultipleNewAddressProofs',\n            addresses.map(address => encodeBN254toBase58(address)),\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(array(NewAddressProofResult)),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get proofs for new addresses ${addresses.map(address => encodeBN254toBase58(address)).join(', ')}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get proofs for new addresses ${addresses.map(address => encodeBN254toBase58(address)).join(', ')}`,\n            );\n        }\n\n        /// Creates proof for each address\n        const newAddressProofs: MerkleContextWithNewAddressProof[] = [];\n\n        for (const proof of res.result.value) {\n            const _proof: MerkleContextWithNewAddressProof = {\n                root: proof.root,\n                rootIndex: proof.rootSeq % 2400,\n                value: proof.address,\n                leafLowerRangeValue: proof.lowerRangeAddress,\n                leafHigherRangeValue: proof.higherRangeAddress,\n                nextIndex: bn(proof.nextIndex),\n                merkleProofHashedIndexedElementLeaf: proof.proof,\n                indexHashedIndexedElementLeaf: bn(proof.lowElementLeafIndex),\n                treeInfo: {\n                    tree: proof.merkleTree,\n                    queue: defaultTestStateTreeAccounts().addressQueue,\n                    treeType: TreeType.AddressV1,\n                    nextTreeInfo: null,\n                },\n            };\n            newAddressProofs.push(_proof);\n        }\n        return newAddressProofs;\n    }\n\n    /**\n     * @deprecated use {@link getValidityProofV0} instead.\n     *\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of BN254 hashes.\n     * @param newAddresses  Array of BN254 new addresses.\n     * @returns             validity proof with context\n     */\n    async getValidityProof(\n        hashes: BN254[] = [],\n        newAddresses: BN254[] = [],\n    ): Promise<ValidityProofWithContext> {\n        const accs = await this.getMultipleCompressedAccounts(hashes);\n        const trees = accs.map(acc => acc.treeInfo.tree);\n        const queues = accs.map(acc => acc.treeInfo.queue);\n\n        const defaultAddressTreePublicKey =\n            defaultTestStateTreeAccounts().addressTree;\n        const defaultAddressQueuePublicKey =\n            defaultTestStateTreeAccounts().addressQueue;\n\n        const formattedHashes = hashes.map((item, index) => {\n            return {\n                hash: item,\n                tree: trees[index],\n                queue: queues[index],\n            };\n        });\n\n        const formattedNewAddresses = newAddresses.map(item => {\n            return {\n                address: item,\n                tree: defaultAddressTreePublicKey,\n                queue: defaultAddressQueuePublicKey,\n            };\n        });\n\n        return this.getValidityProofV0(formattedHashes, formattedNewAddresses);\n    }\n\n    /**\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of { hash: BN254, tree: PublicKey, queue: PublicKey }.\n     * @param newAddresses  Array of { address: BN254, tree: PublicKey, queue: PublicKey }.\n     * @returns             validity proof with context\n     */\n    async getValidityProofV0(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<ValidityProofWithContext> {\n        const { value } = await this.getValidityProofAndRpcContext(\n            hashes,\n            newAddresses,\n        );\n        return value;\n    }\n\n    /**\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses. Returns with context slot.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of BN254 hashes.\n     * @param newAddresses  Array of BN254 new addresses. Optionally specify the\n     *                      tree and queue for each address. Default to public\n     *                      state tree/queue.\n     * @returns             validity proof with context\n     */\n    async getValidityProofAndRpcContext(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<WithContext<ValidityProofWithContext>> {\n        validateNumbersForProof(hashes.length, newAddresses.length);\n\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            versionedEndpoint('getValidityProof'),\n            {\n                hashes: hashes.map(({ hash }) => encodeBN254toBase58(hash)),\n                newAddressesWithTrees: newAddresses.map(\n                    ({ address, tree }) => ({\n                        address: encodeBN254toBase58(address),\n                        tree: tree.toBase58(),\n                    }),\n                ),\n            },\n        );\n\n        let res;\n        if (featureFlags.isV2()) {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(ValidityProofResultV2),\n            );\n        } else {\n            res = create(\n                unsafeRes,\n                jsonRpcResultAndContext(ValidityProofResult),\n            );\n        }\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get validity proof for hashes ${hashes.map(h => h.hash.toString()).join(', ')}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get validity proof for hashes ${hashes.map(h => h.hash.toString()).join(', ')}`,\n            );\n        }\n\n        const value = res.result.value as any;\n\n        if (featureFlags.isV2()) {\n            return {\n                value: {\n                    compressedProof: value.compressedProof,\n                    leaves: value.accounts\n                        .map((r: any) => r.hash)\n                        .concat(value.addresses.map((r: any) => r.address)),\n                    roots: value.accounts\n                        .map((r: any) => r.root)\n                        .concat(value.addresses.map((r: any) => r.root)),\n                    rootIndices: value.accounts\n                        .map((r: any) => r.rootIndex.rootIndex)\n                        .concat(value.addresses.map((r: any) => r.rootIndex)),\n                    proveByIndices: value.accounts\n                        .map((r: any) => r.rootIndex.proveByIndex)\n                        .concat(value.addresses.map((r: any) => false)), // addresses.proveByIndex is always false.\n                    treeInfos: value.accounts\n                        .map((r: any) => r.merkleContext)\n                        .concat(\n                            value.addresses.map((r: any) => r.merkleContext),\n                        ),\n                    leafIndices: value.accounts\n                        .map((r: any) => r.leafIndex)\n                        .concat(value.addresses.map((r: any) => 0)),\n                },\n                context: res.result.context,\n            };\n        } else {\n            // Temporary fix for v1 backward compatibility.\n            const allInfos = await this.getStateTreeInfos();\n            const infos = value.merkleTrees.map((r: PublicKey) => {\n                if (r.equals(defaultTestStateTreeAccounts().addressTree)) {\n                    return {\n                        tree: r,\n                        queue: defaultTestStateTreeAccounts().addressQueue,\n                        treeType: TreeType.AddressV1,\n                        nextTreeInfo: null,\n                    };\n                }\n                return getTreeInfoByPubkey(allInfos, r);\n            });\n\n            return {\n                value: {\n                    compressedProof: value.compressedProof,\n                    roots: value.roots,\n                    rootIndices: value.rootIndices.map((r: any) => r),\n                    leafIndices: value.leafIndices,\n                    leaves: value.leaves,\n                    treeInfos: infos,\n                    proveByIndices: value.rootIndices.map(\n                        (r: any) => r.proveByIndex,\n                    ),\n                },\n                context: res.result.context,\n            };\n        }\n    }\n}\n","import { Connection, ConnectionConfig, PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport {\n    getCompressedAccountByHashTest,\n    getCompressedAccountsByOwnerTest,\n    getMultipleCompressedAccountsByHashTest,\n} from './get-compressed-accounts';\nimport {\n    getCompressedTokenAccountByHashTest,\n    getCompressedTokenAccountsByDelegateTest,\n    getCompressedTokenAccountsByOwnerTest,\n} from './get-compressed-token-accounts';\nimport { MerkleTree } from '../merkle-tree/merkle-tree';\nimport { getParsedEvents } from './get-parsed-events';\nimport {\n    defaultTestStateTreeAccounts,\n    localTestActiveStateTreeInfos,\n} from '../../constants';\nimport {\n    AddressWithTree,\n    CompressedMintTokenHolders,\n    CompressedTransaction,\n    GetCompressedAccountsByOwnerConfig,\n    PaginatedOptions,\n    HashWithTree,\n    LatestNonVotingSignatures,\n    LatestNonVotingSignaturesPaginated,\n    SignatureWithMetadata,\n    WithContext,\n    WithCursor,\n} from '../../rpc-interface';\nimport {\n    ValidityProofWithContext,\n    CompressionApiInterface,\n    GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ParsedTokenAccount,\n    TokenBalance,\n} from '../../rpc-interface';\nimport {\n    BN254,\n    CompressedAccountWithMerkleContext,\n    MerkleContextWithMerkleProof,\n    PublicTransactionEvent,\n    TreeType,\n    bn,\n} from '../../state';\nimport { IndexedArray } from '../merkle-tree';\nimport {\n    MerkleContextWithNewAddressProof,\n    convertMerkleProofsWithContextToHex,\n    convertNonInclusionMerkleProofInputsToHex,\n    proverRequest,\n} from '../../rpc';\nimport { TreeInfo } from '../../state/types';\nimport { getStateTreeInfoByPubkey } from '../../utils/get-state-tree-infos';\n\nexport interface TestRpcConfig {\n    /**\n     * Depth of state tree. Defaults to the public default test state tree depth\n     */\n    depth?: number;\n    /**\n     * Log proof generation time\n     */\n    log?: boolean;\n}\n\nexport type ClientSubscriptionId = number;\nexport interface LightWasm {\n    blakeHash(input: string | Uint8Array, hashLength: number): Uint8Array;\n    poseidonHash(input: string[] | BN[]): Uint8Array;\n    poseidonHashString(input: string[] | BN[]): string;\n    poseidonHashBN(input: string[] | BN[]): BN;\n}\n\n/**\n * Returns a mock RPC instance for use in unit tests.\n *\n * @param lightWasm               Wasm hasher instance.\n * @param endpoint                RPC endpoint URL. Defaults to\n *                                'http://127.0.0.1:8899'.\n * @param proverEndpoint          Prover server endpoint URL. Defaults to\n *                                'http://localhost:3001'.\n * @param merkleTreeAddress       Address of the merkle tree to index. Defaults\n *                                to the public default test state tree.\n * @param nullifierQueueAddress   Optional address of the associated nullifier\n *                                queue.\n * @param depth                   Depth of the merkle tree.\n * @param log                     Log proof generation time.\n */\nexport async function getTestRpc(\n    lightWasm: LightWasm,\n    endpoint: string = 'http://127.0.0.1:8899',\n    compressionApiEndpoint: string = 'http://127.0.0.1:8784',\n    proverEndpoint: string = 'http://127.0.0.1:3001',\n    depth?: number,\n    log = false,\n) {\n    return new TestRpc(\n        endpoint,\n        lightWasm,\n        compressionApiEndpoint,\n        proverEndpoint,\n        undefined,\n        {\n            depth: depth || defaultTestStateTreeAccounts().merkleTreeHeight,\n            log,\n        },\n    );\n}\n/**\n * Mock RPC for unit tests that simulates the ZK Compression RPC interface.\n * Parses events and builds merkletree on-demand. It does not persist state.\n * Constraints:\n * - Can only index up to 1000 transactions\n *\n * For advanced testing use `Rpc` class which uses photon:\n * https://github.com/helius-labs/photon\n */\nexport class TestRpc extends Connection implements CompressionApiInterface {\n    compressionApiEndpoint: string;\n    proverEndpoint: string;\n    lightWasm: LightWasm;\n    depth: number;\n    log = false;\n    allStateTreeInfos: TreeInfo[] | null = null;\n    lastStateTreeFetchTime: number | null = null;\n    fetchPromise: Promise<TreeInfo[]> | null = null;\n    CACHE_TTL = 1000 * 60 * 60; // 1 hour\n\n    /**\n     * Establish a Compression-compatible JSON RPC mock-connection\n     *\n     * @param endpoint                  endpoint to the solana cluster (use for\n     *                                  localnet only)\n     * @param hasher                    light wasm hasher instance\n     * @param compressionApiEndpoint    Endpoint to the compression server.\n     * @param proverEndpoint            Endpoint to the prover server. defaults\n     *                                  to endpoint\n     * @param connectionConfig          Optional connection config\n     * @param testRpcConfig             Config for the mock rpc\n     */\n    constructor(\n        endpoint: string,\n        hasher: LightWasm,\n        compressionApiEndpoint: string,\n        proverEndpoint: string,\n        connectionConfig?: ConnectionConfig,\n        testRpcConfig?: TestRpcConfig,\n    ) {\n        super(endpoint, connectionConfig || 'confirmed');\n\n        this.compressionApiEndpoint = compressionApiEndpoint;\n        this.proverEndpoint = proverEndpoint;\n\n        const { depth, log } = testRpcConfig ?? {};\n        const { merkleTreeHeight } = defaultTestStateTreeAccounts();\n\n        this.lightWasm = hasher;\n        this.depth = depth ?? merkleTreeHeight;\n        this.log = log ?? false;\n    }\n\n    /**\n     * @deprecated Use {@link getStateTreeInfos} instead\n     */\n    async getCachedActiveStateTreeInfo() {}\n    /**\n     * @deprecated Use {@link getStateTreeInfos} instead\n     */\n    async getCachedActiveStateTreeInfos() {}\n    /**\n     * Returns local test state trees.\n     */\n    async getStateTreeInfos(): Promise<TreeInfo[]> {\n        return localTestActiveStateTreeInfos();\n    }\n    async doFetch(): Promise<TreeInfo[]> {\n        throw new Error('doFetch not supported in test-rpc');\n    }\n\n    /**\n     * Fetch the compressed account for the specified account hash\n     */\n    async getCompressedAccount(\n        address?: BN254,\n        hash?: BN254,\n    ): Promise<CompressedAccountWithMerkleContext | null> {\n        if (address) {\n            throw new Error('address is not supported in test-rpc');\n        }\n        if (!hash) {\n            throw new Error('hash is required');\n        }\n\n        const account = await getCompressedAccountByHashTest(this, hash);\n        return account ?? null;\n    }\n\n    /**\n     * Fetch the compressed balance for the specified account hash\n     */\n    async getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN> {\n        if (address) {\n            throw new Error('address is not supported in test-rpc');\n        }\n        if (!hash) {\n            throw new Error('hash is required');\n        }\n\n        const account = await getCompressedAccountByHashTest(this, hash);\n        if (!account) {\n            throw new Error('Account not found');\n        }\n        return bn(account.lamports);\n    }\n\n    /**\n     * Fetch the total compressed balance for the specified owner public key\n     */\n    async getCompressedBalanceByOwner(owner: PublicKey): Promise<BN> {\n        const accounts = await this.getCompressedAccountsByOwner(owner);\n        return accounts.items.reduce(\n            (acc, account) => acc.add(account.lamports),\n            bn(0),\n        );\n    }\n\n    /**\n     * Fetch the latest merkle proof for the specified account hash from the\n     * cluster\n     */\n    async getCompressedAccountProof(\n        hash: BN254,\n    ): Promise<MerkleContextWithMerkleProof> {\n        const proofs = await this.getMultipleCompressedAccountProofs([hash]);\n        return proofs[0];\n    }\n\n    /**\n     * Fetch all the account info for multiple compressed accounts specified by\n     * an array of account hashes\n     */\n    async getMultipleCompressedAccounts(\n        hashes: BN254[],\n    ): Promise<CompressedAccountWithMerkleContext[]> {\n        return await getMultipleCompressedAccountsByHashTest(this, hashes);\n    }\n    /**\n     * Ensure that the Compression Indexer has already indexed the transaction\n     */\n    async confirmTransactionIndexed(_slot: number): Promise<boolean> {\n        return true;\n    }\n\n    /**\n     * Fetch the latest merkle proofs for multiple compressed accounts specified\n     * by an array account hashes\n     */\n    async getMultipleCompressedAccountProofs(\n        hashes: BN254[],\n    ): Promise<MerkleContextWithMerkleProof[]> {\n        // Parse events and organize leaves by their respective merkle trees\n        const events: PublicTransactionEvent[] = await getParsedEvents(\n            this,\n        ).then(events => events.reverse());\n        const leavesByTree: Map<\n            string,\n            {\n                leaves: number[][];\n                leafIndices: number[];\n                treeInfo: TreeInfo;\n            }\n        > = new Map();\n\n        const cachedStateTreeInfos = await this.getStateTreeInfos();\n\n        /// Assign leaves to their respective trees\n        for (const event of events) {\n            for (\n                let index = 0;\n                index < event.outputCompressedAccounts.length;\n                index++\n            ) {\n                const hash = event.outputCompressedAccountHashes[index];\n                const treeOrQueue =\n                    event.pubkeyArray[\n                        event.outputCompressedAccounts[index].merkleTreeIndex\n                    ];\n\n                const stateTreeInfo = getStateTreeInfoByPubkey(\n                    cachedStateTreeInfos,\n                    treeOrQueue,\n                );\n\n                if (!leavesByTree.has(stateTreeInfo.tree.toBase58())) {\n                    leavesByTree.set(stateTreeInfo.tree.toBase58(), {\n                        leaves: [],\n                        leafIndices: [],\n                        treeInfo: stateTreeInfo,\n                    });\n                }\n\n                const treeData = leavesByTree.get(\n                    stateTreeInfo.tree.toBase58(),\n                );\n                if (!treeData) {\n                    throw new Error(\n                        `Tree not found: ${stateTreeInfo.tree.toBase58()}`,\n                    );\n                }\n                treeData.leaves.push(hash);\n                treeData.leafIndices.push(event.outputLeafIndices[index]);\n            }\n        }\n\n        const merkleProofsMap: Map<string, MerkleContextWithMerkleProof> =\n            new Map();\n\n        for (const [treeKey, { leaves, treeInfo }] of leavesByTree.entries()) {\n            const tree = new PublicKey(treeKey);\n\n            let merkleTree: MerkleTree | undefined;\n            if (treeInfo.treeType === TreeType.StateV1) {\n                merkleTree = new MerkleTree(\n                    this.depth,\n                    this.lightWasm,\n                    leaves.map(leaf => bn(leaf).toString()),\n                );\n            } else if (treeInfo.treeType === TreeType.StateV2) {\n                /// In V2 State trees, The Merkle tree stays empty until the\n                /// first forester transaction. And since test-rpc is only used\n                /// for non-forested tests, we must return a tree with\n                /// zerovalues.\n                merkleTree = new MerkleTree(32, this.lightWasm, []);\n            } else {\n                throw new Error(\n                    `Invalid tree type: ${treeInfo.treeType} in test-rpc.ts`,\n                );\n            }\n\n            for (let i = 0; i < hashes.length; i++) {\n                const leafIndex = leaves.findIndex(leaf =>\n                    bn(leaf).eq(hashes[i]),\n                );\n\n                /// If leaf is part of current tree, return proof\n                if (leafIndex !== -1) {\n                    if (treeInfo.treeType === TreeType.StateV1) {\n                        const pathElements =\n                            merkleTree.path(leafIndex).pathElements;\n                        const bnPathElements = pathElements.map(value =>\n                            bn(value),\n                        );\n                        const root = bn(merkleTree.root());\n\n                        const merkleProof: MerkleContextWithMerkleProof = {\n                            hash: bn(hashes[i].toArray('be', 32)),\n                            treeInfo,\n                            leafIndex,\n                            merkleProof: bnPathElements,\n                            proveByIndex: false,\n                            rootIndex: leaves.length,\n                            root,\n                        };\n\n                        merkleProofsMap.set(hashes[i].toString(), merkleProof);\n                    } else if (treeInfo.treeType === TreeType.StateV2) {\n                        const pathElements = merkleTree._zeros.slice(0, -1);\n                        const bnPathElements = pathElements.map(value =>\n                            bn(value),\n                        );\n                        const root = bn(merkleTree.root());\n\n                        /// get leafIndex from leavesByTree for the given hash\n                        const leafIndex = leavesByTree\n                            .get(tree.toBase58())!\n                            .leafIndices.findIndex(index =>\n                                hashes[i].eq(\n                                    bn(\n                                        leavesByTree.get(tree.toBase58())!\n                                            .leaves[index],\n                                    ),\n                                ),\n                            );\n\n                        const merkleProof: MerkleContextWithMerkleProof = {\n                            // Hash is 0 for proveByIndex trees in test-rpc.\n                            hash: bn(hashes[i].toArray('be', 32)),\n                            // hash: bn(new Array(32).fill(0)),\n                            treeInfo,\n                            leafIndex,\n                            merkleProof: bnPathElements,\n                            proveByIndex: true,\n                            // Root index is 0 for proveByIndex trees in\n                            // test-rpc.\n                            rootIndex: 0,\n                            root,\n                        };\n\n                        merkleProofsMap.set(hashes[i].toString(), merkleProof);\n                    }\n                }\n            }\n        }\n\n        // Validate proofs\n        merkleProofsMap.forEach((proof, index) => {\n            if (proof.treeInfo.treeType === TreeType.StateV1) {\n                const leafIndex = proof.leafIndex;\n                const computedHash = leavesByTree.get(\n                    proof.treeInfo.tree.toBase58(),\n                )!.leaves[leafIndex];\n                const hashArr = bn(computedHash);\n                if (!hashArr.eq(proof.hash)) {\n                    throw new Error(\n                        `Mismatch at index ${index}: expected ${proof.hash.toString()}, got ${hashArr.toString()}`,\n                    );\n                }\n            }\n        });\n\n        // Ensure all requested hashes belong to the same tree type\n        const uniqueTreeTypes = new Set(\n            hashes.map(hash => {\n                const proof = merkleProofsMap.get(hash.toString());\n                if (!proof) {\n                    throw new Error(\n                        `Proof not found for hash: ${hash.toString()}`,\n                    );\n                }\n                return proof.treeInfo.treeType;\n            }),\n        );\n\n        if (uniqueTreeTypes.size > 1) {\n            throw new Error(\n                'Requested hashes belong to different tree types (V1/V2)',\n            );\n        }\n\n        // Return proofs in the order of requested hashes\n        return hashes.map(hash => {\n            const proof = merkleProofsMap.get(hash.toString());\n            if (!proof) {\n                throw new Error(`No proof found for hash: ${hash.toString()}`);\n            }\n            return proof;\n        });\n    }\n    /**\n     * Fetch all the compressed accounts owned by the specified public key.\n     * Owner can be a program or user account\n     */\n    async getCompressedAccountsByOwner(\n        owner: PublicKey,\n        _config?: GetCompressedAccountsByOwnerConfig,\n    ): Promise<WithCursor<CompressedAccountWithMerkleContext[]>> {\n        const accounts = await getCompressedAccountsByOwnerTest(this, owner);\n        return {\n            items: accounts,\n            cursor: null,\n        };\n    }\n\n    /**\n     * Fetch the latest compression signatures on the cluster. Results are\n     * paginated.\n     */\n    async getLatestCompressionSignatures(\n        _cursor?: string,\n        _limit?: number,\n    ): Promise<LatestNonVotingSignaturesPaginated> {\n        throw new Error(\n            'getLatestNonVotingSignaturesWithContext not supported in test-rpc',\n        );\n    }\n    /**\n     * Fetch the latest non-voting signatures on the cluster. Results are\n     * not paginated.\n     */\n    async getLatestNonVotingSignatures(\n        _limit?: number,\n    ): Promise<LatestNonVotingSignatures> {\n        throw new Error(\n            'getLatestNonVotingSignaturesWithContext not supported in test-rpc',\n        );\n    }\n    /**\n     * Fetch all the compressed token accounts owned by the specified public\n     * key. Owner can be a program or user account\n     */\n    async getCompressedTokenAccountsByOwner(\n        owner: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        return await getCompressedTokenAccountsByOwnerTest(\n            this,\n            owner,\n            options!.mint!,\n        );\n    }\n\n    /**\n     * Fetch all the compressed accounts delegated to the specified public key.\n     */\n    async getCompressedTokenAccountsByDelegate(\n        delegate: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        return await getCompressedTokenAccountsByDelegateTest(\n            this,\n            delegate,\n            options.mint!,\n        );\n    }\n\n    /**\n     * Fetch the compressed token balance for the specified account hash\n     */\n    async getCompressedTokenAccountBalance(\n        hash: BN254,\n    ): Promise<{ amount: BN }> {\n        const account = await getCompressedTokenAccountByHashTest(this, hash);\n        return { amount: bn(account.parsed.amount) };\n    }\n\n    /**\n     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2}.\n     * Fetch all the compressed token balances owned by the specified public\n     * key. Can filter by mint.\n     */\n    async getCompressedTokenBalancesByOwner(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<{ balance: BN; mint: PublicKey }[]>> {\n        const accounts = await getCompressedTokenAccountsByOwnerTest(\n            this,\n            publicKey,\n            options.mint!,\n        );\n        return {\n            items: accounts.items.map(account => ({\n                balance: bn(account.parsed.amount),\n                mint: account.parsed.mint,\n            })),\n            cursor: null,\n        };\n    }\n\n    /**\n     * Fetch all the compressed token balances owned by the specified public\n     * key. Can filter by mint. Uses context.\n     */\n    async getCompressedTokenBalancesByOwnerV2(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithContext<WithCursor<TokenBalance[]>>> {\n        const accounts = await getCompressedTokenAccountsByOwnerTest(\n            this,\n            publicKey,\n            options.mint!,\n        );\n        return {\n            context: { slot: 1 },\n            value: {\n                items: accounts.items.map(account => ({\n                    balance: bn(account.parsed.amount),\n                    mint: account.parsed.mint,\n                })),\n                cursor: null,\n            },\n        };\n    }\n\n    /**\n     * Returns confirmed signatures for transactions involving the specified\n     * account hash forward in time from genesis to the most recent confirmed\n     * block\n     *\n     * @param hash queried account hash\n     */\n    async getCompressionSignaturesForAccount(\n        _hash: BN254,\n    ): Promise<SignatureWithMetadata[]> {\n        throw new Error(\n            'getCompressionSignaturesForAccount not implemented in test-rpc',\n        );\n    }\n\n    /**\n     * Fetch a confirmed or finalized transaction from the cluster. Return with\n     * CompressionInfo\n     */\n    async getTransactionWithCompressionInfo(\n        _signature: string,\n    ): Promise<CompressedTransaction> {\n        throw new Error('getCompressedTransaction not implemented in test-rpc');\n    }\n\n    /**\n     * Returns confirmed signatures for transactions involving the specified\n     * address forward in time from genesis to the most recent confirmed\n     * block\n     *\n     * @param address queried compressed account address\n     */\n    async getCompressionSignaturesForAddress(\n        _address: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        throw new Error('getSignaturesForAddress3 not implemented');\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified account owner forward in time from genesis to the\n     * most recent confirmed block\n     *\n     * @param owner queried owner public key\n     */\n    async getCompressionSignaturesForOwner(\n        _owner: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        throw new Error('getSignaturesForOwner not implemented');\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified token account owner forward in time from genesis to the most\n     * recent confirmed block\n     */\n    async getCompressionSignaturesForTokenOwner(\n        _owner: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        throw new Error('getSignaturesForTokenOwner not implemented');\n    }\n\n    /**\n     * Fetch the current indexer health status\n     */\n    async getIndexerHealth(): Promise<string> {\n        return 'ok';\n    }\n\n    /**\n     * Fetch the current slot that the node is processing\n     */\n    async getIndexerSlot(): Promise<number> {\n        return 1;\n    }\n\n    /**\n     * Fetch the latest address proofs for new unique addresses specified by an\n     * array of addresses.\n     *\n     * the proof states that said address have not yet been created in respective address tree.\n     * @param addresses Array of BN254 new addresses\n     * @returns Array of validity proofs for new addresses\n     */\n    async getMultipleNewAddressProofs(addresses: BN254[]) {\n        /// Build tree\n        const indexedArray = IndexedArray.default();\n        const allAddresses: BN[] = [];\n        indexedArray.init();\n        const hashes: BN[] = [];\n        // TODO(crank): add support for cranked address tree in 'allAddresses'.\n        // The Merkle tree root doesnt actually advance beyond init() unless we\n        // start emptying the address queue.\n        for (let i = 0; i < allAddresses.length; i++) {\n            indexedArray.append(bn(allAddresses[i]));\n        }\n        for (let i = 0; i < indexedArray.elements.length; i++) {\n            const hash = indexedArray.hashElement(this.lightWasm, i);\n            hashes.push(bn(hash!));\n        }\n        const tree = new MerkleTree(\n            this.depth,\n            this.lightWasm,\n            hashes.map(hash => bn(hash).toString()),\n        );\n\n        /// Creates proof for each address\n        const newAddressProofs: MerkleContextWithNewAddressProof[] = [];\n\n        for (let i = 0; i < addresses.length; i++) {\n            const [lowElement] = indexedArray.findLowElement(addresses[i]);\n            if (!lowElement) throw new Error('Address not found');\n\n            const leafIndex = lowElement.index;\n\n            const pathElements: string[] = tree.path(leafIndex).pathElements;\n            const bnPathElements = pathElements.map(value => bn(value));\n\n            const higherRangeValue = indexedArray.get(\n                lowElement.nextIndex,\n            )!.value;\n            const root = bn(tree.root());\n\n            const proof: MerkleContextWithNewAddressProof = {\n                root,\n                rootIndex: 3,\n                value: addresses[i],\n                leafLowerRangeValue: lowElement.value,\n                leafHigherRangeValue: higherRangeValue,\n                nextIndex: bn(lowElement.nextIndex),\n                merkleProofHashedIndexedElementLeaf: bnPathElements,\n                indexHashedIndexedElementLeaf: bn(lowElement.index),\n                treeInfo: {\n                    tree: defaultTestStateTreeAccounts().addressTree,\n                    queue: defaultTestStateTreeAccounts().addressQueue,\n                    treeType: TreeType.AddressV1,\n                    nextTreeInfo: null,\n                },\n            };\n            newAddressProofs.push(proof);\n        }\n        return newAddressProofs;\n    }\n\n    async getCompressedMintTokenHolders(\n        _mint: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>> {\n        throw new Error(\n            'getCompressedMintTokenHolders not implemented in test-rpc',\n        );\n    }\n\n    /**\n     * @deprecated This method is not available for TestRpc. Please use\n     * {@link getValidityProof} instead.\n     */\n    async getValidityProofAndRpcContext(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<WithContext<ValidityProofWithContext>> {\n        if (newAddresses.some(address => !(address instanceof BN))) {\n            throw new Error('AddressWithTree is not supported in test-rpc');\n        }\n        return {\n            value: await this.getValidityProofV0(hashes, newAddresses),\n            context: { slot: 1 },\n        };\n    }\n    /**\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of BN254 hashes.\n     * @param newAddresses  Array of BN254 new addresses.\n     * @returns             validity proof with context\n     */\n    async getValidityProof(\n        hashes: BN254[] = [],\n        newAddresses: BN254[] = [],\n    ): Promise<ValidityProofWithContext> {\n        if (newAddresses.some(address => !(address instanceof BN))) {\n            throw new Error('AddressWithTree is not supported in test-rpc');\n        }\n        let validityProof: ValidityProofWithContext | null;\n\n        const treeInfosUsed: TreeInfo[] = [];\n\n        if (hashes.length === 0 && newAddresses.length === 0) {\n            throw new Error(\n                'Empty input. Provide hashes and/or new addresses.',\n            );\n        } else if (hashes.length > 0 && newAddresses.length === 0) {\n            for (const hash of hashes) {\n                const account = await this.getCompressedAccount(\n                    undefined,\n                    hash,\n                );\n\n                if (account) {\n                    treeInfosUsed.push(account.treeInfo);\n                } else throw new Error('Account not found');\n            }\n            const hasV1Accounts = treeInfosUsed.some(\n                info => info.treeType === TreeType.StateV1,\n            );\n\n            /// inclusion\n            const merkleProofsWithContext =\n                await this.getMultipleCompressedAccountProofs(hashes);\n            if (hasV1Accounts) {\n                const inputs = convertMerkleProofsWithContextToHex(\n                    merkleProofsWithContext,\n                );\n\n                const compressedProof = await proverRequest(\n                    this.proverEndpoint,\n                    'inclusion',\n                    inputs,\n                    this.log,\n                );\n                validityProof = {\n                    compressedProof,\n                    roots: merkleProofsWithContext.map(proof => proof.root),\n                    rootIndices: merkleProofsWithContext.map(\n                        proof => proof.rootIndex,\n                    ),\n                    leafIndices: merkleProofsWithContext.map(\n                        proof => proof.leafIndex,\n                    ),\n                    leaves: merkleProofsWithContext.map(proof =>\n                        bn(proof.hash),\n                    ),\n                    treeInfos: merkleProofsWithContext.map(\n                        proof => proof.treeInfo,\n                    ),\n                    proveByIndices: merkleProofsWithContext.map(\n                        proof => proof.proveByIndex,\n                    ),\n                };\n            } else {\n                validityProof = {\n                    compressedProof: null,\n                    roots: merkleProofsWithContext.map(_proof => bn(0)),\n                    rootIndices: merkleProofsWithContext.map(\n                        proof => proof.rootIndex,\n                    ),\n                    leafIndices: merkleProofsWithContext.map(\n                        proof => proof.leafIndex,\n                    ),\n                    leaves: merkleProofsWithContext.map(proof =>\n                        bn(proof.hash),\n                    ),\n                    treeInfos: merkleProofsWithContext.map(\n                        proof => proof.treeInfo,\n                    ),\n                    proveByIndices: merkleProofsWithContext.map(\n                        proof => proof.proveByIndex,\n                    ),\n                };\n            }\n        } else if (hashes.length === 0 && newAddresses.length > 0) {\n            /// new-address\n            const newAddressProofs: MerkleContextWithNewAddressProof[] =\n                await this.getMultipleNewAddressProofs(newAddresses);\n\n            const inputs =\n                convertNonInclusionMerkleProofInputsToHex(newAddressProofs);\n\n            const compressedProof = await proverRequest(\n                this.proverEndpoint,\n                'new-address',\n                inputs,\n                this.log,\n            );\n\n            validityProof = {\n                compressedProof,\n                roots: newAddressProofs.map(proof => proof.root),\n                rootIndices: newAddressProofs.map(_ => 3),\n                leafIndices: newAddressProofs.map(proof =>\n                    proof.indexHashedIndexedElementLeaf.toNumber(),\n                ),\n                leaves: newAddressProofs.map(proof => bn(proof.value)),\n                treeInfos: newAddressProofs.map(proof => proof.treeInfo),\n                proveByIndices: newAddressProofs.map(_ => false),\n            };\n        } else if (hashes.length > 0 && newAddresses.length > 0) {\n            /// combined\n            const merkleProofsWithContext =\n                await this.getMultipleCompressedAccountProofs(hashes);\n            const newAddressProofs: MerkleContextWithNewAddressProof[] =\n                await this.getMultipleNewAddressProofs(newAddresses);\n\n            const treeInfosUsed = merkleProofsWithContext.map(\n                proof => proof.treeInfo,\n            );\n            const hasV1Accounts = treeInfosUsed.some(\n                info => info.treeType === TreeType.StateV1,\n            );\n\n            const newAddressInputs =\n                convertNonInclusionMerkleProofInputsToHex(newAddressProofs);\n\n            let compressedProof;\n            if (hasV1Accounts) {\n                const inputs = convertMerkleProofsWithContextToHex(\n                    merkleProofsWithContext,\n                );\n\n                compressedProof = await proverRequest(\n                    this.proverEndpoint,\n                    'combined',\n                    [inputs, newAddressInputs],\n                    true,\n                );\n            } else {\n                // Still need to make the prover request for new addresses\n                compressedProof = await proverRequest(\n                    this.proverEndpoint,\n                    'new-address',\n                    newAddressInputs,\n                    true,\n                );\n            }\n\n            validityProof = {\n                compressedProof,\n                roots: merkleProofsWithContext\n                    .map(proof => (!hasV1Accounts ? bn(0) : proof.root)) // TODO: find better solution.\n                    .concat(newAddressProofs.map(proof => proof.root)),\n                rootIndices: merkleProofsWithContext\n                    .map(proof => proof.rootIndex)\n                    // TODO(crank): make dynamic to enable forester support in\n                    // test-rpc.ts. Currently this is a static root because the\n                    // address tree doesn't advance.\n                    .concat(newAddressProofs.map(_ => 3)),\n                leafIndices: merkleProofsWithContext\n                    .map(proof => proof.leafIndex)\n                    .concat(\n                        newAddressProofs.map(proof =>\n                            proof.indexHashedIndexedElementLeaf.toNumber(),\n                        ),\n                    ),\n                leaves: merkleProofsWithContext\n                    .map(proof => bn(proof.hash))\n                    .concat(newAddressProofs.map(proof => bn(proof.value))),\n                treeInfos: merkleProofsWithContext\n                    .map(proof => proof.treeInfo)\n                    .concat(newAddressProofs.map(proof => proof.treeInfo)),\n                proveByIndices: merkleProofsWithContext\n                    .map(proof => proof.proveByIndex)\n                    .concat(newAddressProofs.map(_ => false)),\n            };\n        } else throw new Error('Invalid input');\n\n        return validityProof;\n    }\n\n    async getValidityProofV0(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<ValidityProofWithContext> {\n        /// TODO(swen): add support for custom trees\n        return this.getValidityProof(\n            hashes.map(hash => hash.hash),\n            newAddresses.map(address => address.address),\n        );\n    }\n}\n","import { Connection, Keypair, Signer } from '@solana/web3.js';\nimport { confirmTx } from '../utils/send-and-confirm';\nimport { Rpc } from '../rpc';\nimport BN from 'bn.js';\n\nlet c = 1;\n\nexport const ALICE = getTestKeypair(255);\nexport const BOB = getTestKeypair(254);\nexport const CHARLIE = getTestKeypair(253);\nexport const DAVE = getTestKeypair(252);\n\n/**\n * Deep comparison of two objects. Handles BN comparison correctly.\n *\n * @param ref - The reference object to compare.\n * @param val - The value object to compare.\n * @returns True if the objects are deeply equal, false otherwise.\n */\nexport function deepEqual(ref: any, val: any) {\n    if (typeof ref !== typeof val) {\n        console.log(`Type mismatch: ${typeof ref} !== ${typeof val}`);\n        return false;\n    }\n\n    if (ref instanceof BN && val instanceof BN) {\n        return ref.eq(val);\n    }\n\n    if (typeof ref === 'object' && ref !== null && val !== null) {\n        const refKeys = Object.keys(ref);\n        const valKeys = Object.keys(val);\n\n        if (refKeys.length !== valKeys.length) {\n            console.log(\n                `Key length mismatch: ${refKeys.length} !== ${valKeys.length}`,\n            );\n            return false;\n        }\n\n        for (const key of refKeys) {\n            if (!valKeys.includes(key)) {\n                console.log(`Key ${key} not found in value`);\n                return false;\n            }\n            if (!deepEqual(ref[key], val[key])) {\n                console.log(`Value mismatch at key ${key}`);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    if (ref !== val) {\n        console.log(`Value mismatch: ${ref} !== ${val}`);\n    }\n\n    return ref === val;\n}\n\n/**\n * Create a new account and airdrop lamports to it\n *\n * @param rpc       connection to use\n * @param lamports  amount of lamports to airdrop\n * @param counter   counter to use for generating the keypair.\n *                  If undefined or >255, generates random keypair.\n */\nexport async function newAccountWithLamports(\n    rpc: Rpc,\n    lamports = 1000000000,\n    counter: number | undefined = undefined,\n): Promise<Signer> {\n    /// get random keypair\n    if (counter === undefined || counter > 255) {\n        counter = 256;\n    }\n\n    const account = getTestKeypair(counter);\n    const sig = await rpc.requestAirdrop(account.publicKey, lamports);\n    await confirmTx(rpc, sig);\n    return account;\n}\n\nexport function getConnection(): Connection {\n    const url = 'http://127.0.0.1:8899';\n    const connection = new Connection(url, 'confirmed');\n    return connection;\n}\n\n/**\n * For use in tests.\n * Generate a unique keypair by passing in a counter <255. If no counter\n * is supplied, it uses and increments a global counter.\n * if counter > 255, generates random keypair\n */\nexport function getTestKeypair(\n    counter: number | undefined = undefined,\n): Keypair {\n    if (!counter) {\n        counter = c;\n        c++;\n    }\n    if (counter > 255) {\n        return Keypair.generate();\n    }\n    const seed = new Uint8Array(32);\n    seed[31] = counter; // le\n\n    return Keypair.fromSeed(seed);\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { describe, it, expect } = import.meta.vitest;\n\n    describe('getTestKeypair', () => {\n        it('should generate a keypair with a specific counter', () => {\n            const keypair = getTestKeypair(10);\n            const keypair2 = getTestKeypair(10);\n            expect(keypair).toEqual(keypair2);\n            expect(keypair).toBeInstanceOf(Keypair);\n            expect(keypair.publicKey).toBeDefined();\n            expect(keypair.secretKey).toBeDefined();\n        });\n\n        it('should generate random keypair if counter is greater than 255', () => {\n            const testFn = () => getTestKeypair(256);\n            const kp1 = testFn();\n            const kp2 = testFn();\n            expect(kp1).not.toEqual(kp2);\n        });\n\n        it('should increment the global counter if no counter is provided', () => {\n            const initialKeypair = getTestKeypair();\n            const nextKeypair = getTestKeypair();\n            const nextNextKeypair = getTestKeypair();\n            const nextNextNextKeypair = getTestKeypair(3);\n            expect(initialKeypair).not.toEqual(nextKeypair);\n            expect(nextKeypair).not.toEqual(nextNextKeypair);\n            expect(nextNextKeypair).toEqual(nextNextNextKeypair);\n        });\n    });\n}\n","// TODO: Clean up\nexport enum UtxoErrorCode {\n    NEGATIVE_LAMPORTS = 'NEGATIVE_LAMPORTS',\n    NOT_U64 = 'NOT_U64',\n    BLINDING_EXCEEDS_FIELD_SIZE = 'BLINDING_EXCEEDS_FIELD_SIZE',\n}\n\nexport enum SelectInUtxosErrorCode {\n    FAILED_TO_FIND_UTXO_COMBINATION = 'FAILED_TO_FIND_UTXO_COMBINATION',\n    INVALID_NUMBER_OF_IN_UTXOS = 'INVALID_NUMBER_OF_IN_UTXOS',\n}\n\nexport enum CreateUtxoErrorCode {\n    OWNER_UNDEFINED = 'OWNER_UNDEFINED',\n    INVALID_OUTPUT_UTXO_LENGTH = 'INVALID_OUTPUT_UTXO_LENGTH',\n    UTXO_DATA_UNDEFINED = 'UTXO_DATA_UNDEFINED',\n}\n\nexport enum RpcErrorCode {\n    CONNECTION_UNDEFINED = 'CONNECTION_UNDEFINED',\n    RPC_PUBKEY_UNDEFINED = 'RPC_PUBKEY_UNDEFINED',\n    RPC_METHOD_NOT_IMPLEMENTED = 'RPC_METHOD_NOT_IMPLEMENTED',\n    RPC_INVALID = 'RPC_INVALID',\n}\n\nexport enum LookupTableErrorCode {\n    LOOK_UP_TABLE_UNDEFINED = 'LOOK_UP_TABLE_UNDEFINED',\n    LOOK_UP_TABLE_NOT_INITIALIZED = 'LOOK_UP_TABLE_NOT_INITIALIZED',\n}\n\nexport enum HashErrorCode {\n    NO_POSEIDON_HASHER_PROVIDED = 'NO_POSEIDON_HASHER_PROVIDED',\n}\n\nexport enum ProofErrorCode {\n    INVALID_PROOF = 'INVALID_PROOF',\n    PROOF_INPUT_UNDEFINED = 'PROOF_INPUT_UNDEFINED',\n    PROOF_GENERATION_FAILED = 'PROOF_GENERATION_FAILED',\n}\n\nexport enum MerkleTreeErrorCode {\n    MERKLE_TREE_NOT_INITIALIZED = 'MERKLE_TREE_NOT_INITIALIZED',\n    SOL_MERKLE_TREE_UNDEFINED = 'SOL_MERKLE_TREE_UNDEFINED',\n    MERKLE_TREE_UNDEFINED = 'MERKLE_TREE_UNDEFINED',\n    INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE = 'INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE',\n    MERKLE_TREE_INDEX_UNDEFINED = 'MERKLE_TREE_INDEX_UNDEFINED',\n    MERKLE_TREE_SET_SPACE_UNDEFINED = 'MERKLE_TREE_SET_SPACE_UNDEFINED',\n}\n\nexport enum UtilsErrorCode {\n    ACCOUNT_NAME_UNDEFINED_IN_IDL = 'ACCOUNT_NAME_UNDEFINED_IN_IDL',\n    PROPERTY_UNDEFINED = 'PROPERTY_UNDEFINED',\n    LOOK_UP_TABLE_CREATION_FAILED = 'LOOK_UP_TABLE_CREATION_FAILED',\n    UNSUPPORTED_ARCHITECTURE = 'UNSUPPORTED_ARCHITECTURE',\n    UNSUPPORTED_PLATFORM = 'UNSUPPORTED_PLATFORM',\n    ACCOUNTS_UNDEFINED = 'ACCOUNTS_UNDEFINED',\n    INVALID_NUMBER = 'INVALID_NUMBER',\n}\n\nclass MetaError extends Error {\n    code: string;\n    functionName: string;\n    codeMessage?: string;\n\n    constructor(code: string, functionName: string, codeMessage?: string) {\n        super(`${code}: ${codeMessage}`);\n        this.code = code;\n        this.functionName = functionName;\n        this.codeMessage = codeMessage;\n    }\n}\n\nexport class UtxoError extends MetaError {}\n\nexport class SelectInUtxosError extends MetaError {}\n\nexport class CreateUtxoError extends MetaError {}\n\nexport class RpcError extends MetaError {}\n\nexport class LookupTableError extends MetaError {}\n\nexport class HashError extends MetaError {}\n\nexport class ProofError extends MetaError {}\n\nexport class MerkleTreeError extends MetaError {}\n\nexport class UtilsError extends MetaError {}\n","export type LightSystemProgram = {\n    version: '1.2.0';\n    name: 'light_system_program';\n    constants: [\n        {\n            name: 'SOL_POOL_PDA_SEED';\n            type: 'bytes';\n            value: '[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]';\n        },\n    ];\n    instructions: [\n        {\n            name: 'initCpiContextAccount';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                },\n                {\n                    name: 'cpiContextAccount';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'associatedMerkleTree';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [];\n        },\n        {\n            name: 'invoke';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ];\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['Merkle trees.'];\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ];\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'invokeCpi';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'invokingProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'cpiContextAccount';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'invokeCpiWithReadOnly';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'invokingProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'cpiContextAccount';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'stubIdlBuild';\n            docs: [\n                'This function is a stub to allow Anchor to include the input types in',\n                'the IDL. It should not be included in production builds nor be called in',\n                'practice.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ];\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['Merkle trees.'];\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ];\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs1';\n                    type: {\n                        defined: 'InstructionDataInvoke';\n                    };\n                },\n                {\n                    name: 'inputs2';\n                    type: {\n                        defined: 'InstructionDataInvokeCpi';\n                    };\n                },\n                {\n                    name: 'inputs3';\n                    type: {\n                        defined: 'PublicTransactionEvent';\n                    };\n                },\n            ];\n        },\n    ];\n    accounts: [\n        {\n            name: 'cpiContextAccount';\n            docs: [\n                'Collects instruction data without executing a compressed transaction.',\n                'Signer checks are performed on instruction data.',\n                'Collected instruction data is combined with the instruction data of the executing cpi,',\n                'and executed as a single transaction.',\n                'This enables to use input compressed accounts that are owned by multiple programs,',\n                'with one zero-knowledge proof.',\n            ];\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'feePayer';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'associatedMerkleTree';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'context';\n                        type: {\n                            vec: {\n                                defined: 'InstructionDataInvokeCpi';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n    ];\n    types: [\n        {\n            name: 'InstructionDataInvoke';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext';\n                        type: {\n                            vec: {\n                                defined: 'PackedCompressedAccountWithMerkleContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'newAddressParams';\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked';\n                            };\n                        };\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'NewAddressParamsPacked';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'seed';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                    {\n                        name: 'addressQueueAccountIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'addressMerkleTreeAccountIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'addressMerkleTreeRootIndex';\n                        type: 'u16';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'OutputCompressedAccountWithPackedContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'compressedAccount';\n                        type: {\n                            defined: 'CompressedAccount';\n                        };\n                    },\n                    {\n                        name: 'merkleTreeIndex';\n                        type: 'u8';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedProof';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'a';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                    {\n                        name: 'b';\n                        type: {\n                            array: ['u8', 64];\n                        };\n                    },\n                    {\n                        name: 'c';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'InstructionDataInvokeCpi';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'newAddressParams';\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked';\n                            };\n                        };\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext';\n                        type: {\n                            vec: {\n                                defined: 'PackedCompressedAccountWithMerkleContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                    {\n                        name: 'cpiContext';\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedCpiContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'setContext';\n                        docs: [\n                            'Is set by the program that is invoking the CPI to signal that is should',\n                            'set the cpi context.',\n                        ];\n                        type: 'bool';\n                    },\n                    {\n                        name: 'firstSetContext';\n                        docs: [\n                            'Is set to wipe the cpi context since someone could have set it before',\n                            'with unrelated data.',\n                        ];\n                        type: 'bool';\n                    },\n                    {\n                        name: 'cpiContextAccountIndex';\n                        docs: [\n                            'Index of cpi context account in remaining accounts.',\n                        ];\n                        type: 'u8';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedAccount';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'owner';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'lamports';\n                        type: 'u64';\n                    },\n                    {\n                        name: 'address';\n                        type: {\n                            option: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'data';\n                        type: {\n                            option: {\n                                defined: 'CompressedAccountData';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedAccountData';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'discriminator';\n                        type: {\n                            array: ['u8', 8];\n                        };\n                    },\n                    {\n                        name: 'data';\n                        type: 'bytes';\n                    },\n                    {\n                        name: 'dataHash';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PackedCompressedAccountWithMerkleContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'compressedAccount';\n                        type: {\n                            defined: 'CompressedAccount';\n                        };\n                    },\n                    {\n                        name: 'merkleContext';\n                        type: {\n                            defined: 'PackedMerkleContext';\n                        };\n                    },\n                    {\n                        name: 'rootIndex';\n                        docs: [\n                            'Index of root used in inclusion validity proof.',\n                        ];\n                        type: 'u16';\n                    },\n                    {\n                        name: 'readOnly';\n                        docs: [\n                            'Placeholder to mark accounts read-only unimplemented set to false.',\n                        ];\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PackedMerkleContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'merkleTreePubkeyIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'queuePubkeyIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'leafIndex';\n                        type: 'u32';\n                    },\n                    {\n                        name: 'proveByIndex';\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'MerkleTreeSequenceNumber';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'pubkey';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'seq';\n                        type: 'u64';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PublicTransactionEvent';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'inputCompressedAccountHashes';\n                        type: {\n                            vec: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccountHashes';\n                        type: {\n                            vec: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputLeafIndices';\n                        type: {\n                            vec: 'u32';\n                        };\n                    },\n                    {\n                        name: 'sequenceNumbers';\n                        type: {\n                            vec: {\n                                defined: 'MerkleTreeSequenceNumber';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'pubkeyArray';\n                        type: {\n                            vec: 'publicKey';\n                        };\n                    },\n                    {\n                        name: 'message';\n                        type: {\n                            option: 'bytes';\n                        };\n                    },\n                ];\n            };\n        },\n    ];\n    errors: [\n        {\n            code: 6000;\n            name: 'SumCheckFailed';\n            msg: 'Sum check failed';\n        },\n        {\n            code: 6001;\n            name: 'SignerCheckFailed';\n            msg: 'Signer check failed';\n        },\n        {\n            code: 6002;\n            name: 'CpiSignerCheckFailed';\n            msg: 'Cpi signer check failed';\n        },\n        {\n            code: 6003;\n            name: 'ComputeInputSumFailed';\n            msg: 'Computing input sum failed.';\n        },\n        {\n            code: 6004;\n            name: 'ComputeOutputSumFailed';\n            msg: 'Computing output sum failed.';\n        },\n        {\n            code: 6005;\n            name: 'ComputeRpcSumFailed';\n            msg: 'Computing rpc sum failed.';\n        },\n        {\n            code: 6006;\n            name: 'InvalidAddress';\n            msg: 'InvalidAddress';\n        },\n        {\n            code: 6007;\n            name: 'DeriveAddressError';\n            msg: 'DeriveAddressError';\n        },\n        {\n            code: 6008;\n            name: 'CompressedSolPdaUndefinedForCompressSol';\n            msg: 'CompressedSolPdaUndefinedForCompressSol';\n        },\n        {\n            code: 6009;\n            name: 'DecompressLamportsUndefinedForCompressSol';\n            msg: 'DecompressLamportsUndefinedForCompressSol';\n        },\n        {\n            code: 6010;\n            name: 'CompressedSolPdaUndefinedForDecompressSol';\n            msg: 'CompressedSolPdaUndefinedForDecompressSol';\n        },\n        {\n            code: 6011;\n            name: 'DeCompressLamportsUndefinedForDecompressSol';\n            msg: 'DeCompressLamportsUndefinedForDecompressSol';\n        },\n        {\n            code: 6012;\n            name: 'DecompressRecipientUndefinedForDecompressSol';\n            msg: 'DecompressRecipientUndefinedForDecompressSol';\n        },\n        {\n            code: 6013;\n            name: 'WriteAccessCheckFailed';\n            msg: 'WriteAccessCheckFailed';\n        },\n        {\n            code: 6014;\n            name: 'InvokingProgramNotProvided';\n            msg: 'InvokingProgramNotProvided';\n        },\n        {\n            code: 6015;\n            name: 'InvalidCapacity';\n            msg: 'InvalidCapacity';\n        },\n        {\n            code: 6016;\n            name: 'InvalidMerkleTreeOwner';\n            msg: 'InvalidMerkleTreeOwner';\n        },\n        {\n            code: 6017;\n            name: 'ProofIsNone';\n            msg: 'ProofIsNone';\n        },\n        {\n            code: 6018;\n            name: 'ProofIsSome';\n            msg: 'Proof is some but no input compressed accounts or new addresses provided.';\n        },\n        {\n            code: 6019;\n            name: 'EmptyInputs';\n            msg: 'EmptyInputs';\n        },\n        {\n            code: 6020;\n            name: 'CpiContextAccountUndefined';\n            msg: 'CpiContextAccountUndefined';\n        },\n        {\n            code: 6021;\n            name: 'CpiContextEmpty';\n            msg: 'CpiContextEmpty';\n        },\n        {\n            code: 6022;\n            name: 'CpiContextMissing';\n            msg: 'CpiContextMissing';\n        },\n        {\n            code: 6023;\n            name: 'DecompressionRecipientDefined';\n            msg: 'DecompressionRecipientDefined';\n        },\n        {\n            code: 6024;\n            name: 'SolPoolPdaDefined';\n            msg: 'SolPoolPdaDefined';\n        },\n        {\n            code: 6025;\n            name: 'AppendStateFailed';\n            msg: 'AppendStateFailed';\n        },\n        {\n            code: 6026;\n            name: 'InstructionNotCallable';\n            msg: 'The instruction is not callable';\n        },\n        {\n            code: 6027;\n            name: 'CpiContextFeePayerMismatch';\n            msg: 'CpiContextFeePayerMismatch';\n        },\n        {\n            code: 6028;\n            name: 'CpiContextAssociatedMerkleTreeMismatch';\n            msg: 'CpiContextAssociatedMerkleTreeMismatch';\n        },\n        {\n            code: 6029;\n            name: 'NoInputs';\n            msg: 'NoInputs';\n        },\n        {\n            code: 6030;\n            name: 'InputMerkleTreeIndicesNotInOrder';\n            msg: 'Input merkle tree indices are not in ascending order.';\n        },\n        {\n            code: 6031;\n            name: 'OutputMerkleTreeIndicesNotInOrder';\n            msg: 'Output merkle tree indices are not in ascending order.';\n        },\n        {\n            code: 6032;\n            name: 'OutputMerkleTreeNotUnique';\n        },\n        {\n            code: 6033;\n            name: 'DataFieldUndefined';\n        },\n        {\n            code: 6034;\n            name: 'ReadOnlyAddressAlreadyExists';\n        },\n        {\n            code: 6035;\n            name: 'ReadOnlyAccountDoesNotExist';\n        },\n        {\n            code: 6036;\n            name: 'HashChainInputsLenghtInconsistent';\n        },\n        {\n            code: 6037;\n            name: 'InvalidAddressTreeHeight';\n        },\n        {\n            code: 6038;\n            name: 'InvalidStateTreeHeight';\n        },\n    ];\n};\n\nexport const IDL: LightSystemProgram = {\n    version: '1.2.0',\n    name: 'light_system_program',\n    constants: [\n        {\n            name: 'SOL_POOL_PDA_SEED',\n            type: 'bytes',\n            value: '[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]',\n        },\n    ],\n    instructions: [\n        {\n            name: 'initCpiContextAccount',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                },\n                {\n                    name: 'cpiContextAccount',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'associatedMerkleTree',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [],\n        },\n        {\n            name: 'invoke',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ],\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['Merkle trees.'],\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ],\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'invokeCpi',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'invokingProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'cpiContextAccount',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'invokeCpiWithReadOnly',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'invokingProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'cpiContextAccount',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'stubIdlBuild',\n            docs: [\n                'This function is a stub to allow Anchor to include the input types in',\n                'the IDL. It should not be included in production builds nor be called in',\n                'practice.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ],\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['Merkle trees.'],\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ],\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs1',\n                    type: {\n                        defined: 'InstructionDataInvoke',\n                    },\n                },\n                {\n                    name: 'inputs2',\n                    type: {\n                        defined: 'InstructionDataInvokeCpi',\n                    },\n                },\n                {\n                    name: 'inputs3',\n                    type: {\n                        defined: 'PublicTransactionEvent',\n                    },\n                },\n            ],\n        },\n    ],\n    accounts: [\n        {\n            name: 'cpiContextAccount',\n            docs: [\n                'Collects instruction data without executing a compressed transaction.',\n                'Signer checks are performed on instruction data.',\n                'Collected instruction data is combined with the instruction data of the executing cpi,',\n                'and executed as a single transaction.',\n                'This enables to use input compressed accounts that are owned by multiple programs,',\n                'with one zero-knowledge proof.',\n            ],\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'feePayer',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'associatedMerkleTree',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'context',\n                        type: {\n                            vec: {\n                                defined: 'InstructionDataInvokeCpi',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n    ],\n    types: [\n        {\n            name: 'InstructionDataInvoke',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext',\n                        type: {\n                            vec: {\n                                defined:\n                                    'PackedCompressedAccountWithMerkleContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'newAddressParams',\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked',\n                            },\n                        },\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'NewAddressParamsPacked',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'seed',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                    {\n                        name: 'addressQueueAccountIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'addressMerkleTreeAccountIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'addressMerkleTreeRootIndex',\n                        type: 'u16',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'OutputCompressedAccountWithPackedContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'compressedAccount',\n                        type: {\n                            defined: 'CompressedAccount',\n                        },\n                    },\n                    {\n                        name: 'merkleTreeIndex',\n                        type: 'u8',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedProof',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'a',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                    {\n                        name: 'b',\n                        type: {\n                            array: ['u8', 64],\n                        },\n                    },\n                    {\n                        name: 'c',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'InstructionDataInvokeCpi',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'newAddressParams',\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked',\n                            },\n                        },\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext',\n                        type: {\n                            vec: {\n                                defined:\n                                    'PackedCompressedAccountWithMerkleContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                    {\n                        name: 'cpiContext',\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedCpiContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'setContext',\n                        docs: [\n                            'Is set by the program that is invoking the CPI to signal that is should',\n                            'set the cpi context.',\n                        ],\n                        type: 'bool',\n                    },\n                    {\n                        name: 'firstSetContext',\n                        docs: [\n                            'Is set to wipe the cpi context since someone could have set it before',\n                            'with unrelated data.',\n                        ],\n                        type: 'bool',\n                    },\n                    {\n                        name: 'cpiContextAccountIndex',\n                        docs: [\n                            'Index of cpi context account in remaining accounts.',\n                        ],\n                        type: 'u8',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedAccount',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'owner',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'lamports',\n                        type: 'u64',\n                    },\n                    {\n                        name: 'address',\n                        type: {\n                            option: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'data',\n                        type: {\n                            option: {\n                                defined: 'CompressedAccountData',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedAccountData',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'discriminator',\n                        type: {\n                            array: ['u8', 8],\n                        },\n                    },\n                    {\n                        name: 'data',\n                        type: 'bytes',\n                    },\n                    {\n                        name: 'dataHash',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PackedCompressedAccountWithMerkleContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'compressedAccount',\n                        type: {\n                            defined: 'CompressedAccount',\n                        },\n                    },\n                    {\n                        name: 'merkleContext',\n                        type: {\n                            defined: 'PackedMerkleContext',\n                        },\n                    },\n                    {\n                        name: 'rootIndex',\n                        docs: [\n                            'Index of root used in inclusion validity proof.',\n                        ],\n                        type: 'u16',\n                    },\n                    {\n                        name: 'readOnly',\n                        docs: [\n                            'Placeholder to mark accounts read-only unimplemented set to false.',\n                        ],\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PackedMerkleContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'merkleTreePubkeyIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'queuePubkeyIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'leafIndex',\n                        type: 'u32',\n                    },\n                    {\n                        name: 'proveByIndex',\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'MerkleTreeSequenceNumber',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'pubkey',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'seq',\n                        type: 'u64',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PublicTransactionEvent',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'inputCompressedAccountHashes',\n                        type: {\n                            vec: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccountHashes',\n                        type: {\n                            vec: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputLeafIndices',\n                        type: {\n                            vec: 'u32',\n                        },\n                    },\n                    {\n                        name: 'sequenceNumbers',\n                        type: {\n                            vec: {\n                                defined: 'MerkleTreeSequenceNumber',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'pubkeyArray',\n                        type: {\n                            vec: 'publicKey',\n                        },\n                    },\n                    {\n                        name: 'message',\n                        type: {\n                            option: 'bytes',\n                        },\n                    },\n                ],\n            },\n        },\n    ],\n    errors: [\n        {\n            code: 6000,\n            name: 'SumCheckFailed',\n            msg: 'Sum check failed',\n        },\n        {\n            code: 6001,\n            name: 'SignerCheckFailed',\n            msg: 'Signer check failed',\n        },\n        {\n            code: 6002,\n            name: 'CpiSignerCheckFailed',\n            msg: 'Cpi signer check failed',\n        },\n        {\n            code: 6003,\n            name: 'ComputeInputSumFailed',\n            msg: 'Computing input sum failed.',\n        },\n        {\n            code: 6004,\n            name: 'ComputeOutputSumFailed',\n            msg: 'Computing output sum failed.',\n        },\n        {\n            code: 6005,\n            name: 'ComputeRpcSumFailed',\n            msg: 'Computing rpc sum failed.',\n        },\n        {\n            code: 6006,\n            name: 'InvalidAddress',\n            msg: 'InvalidAddress',\n        },\n        {\n            code: 6007,\n            name: 'DeriveAddressError',\n            msg: 'DeriveAddressError',\n        },\n        {\n            code: 6008,\n            name: 'CompressedSolPdaUndefinedForCompressSol',\n            msg: 'CompressedSolPdaUndefinedForCompressSol',\n        },\n        {\n            code: 6009,\n            name: 'DecompressLamportsUndefinedForCompressSol',\n            msg: 'DecompressLamportsUndefinedForCompressSol',\n        },\n        {\n            code: 6010,\n            name: 'CompressedSolPdaUndefinedForDecompressSol',\n            msg: 'CompressedSolPdaUndefinedForDecompressSol',\n        },\n        {\n            code: 6011,\n            name: 'DeCompressLamportsUndefinedForDecompressSol',\n            msg: 'DeCompressLamportsUndefinedForDecompressSol',\n        },\n        {\n            code: 6012,\n            name: 'DecompressRecipientUndefinedForDecompressSol',\n            msg: 'DecompressRecipientUndefinedForDecompressSol',\n        },\n        {\n            code: 6013,\n            name: 'WriteAccessCheckFailed',\n            msg: 'WriteAccessCheckFailed',\n        },\n        {\n            code: 6014,\n            name: 'InvokingProgramNotProvided',\n            msg: 'InvokingProgramNotProvided',\n        },\n        {\n            code: 6015,\n            name: 'InvalidCapacity',\n            msg: 'InvalidCapacity',\n        },\n        {\n            code: 6016,\n            name: 'InvalidMerkleTreeOwner',\n            msg: 'InvalidMerkleTreeOwner',\n        },\n        {\n            code: 6017,\n            name: 'ProofIsNone',\n            msg: 'ProofIsNone',\n        },\n        {\n            code: 6018,\n            name: 'ProofIsSome',\n            msg: 'Proof is some but no input compressed accounts or new addresses provided.',\n        },\n        {\n            code: 6019,\n            name: 'EmptyInputs',\n            msg: 'EmptyInputs',\n        },\n        {\n            code: 6020,\n            name: 'CpiContextAccountUndefined',\n            msg: 'CpiContextAccountUndefined',\n        },\n        {\n            code: 6021,\n            name: 'CpiContextEmpty',\n            msg: 'CpiContextEmpty',\n        },\n        {\n            code: 6022,\n            name: 'CpiContextMissing',\n            msg: 'CpiContextMissing',\n        },\n        {\n            code: 6023,\n            name: 'DecompressionRecipientDefined',\n            msg: 'DecompressionRecipientDefined',\n        },\n        {\n            code: 6024,\n            name: 'SolPoolPdaDefined',\n            msg: 'SolPoolPdaDefined',\n        },\n        {\n            code: 6025,\n            name: 'AppendStateFailed',\n            msg: 'AppendStateFailed',\n        },\n        {\n            code: 6026,\n            name: 'InstructionNotCallable',\n            msg: 'The instruction is not callable',\n        },\n        {\n            code: 6027,\n            name: 'CpiContextFeePayerMismatch',\n            msg: 'CpiContextFeePayerMismatch',\n        },\n        {\n            code: 6028,\n            name: 'CpiContextAssociatedMerkleTreeMismatch',\n            msg: 'CpiContextAssociatedMerkleTreeMismatch',\n        },\n        {\n            code: 6029,\n            name: 'NoInputs',\n            msg: 'NoInputs',\n        },\n        {\n            code: 6030,\n            name: 'InputMerkleTreeIndicesNotInOrder',\n            msg: 'Input merkle tree indices are not in ascending order.',\n        },\n        {\n            code: 6031,\n            name: 'OutputMerkleTreeIndicesNotInOrder',\n            msg: 'Output merkle tree indices are not in ascending order.',\n        },\n        {\n            code: 6032,\n            name: 'OutputMerkleTreeNotUnique',\n        },\n        {\n            code: 6033,\n            name: 'DataFieldUndefined',\n        },\n        {\n            code: 6034,\n            name: 'ReadOnlyAddressAlreadyExists',\n        },\n        {\n            code: 6035,\n            name: 'ReadOnlyAccountDoesNotExist',\n        },\n        {\n            code: 6036,\n            name: 'HashChainInputsLenghtInconsistent',\n        },\n        {\n            code: 6037,\n            name: 'InvalidAddressTreeHeight',\n        },\n        {\n            code: 6038,\n            name: 'InvalidStateTreeHeight',\n        },\n    ],\n};\n","/**\n * @param targetLamports - Target priority fee in lamports\n * @param computeUnits - Expected compute units used by the transaction\n * @returns microLamports per compute unit (use in\n * {@link https://github.com/solana-foundation/solana-web3.js/blob/maintenance/v1.x/src/programs/compute-budget.ts#L218})\n */\nexport function calculateComputeUnitPrice(\n    targetLamports: number,\n    computeUnits: number,\n): number {\n    return Math.ceil((targetLamports * 1_000_000) / computeUnits);\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { LightSystemProgram } from '../programs';\nimport { Rpc } from '../rpc';\nimport {\n    buildAndSignTx,\n    selectStateTreeInfo,\n    sendAndConfirmTx,\n} from '../utils';\nimport BN from 'bn.js';\nimport { TreeInfo } from '../state';\n\n/**\n * Compress lamports to a solana address\n *\n * @param rpc                   RPC to use\n * @param payer                 Payer of the transaction and initialization fees\n * @param lamports              Amount of lamports to compress\n * @param toAddress             Address of the recipient compressed account\n * @param outputStateTreeInfo   Optional output state tree. If not provided,\n *                              fetches a random active state tree.\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Transaction signature\n */\nexport async function compress(\n    rpc: Rpc,\n    payer: Signer,\n    lamports: number | BN,\n    toAddress: PublicKey,\n    outputStateTreeInfo?: TreeInfo,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    if (!outputStateTreeInfo) {\n        const stateTreeInfo = await rpc.getStateTreeInfos();\n        outputStateTreeInfo = selectStateTreeInfo(stateTreeInfo);\n    }\n\n    const ix = await LightSystemProgram.compress({\n        payer: payer.publicKey,\n        toAddress,\n        lamports,\n        outputStateTreeInfo,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    LightSystemProgram,\n    selectMinCompressedSolAccountsForTransfer,\n} from '../programs';\nimport { Rpc } from '../rpc';\nimport {\n    NewAddressParams,\n    buildAndSignTx,\n    deriveAddress,\n    deriveAddressSeed,\n    selectStateTreeInfo,\n    sendAndConfirmTx,\n} from '../utils';\nimport { getDefaultAddressTreeInfo } from '../constants';\nimport { AddressTreeInfo, bn, TreeInfo } from '../state';\nimport BN from 'bn.js';\n\n/**\n * Create compressed account with address\n *\n * @param rpc                   RPC to use\n * @param payer                 Payer of the transaction and initialization fees\n * @param seeds                 Seeds to derive the new account address\n * @param programId             Owner of the new account\n * @param addressTreeInfo       Optional address tree info. Defaults to a current\n *                              shared address tree.\n * @param outputStateTreeInfo   Optional output state tree. Defaults to fetching\n *                              a current shared state tree.\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Transaction signature\n */\nexport async function createAccount(\n    rpc: Rpc,\n    payer: Signer,\n    seeds: Uint8Array[],\n    programId: PublicKey,\n    addressTreeInfo?: AddressTreeInfo,\n    outputStateTreeInfo?: TreeInfo,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const { tree, queue } = addressTreeInfo ?? getDefaultAddressTreeInfo();\n\n    const seed = deriveAddressSeed(seeds, programId);\n    const address = deriveAddress(seed, tree);\n\n    if (!outputStateTreeInfo) {\n        const stateTreeInfo = await rpc.getStateTreeInfos();\n        outputStateTreeInfo = selectStateTreeInfo(stateTreeInfo);\n    }\n\n    const proof = await rpc.getValidityProofV0(undefined, [\n        {\n            address: bn(address.toBytes()),\n            tree,\n            queue,\n        },\n    ]);\n\n    const params: NewAddressParams = {\n        seed: seed,\n        addressMerkleTreeRootIndex: proof.rootIndices[0],\n        addressMerkleTreePubkey: proof.treeInfos[0].tree,\n        addressQueuePubkey: proof.treeInfos[0].queue,\n    };\n\n    const ix = await LightSystemProgram.createAccount({\n        payer: payer.publicKey,\n        newAddressParams: params,\n        newAddress: Array.from(address.toBytes()),\n        recentValidityProof: proof.compressedProof,\n        programId,\n        outputStateTreeInfo,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n\n/**\n * Create compressed account with address and lamports\n *\n * @param rpc                   RPC to use\n * @param payer                 Payer of the transaction and initialization fees\n * @param seeds                 Seeds to derive the new account address\n * @param lamports              Number of compressed lamports to initialize the\n *                              account with\n * @param programId             Owner of the new account\n * @param addressTreeInfo       Optional address tree info. Defaults to a\n *                              current shared address tree.\n * @param outputStateTreeInfo   Optional output state tree. Defaults to a\n *                              current shared state tree.\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Transaction signature\n */\nexport async function createAccountWithLamports(\n    rpc: Rpc,\n    payer: Signer,\n    seeds: Uint8Array[],\n    lamports: number | BN,\n    programId: PublicKey,\n    addressTreeInfo?: AddressTreeInfo,\n    outputStateTreeInfo?: TreeInfo,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    lamports = bn(lamports);\n\n    const compressedAccounts = await rpc.getCompressedAccountsByOwner(\n        payer.publicKey,\n    );\n\n    const [inputAccounts] = selectMinCompressedSolAccountsForTransfer(\n        compressedAccounts.items,\n        lamports,\n    );\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    const { tree } = addressTreeInfo ?? getDefaultAddressTreeInfo();\n\n    const seed = deriveAddressSeed(seeds, programId);\n    const address = deriveAddress(seed, tree);\n\n    const proof = await rpc.getValidityProof(\n        inputAccounts.map(account => account.hash),\n        [bn(address.toBytes())],\n    );\n\n    const params: NewAddressParams = {\n        seed: seed,\n        addressMerkleTreeRootIndex:\n            proof.rootIndices[proof.rootIndices.length - 1],\n        addressMerkleTreePubkey:\n            proof.treeInfos[proof.treeInfos.length - 1].tree,\n        addressQueuePubkey: proof.treeInfos[proof.treeInfos.length - 1].queue,\n    };\n\n    const ix = await LightSystemProgram.createAccount({\n        payer: payer.publicKey,\n        newAddressParams: params,\n        newAddress: Array.from(address.toBytes()),\n        recentValidityProof: proof.compressedProof,\n        inputCompressedAccounts: inputAccounts,\n        inputStateRootIndices: proof.rootIndices,\n        outputStateTreeInfo,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n","import {\n    PublicKey,\n    Keypair,\n    Connection,\n    AddressLookupTableProgram,\n    Signer,\n} from '@solana/web3.js';\nimport { buildAndSignTx, sendAndConfirmTx } from './send-and-confirm';\nimport { dedupeSigner } from './dedupe-signer';\nimport { Rpc } from '../rpc';\n\n/**\n * Create two lookup tables storing all public state tree and queue addresses\n * returns lookup table addresses and txId\n *\n * @internal\n * @param connection    Connection to the Solana network\n * @param payer         Keypair of the payer\n * @param authority     Keypair of the authority\n * @param recentSlot    Slot of the recent block\n */\nexport async function createStateTreeLookupTable({\n    connection,\n    payer,\n    authority,\n    recentSlot,\n}: {\n    connection: Connection;\n    payer: Keypair;\n    authority: Keypair;\n    recentSlot: number;\n}): Promise<{ address: PublicKey; txId: string }> {\n    const [createInstruction1, lookupTableAddress1] =\n        AddressLookupTableProgram.createLookupTable({\n            payer: payer.publicKey,\n            authority: authority.publicKey,\n            recentSlot,\n        });\n\n    const blockhash = await connection.getLatestBlockhash();\n\n    const tx = buildAndSignTx(\n        [createInstruction1],\n        payer,\n        blockhash.blockhash,\n        dedupeSigner(payer as Signer, [authority]),\n    );\n\n    const txId = await sendAndConfirmTx(connection as Rpc, tx);\n\n    return {\n        address: lookupTableAddress1,\n        txId,\n    };\n}\n\n/**\n * Extend state tree lookup table with new state tree and queue addresses\n *\n * @internal\n * @param connection                Connection to the Solana network\n * @param tableAddress              Address of the lookup table to extend\n * @param newStateTreeAddresses     Addresses of the new state trees to add\n * @param newQueueAddresses         Addresses of the new queues to add\n * @param newCpiContextAddresses    Addresses of the new cpi contexts to add\n * @param payer                     Keypair of the payer\n * @param authority                 Keypair of the authority\n */\nexport async function extendStateTreeLookupTable({\n    connection,\n    tableAddress,\n    newStateTreeAddresses,\n    newQueueAddresses,\n    newCpiContextAddresses,\n    payer,\n    authority,\n}: {\n    connection: Connection;\n    tableAddress: PublicKey;\n    newStateTreeAddresses: PublicKey[];\n    newQueueAddresses: PublicKey[];\n    newCpiContextAddresses: PublicKey[];\n    payer: Keypair;\n    authority: Keypair;\n}): Promise<{ tableAddress: PublicKey; txId: string }> {\n    const lutState = await connection.getAddressLookupTable(tableAddress);\n    if (!lutState.value) {\n        throw new Error('Lookup table not found');\n    }\n    if (lutState.value.state.addresses.length % 3 !== 0) {\n        throw new Error('Lookup table must have a multiple of 3 addresses');\n    }\n    if (\n        newStateTreeAddresses.length !== newQueueAddresses.length ||\n        newStateTreeAddresses.length !== newCpiContextAddresses.length\n    ) {\n        throw new Error(\n            'Same number of newStateTreeAddresses, newQueueAddresses, and newCpiContextAddresses required',\n        );\n    }\n\n    const instructions = AddressLookupTableProgram.extendLookupTable({\n        payer: payer.publicKey,\n        authority: authority.publicKey,\n        lookupTable: tableAddress,\n        addresses: newStateTreeAddresses.flatMap((addr, index) => [\n            addr,\n            newQueueAddresses[index],\n            newCpiContextAddresses[index],\n        ]),\n    });\n\n    const blockhash = await connection.getLatestBlockhash();\n\n    const tx = buildAndSignTx(\n        [instructions],\n        payer,\n        blockhash.blockhash,\n        dedupeSigner(payer as Signer, [authority]),\n    );\n\n    const txId = await sendAndConfirmTx(connection as Rpc, tx);\n\n    return {\n        tableAddress,\n        txId,\n    };\n}\n\n/**\n * Adds state tree address to lookup table. Acts as nullifier lookup for rolled\n * over state trees.\n *\n * @internal\n * @param connection                    Connection to the Solana network\n * @param stateTreeAddress              Address of the state tree to nullify\n * @param nullifyLookupTableAddress     Address of the nullifier lookup table to\n *                                      store address in\n * @param stateTreeLookupTableAddress   lookup table storing all state tree\n *                                      addresses\n * @param payer                         Keypair of the payer\n * @param authority                     Keypair of the authority\n */\nexport async function nullifyLookupTable({\n    connection,\n    fullStateTreeAddress,\n    nullifyLookupTableAddress,\n    stateTreeLookupTableAddress,\n    payer,\n    authority,\n}: {\n    connection: Connection;\n    fullStateTreeAddress: PublicKey;\n    nullifyLookupTableAddress: PublicKey;\n    stateTreeLookupTableAddress: PublicKey;\n    payer: Keypair;\n    authority: Keypair;\n}): Promise<{ txId: string }> {\n    // to be nullified, the address must be part of stateTreeLookupTable set\n    const stateTreeLookupTable = await connection.getAddressLookupTable(\n        stateTreeLookupTableAddress,\n    );\n\n    if (!stateTreeLookupTable.value) {\n        console.log('stateTreeLookupTable', stateTreeLookupTable);\n        throw new Error('State tree lookup table not found');\n    }\n\n    if (\n        !stateTreeLookupTable.value.state.addresses\n            .map(addr => addr.toBase58())\n            .includes(fullStateTreeAddress.toBase58())\n    ) {\n        console.log('fullStateTreeAddress', fullStateTreeAddress);\n        console.log(\n            'stateTreeLookupTable.value.state.addresses',\n            stateTreeLookupTable.value.state.addresses,\n        );\n        throw new Error(\n            'State tree address not found in lookup table. Pass correct address or stateTreeLookupTable',\n        );\n    }\n\n    const nullifyLookupTable = await connection.getAddressLookupTable(\n        nullifyLookupTableAddress,\n    );\n\n    if (!nullifyLookupTable.value) {\n        throw new Error('Nullify table not found');\n    }\n    if (\n        nullifyLookupTable.value.state.addresses\n            .map(addr => addr.toBase58())\n            .includes(fullStateTreeAddress.toBase58())\n    ) {\n        throw new Error('Address already exists in nullify lookup table');\n    }\n\n    const instructions = AddressLookupTableProgram.extendLookupTable({\n        payer: payer.publicKey,\n        authority: authority.publicKey,\n        lookupTable: nullifyLookupTableAddress,\n        addresses: [fullStateTreeAddress],\n    });\n\n    const blockhash = await connection.getLatestBlockhash();\n\n    const tx = buildAndSignTx(\n        [instructions],\n        payer,\n        blockhash.blockhash,\n        dedupeSigner(payer as Signer, [authority]),\n    );\n\n    const txId = await sendAndConfirmTx(connection as Rpc, tx);\n\n    return {\n        txId,\n    };\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { LightSystemProgram, sumUpLamports } from '../programs';\nimport { Rpc } from '../rpc';\nimport { buildAndSignTx, sendAndConfirmTx } from '../utils';\nimport BN from 'bn.js';\nimport { CompressedAccountWithMerkleContext, bn } from '../state';\n\n/**\n * Decompress lamports into a solana account\n *\n * @param rpc                   RPC to use\n * @param payer                 Payer of the transaction and initialization fees\n * @param lamports              Amount of lamports to compress\n * @param toAddress             Address of the recipient compressed account\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Transaction signature\n */\nexport async function decompress(\n    rpc: Rpc,\n    payer: Signer,\n    lamports: number | BN,\n    recipient: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    const userCompressedAccountsWithMerkleContext: CompressedAccountWithMerkleContext[] =\n        (await rpc.getCompressedAccountsByOwner(payer.publicKey)).items;\n\n    lamports = bn(lamports);\n\n    const inputLamports = sumUpLamports(\n        userCompressedAccountsWithMerkleContext,\n    );\n\n    if (lamports.gt(inputLamports)) {\n        throw new Error(\n            `Not enough compressed lamports. Expected ${lamports}, got ${inputLamports}`,\n        );\n    }\n\n    const proof = await rpc.getValidityProof(\n        userCompressedAccountsWithMerkleContext.map(x => bn(x.hash)),\n    );\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const ix = await LightSystemProgram.decompress({\n        payer: payer.publicKey,\n        toAddress: recipient,\n        inputCompressedAccounts: userCompressedAccountsWithMerkleContext,\n        recentValidityProof: proof.compressedProof,\n        recentInputStateRootIndices: proof.rootIndices,\n        lamports,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n","/** pipe function */\nexport function pipe<T, R>(\n    initialFunction: (arg: T) => R,\n    ...functions: ((arg: R) => R)[]\n): (initialValue: T) => R {\n    return (initialValue: T): R =>\n        functions.reduce(\n            (currentValue, currentFunction) => currentFunction(currentValue),\n            initialFunction(initialValue),\n        );\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { it, expect, describe } = import.meta.vitest;\n\n    describe('pipe', () => {\n        it('should return the result of applying all fns to the initial value', () => {\n            const addOne = (x: number) => x + 1;\n            const multiplyByTwo = (x: number) => x * 2;\n            const subtractThree = (x: number) => x - 3;\n            const addOneMultiplyByTwoSubtractThree = pipe(\n                addOne,\n                multiplyByTwo,\n                subtractThree,\n            );\n            expect(addOneMultiplyByTwoSubtractThree(5)).toBe(9);\n        });\n    });\n}\n","// zzz\nexport function sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport BN from 'bn.js';\nimport {\n    LightSystemProgram,\n    selectMinCompressedSolAccountsForTransfer,\n} from '../programs';\nimport { Rpc } from '../rpc';\nimport { bn, CompressedAccountWithMerkleContext } from '../state';\nimport { buildAndSignTx, sendAndConfirmTx } from '../utils';\nimport { GetCompressedAccountsByOwnerConfig } from '../rpc-interface';\n\n/**\n * Transfer compressed lamports from one owner to another\n *\n * @param rpc                   Rpc to use\n * @param payer                 Payer of transaction fees\n * @param lamports              Number of lamports to transfer\n * @param owner                 Owner of the compressed lamports\n * @param toAddress             Destination address of the recipient\n * @param confirmOptions        Options for confirming the transaction\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transfer(\n    rpc: Rpc,\n    payer: Signer,\n    lamports: number | BN,\n    owner: Signer,\n    toAddress: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    let accumulatedLamports = bn(0);\n    const compressedAccounts: CompressedAccountWithMerkleContext[] = [];\n    let cursor: string | undefined;\n    const batchSize = 1000; // Maximum allowed by the API\n    lamports = bn(lamports);\n\n    while (accumulatedLamports.lt(lamports)) {\n        const batchConfig: GetCompressedAccountsByOwnerConfig = {\n            filters: undefined,\n            dataSlice: undefined,\n            cursor,\n            limit: bn(batchSize),\n        };\n\n        const batch = await rpc.getCompressedAccountsByOwner(\n            owner.publicKey,\n            batchConfig,\n        );\n\n        for (const account of batch.items) {\n            if (account.lamports.gt(bn(0))) {\n                compressedAccounts.push(account);\n                accumulatedLamports = accumulatedLamports.add(account.lamports);\n            }\n        }\n\n        cursor = batch.cursor ?? undefined;\n        if (batch.items.length < batchSize || accumulatedLamports.gte(lamports))\n            break;\n    }\n\n    if (accumulatedLamports.lt(lamports)) {\n        throw new Error(\n            `Insufficient balance for transfer. Required: ${lamports.toString()}, available: ${accumulatedLamports.toString()}`,\n        );\n    }\n\n    const [inputAccounts] = selectMinCompressedSolAccountsForTransfer(\n        compressedAccounts,\n        lamports,\n    );\n\n    const proof = await rpc.getValidityProof(\n        inputAccounts.map(account => bn(account.hash)),\n    );\n\n    const ix = await LightSystemProgram.transfer({\n        payer: payer.publicKey,\n        inputCompressedAccounts: inputAccounts,\n        toAddress,\n        lamports,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 350_000 }), ix],\n        payer,\n        blockhash,\n    );\n\n    const txId = await sendAndConfirmTx(rpc, signedTx, confirmOptions);\n    return txId;\n}\n"],"names":["Layout","constructor","span","property","Number","isInteger","TypeError","this","makeDestinationObject","decode","b","offset","Error","encode","src","getSpan","RangeError","replicate","rv","Object","create","prototype","assign","fromArray","values","nameWithProperty","name","lo","Layout_1","bindConstructorLayout","Class","layout","hasOwnProperty","layout_","boundConstructor_","defineProperty","value","writable","ExternalLayout","isCount","GreedyCount","elementSpan","undefined","super","rem","length","Math","floor","OffsetLayout","UInt","UIntBE","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","Int","readIntLE","writeIntLE","IntBE","readIntBE","writeIntBE","V2E32","pow","divmodInt64","hi32","lo32","roundedInt64","NearUInt64","readUInt32LE","split","writeUInt32LE","NearUInt64BE","readUInt32BE","writeUInt32BE","NearInt64","readInt32LE","writeInt32LE","NearInt64BE","readInt32BE","writeInt32BE","Float","readFloatLE","writeFloatLE","FloatBE","readFloatBE","writeFloatBE","Double","readDoubleLE","writeDoubleLE","DoubleBE","readDoubleBE","writeDoubleBE","Sequence","elementLayout","count","idx","i","push","elo","reduce","v","Structure","fields","decodePrefixes","Array","isArray","acc","fd","e","fsp","dest","firstOffset","lastOffset","lastWrote","fv","shift","layoutFor","offsetOf","UnionDiscriminator","UnionLayoutDiscriminator","Union","discr","defaultLayout","upv","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","VariantLayout","vb","Buffer","isBuffer","union","fixBitwiseResult","BitStructure","word","msb","_packedSetValue","_packedGetValue","addField","bits","bf","BitField","addBoolean","Boolean","fieldFor","container","totalBits","usedBits","sum","valueMask","start","wordMask","wordValue","call","Blob","slice","write","toString","CString","srcb","copy","UTF8","maxSpan","Constant","greedy","u8","u16","u24","u32","u40","u48","nu64","u16be","u24be","u32be","u40be","u48be","nu64be","s8","s16","s24","s32","s40","s48","ns64","s16be","s24be","s32be","s40be","s48be","ns64be","f32","f32be","f64","f64be","struct","seq","unionLayoutDiscriminator","blob","cstr","utf8","const","module","exports","assert","val","msg","inherits","ctor","superCtor","super_","TempCtor","BN","number","base","endian","isBN","negative","words","red","_init","wordSize","window","require","parseHex4Bits","string","index","c","charCodeAt","parseHexByte","lowerBound","r","parseBase","str","end","mul","len","min","move","num","max","left","right","cmp","_initNumber","_initArray","replace","_parseHex","_parseBase","toArray","ceil","j","w","off","_strip","limbLen","limbPow","total","mod","imuln","_iaddn","_move","clone","_expand","size","_normSign","Symbol","for","inspect","zeros","groupSizes","groupBases","smallMulTo","self","out","a","carry","k","ncarry","rword","maxJ","padding","groupSize","groupBase","isZero","modrn","idivn","toNumber","ret","toJSON","toBuffer","toArrayLike","ArrayType","byteLength","reqLength","res","allocUnsafe","allocate","_toArrayLikeLE","position","_toArrayLikeBE","clz32","_countBits","t","_zeroBits","bitLength","hi","zeroBits","toTwos","width","abs","inotn","iaddn","fromTwos","testn","notn","ineg","isNeg","neg","iuor","ior","or","uor","iuand","iand","and","uand","iuxor","ixor","xor","uxor","bytesNeeded","bitsLeft","setn","bit","wbit","iadd","isub","add","sub","comb10MulTo","mid","o","a0","al0","ah0","a1","al1","ah1","a2","al2","ah2","a3","al3","ah3","a4","al4","ah4","a5","al5","ah5","a6","al6","ah6","a7","al7","ah7","a8","al8","ah8","a9","al9","ah9","b0","bl0","bh0","b1","bl1","bh1","b2","bl2","bh2","b3","bl3","bh3","b4","bl4","bh4","b5","bl5","bh5","b6","bl6","bh6","b7","bl7","bh7","b8","bl8","bh8","b9","bl9","bh9","w0","imul","w1","w2","w3","w4","w5","w6","w7","w8","w9","w10","w11","w12","w13","w14","w15","w16","w17","w18","bigMulTo","hncarry","jumboMulTo","mulTo","mulf","isNegNum","muln","sqr","isqr","toBitArray","q","iushln","s","carryMask","newCarry","ishln","iushrn","hint","extended","h","mask","maskedWords","ishrn","shln","ushln","shrn","ushrn","imaskn","maskn","isubn","addn","subn","iabs","_ishlnsubmul","_wordDiv","mode","bhi","m","diff","qj","div","divmod","positive","divn","umod","divRound","dm","half","r2","andln","p","modn","egcd","x","y","A","B","C","D","g","isEven","yp","xp","im","isOdd","jm","gcd","_invmp","x1","x2","delta","cmpn","invm","bincn","ucmp","gtn","gt","gten","gte","ltn","lt","lten","lte","eqn","eq","Red","toRed","ctx","convertTo","_forceRed","fromRed","convertFrom","forceRed","redAdd","redIAdd","redSub","redISub","redShl","shl","redMul","_verify2","redIMul","redSqr","_verify1","redISqr","redSqrt","sqrt","redInvm","redNeg","redPow","primes","k256","p224","p192","p25519","MPrime","n","tmp","_tmp","K256","P224","P192","P25519","prime","_prime","Mont","imod","rinv","minv","ireduce","rlen","imulK","strip","input","output","outLen","prev","next","mod3","one","nOne","lpow","z","inv","wnd","current","currentLen","mont","u","TreeType","VERSION","__importDefault","__esModule","default","map","array","rustEnum","vecU8","tagged","vec","bool","option","publicKey","i256","u256","i128","u128","u64","i32","i16","i8","buffer_layout_1","require$$0","web3_js_1","require$$1","bn_js_1","require$$2","buffer_layout_2","enumerable","get","BNLayout","signed","i64","WrappedLayout","decoder","encoder","PublicKey","key","OptionLayout","decodeBool","encodeBool","data","wrappedLayout","receivedTag","from","variants","discriminant","unionLayout","forEach","MapEntryLayout","keyLayout","valueLayout","keyBytes","Map","entries","featureFlags","version","isV2","toUpperCase","versionedEndpoint","FIELD_SIZE","HIGHEST_ADDRESS_PLUS_ONE","COMPUTE_BUDGET_PATTERN","INVOKE_DISCRIMINATOR","INVOKE_CPI_DISCRIMINATOR","INVOKE_CPI_WITH_READ_ONLY_DISCRIMINATOR","INVOKE_CPI_WITH_ACCOUNT_INFO_DISCRIMINATOR","INSERT_INTO_QUEUES_DISCRIMINATOR","noopProgram","lightSystemProgram","accountCompressionProgram","getRegisteredProgramPda","getAccountCompressionAuthority","findProgramAddressSync","defaultStaticAccountsStruct","registeredProgramPda","accountCompressionAuthority","cpiSignatureAccount","defaultStateTreeLookupTables","mainnet","stateTreeLookupTable","stateTreeLookupTableMainnet","nullifyLookupTable","nullifiedStateTreeLookupTableMainnet","devnet","stateTreeLookupTableDevnet","nullifiedStateTreeLookupTableDevnet","isLocalTest","url","includes","localTestActiveStateTreeInfos","tree","merkletreePubkey","queue","nullifierQueuePubkey","cpiContext","cpiContextPubkey","treeType","StateV1","nextTreeInfo","merkleTree2Pubkey","nullifierQueue2Pubkey","cpiContext2Pubkey","batchMerkleTree","batchQueue","StateV2","filter","info","getDefaultAddressTreeInfo","addressTree","addressQueue","AddressV1","defaultTestStateTreeAccounts","nullifierQueue","merkleTree","merkleTreeHeight","DEFAULT_MERKLE_TREE_HEIGHT","COMPRESSED_TOKEN_PROGRAM_ID","TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD","STATE_MERKLE_TREE_ROLLOVER_FEE","ADDRESS_QUEUE_ROLLOVER_FEE","STATE_MERKLE_TREE_NETWORK_FEE","ADDRESS_TREE_NETWORK_FEE","basex","ALPHABET","BASE_MAP","Uint8Array","charAt","xc","LEADER","FACTOR","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","it3","it4","vch","ArrayBuffer","isView","buffer","byteOffset","pbegin","pend","b58","it1","it2","repeat","createBN254","bs58","bigintNumber","enforceSize","encodeBN254toBase58","bn254Buffer","bn","createCompressedAccountLegacy","owner","lamports","address","createCompressedAccountWithMerkleContextLegacy","merkleContext","readOnly","createMerkleContextLegacy","treeInfo","hash","leafIndex","proveByIndex","CompressedAccountLayout","MerkleContextLayout","NewAddressParamsLayout","InstructionDataInvokeLayout","encodeInstructionDataInvoke","alloc","dataBuffer","lengthBuffer","concat","InstructionDataInvokeCpiLayout","CompressedProofLayout","CompressedCpiContextLayout","NewAddressParamsAssignedPackedLayout","PackedMerkleContextLayout","InAccountLayout","PackedReadOnlyAddressLayout","PackedReadOnlyCompressedAccountLayout","InstructionDataInvokeCpiWithReadOnlyLayout","decodeInstructionDataInvokeCpiWithReadOnly","decodeInstructionDataInvoke","decodeInstructionDataInvokeCpi","invokeAccountsLayout","accounts","defaultPubkey","LightSystemProgram","programId","feePayer","authority","solPoolPda","decompressionRecipient","systemProgram","pubkey","isSigner","isWritable","PublicTransactionEventLayout","decodePublicTransactionEvent","AppendNullifyCreateAddressInputsMetaLayout","AppendLeavesInputLayout","InsertNullifierInputLayout","InsertAddressInputLayout","MerkleTreeSequenceNumberLayout","deserializeAppendNullifyCreateAddressInputsIndexer","meta","leavesCount","readUInt8","leaves","leaf","nullifiersCount","nullifiers","nullifier","addressesCount","addresses","outputSequenceNumbersCount","output_sequence_numbers","inputSequenceNumbersCount","addressSequenceNumbersCount","outputLeafIndicesCount","output_leaf_indices","sequence_numbers","convertToPublicTransactionEvent","decoded","remainingAccounts","invokeData","convertByteArray","arr","inputCompressedAccountHashes","account_hash","outputCompressedAccountHashes","l","outputCompressedAccounts","compressedAccount","_a","_b","_c","_d","_e","dataHash","_f","merkleTreeIndex","outputLeafIndices","sequenceNumbers","sn","tree_pubkey","queue_pubkey","tree_type","pubkeyArray","pk","equals","isCompress","relayFee","compressOrDecompressLamports","message","getIndexOrAdd","accountsArray","findIndex","existingKey","padOutputStateMerkleTrees","outputStateMerkleTrees","numberOfOutputCompressedAccounts","fill","toAccountMetas","account","packCompressedAccounts","inputCompressedAccounts","inputStateRootIndices","outputStateTreeInfo","_remainingAccounts","packedInputCompressedAccounts","packedOutputCompressedAccounts","merkleTreePubkeyIndex","queuePubkeyIndex","rootIndex","activeTreeInfo","activeTreeOrQueue","paddedOutputStateMerkleTrees","validateSufficientBalance","balance","validateSameOwner","compressedAccounts","zerothOwner","every","validateNumbersForProof","hashesLength","newAddressesLength","join","validateNumbers","validateNumbersForNonInclusionProof","validateNumbersForInclusionProof","allowedNumbers","type","isSafeInteger","bytes","lengths","exists","instance","checkFinished","destroyed","finished","U32_MASK64","BigInt","_32n","fromBig","le","lst","Ah","Uint32Array","Al","isLE","byteSwap32","toBytes","TextEncoder","utf8ToBytes","abytes","Hash","_cloneInto","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlBH","rotlSH","rotlL","rotlBL","rotlSL","Keccak","blockLen","suffix","outputLen","enableXOF","rounds","pos","posOut","state","state32","keccak","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","keccakP","update","take","finish","writeInto","bufferOut","set","subarray","xofInto","xof","digestInto","destroy","digest","to","keccak_256","hashCons","hashC","wrapConstructor","gen","isObject","isObjectCustom","RegExp","Date","mapObjectSkip","_mapObject","object","mapper","options","isSeen","WeakMap","deep","target","has","mapArray","element","mapResult","newKey","newValue","shouldRecurse","mapObject","UPPERCASE","LOWERCASE","LEADING_CAPITAL","IDENTIFIER","SEPARATORS","LEADING_SEPARATORS","SEPARATORS_AND_IDENTIFIER","NUMBERS_AND_IDENTIFIER","QuickLRU","maxSize","maxAge","POSITIVE_INFINITY","onEviction","cache","oldCache","_size","_emitEvictions","item","_deleteIfExpired","expiry","now","delete","_getOrDeleteIfExpired","_getItemValue","_peek","_set","_moveToRecent","_entriesAscending","peek","deleted","clear","resize","newSize","items","removeCount","keys","iterator","entriesDescending","entriesAscending","oldCacheSize","callbackFunction","thisArgument","toStringTag","JSON","stringify","QuickLru","transform","exclude","pascalCase","stopPaths","preserveConsecutiveUppercase","stopPathsSet","Set","makeMapper","parentPath","path","some","lastIndex","test","cacheKey","returnValue","trim","toLowerCase","locale","toLocaleLowerCase","toLocaleUpperCase","isLastCharLower","isLastCharUpper","isLastLastCharUpper","isLastLastCharPreserved","character","preserveCamelCase","replaceAll","match","pattern","_","identifier","postProcess","camelCase","toHex","isSmallerThanBn254FieldSizeBe","toCamelCase","camelcaseKeys","hashToBn254FieldSizeBe","bumpSeed","inputWithBumpSeed","hashvToBn254FieldSizeBe","hasher","convertInvokeCpiWithReadOnlyToInvoke","proof","newAddressParams","new_address_params","params","seed","addressMerkleTreeRootIndex","address_merkle_tree_root_index","addressMerkleTreeAccountIndex","address_merkle_tree_account_index","addressQueueAccountIndex","address_queue_account_index","inputCompressedAccountsWithMerkleContext","input_compressed_accounts","packedMerkleContext","merkle_tree_pubkey_index","queue_pubkey_index","leaf_index","prove_by_index","root_index","output_compressed_accounts","compress_or_decompress_lamports","is_compress","deriveAddressSeed","seeds","deriveAddress","addressMerkleTreePubkey","buf","packNewAddressParams","newAddressParamsPacked","addressQueuePubkey","async","confirmTransaction","connection","signature","confirmation","latestBlockHash","getLatestBlockhash","strategy","lastValidBlockHeight","blockhash","dedupeSigner","signer","signers","proofFromJsonStruct","json","proofAX","deserializeHexStringToBeBytes","ar","proofAY","proofA","proofBX0","bs","proofBX1","proofBY0","proofBY1","proofB","proofCX","krs","proofCY","negateAndCompressProof","proofC","aXElement","proofAIsPositive","yElementIsPositiveG1","addBitmaskToByte","bXElement","bYElement","proofBIsPositive","yElement1","yElement2","fieldMidpoint","yElementIsPositiveG2","cXElement","cYElement","proofCIsPositive","hexStr","bN","startsWith","substring","yElement","byte","yIsPositive","buildTx","instructions","payerPublicKey","lookupTableAccounts","messageV0","TransactionMessage","payerKey","recentBlockhash","compileToV0Message","VersionedTransaction","sendAndConfirmTx","rpc","tx","confirmOptions","txId","sendTransaction","confirmTx","commitment","interval","rpcEndpoint","elapsed","Promise","resolve","reject","intervalId","setInterval","clearInterval","status","getSignatureStatuses","confirmationStatus","slot","getSlot","confirmTransactionIndexed","context","err","buildAndSignTx","payer","additionalSigners","allSigners","sign","getStateTreeInfoByPubkey","treeInfos","treeOrQueue","getTreeInfoByPubkey","find","toBase58","selectStateTreeInfo","infos","useMaxConcurrency","filteredInfos","random","getAllStateTreeInfos","stateTreeLUTPairs","stateTreeLookupTablesAndNullifyLookupTables","all","lutPair","getAddressLookupTable","contexts","stateTreePubkeys","nullifyLookupTablePubkeys","addr","nextAvailableTreeInfo","sumUpLamports","SOL_POOL_PDA_SEED","deriveCompressedSolPda","createTransferOutputState","toAddress","changeLamports","createDecompressOutputState","createNewAddressOutputState","createAccount","newAddress","recentValidityProof","SystemProgram","TransactionInstruction","transfer","recentInputStateRootIndices","compress","outputCompressedAccount","decompress","selectMinCompressedSolAccountsForTransfer","transferLamports","accumulatedLamports","selectedAccounts","sort","IndexedElement","nextIndex","other","compareTo","lightWasm","nextValue","poseidonHash","error","IndexedElementBundle","newLowElement","newElement","newElementNextValue","IndexedArray","elements","currentNodeIndex","highestElementIndex","isEmpty","findElement","node","init","init_value","append","findLowElementIndex","findLowElement","lowElementIndex","lowElement","hashElement","nextElement","appendWithLowElementIndex","newElementBundle","newElementWithLowElementIndex","lowest","newElementIndex","MerkleTree","levels","zeroElement","capacity","_lightWasm","_zeros","_layers","poseidonHashString","_rebuild","level","root","insert","bulkInsert","isNaN","pathElements","pathIndices","indexOf","comparator","el","serialize","deserialize","hashFunction","_hash","getParsedEvents","events","signatures","getSignaturesForAddress","txs","getParsedTransactions","maxSupportedTransactionVersion","txParsed","transaction","innerInstructions","allAccounts","accountKeys","txRaw","getTransaction","ix","compiledInstructions","decodedData","innerGroup","accountIdx","transactionEvents","parseEvents","parsePublicTransactionEventWithIdl","indexerEventsTransactions","deserializeFn","transactions","ixInner","decodedEvent","numericData","console","getCompressedAccountByHashTest","getCompressedAccountsForTest","reverse","allOutputAccounts","allInputAccountHashes","getStateTreeInfos","event","withCtx","unspentAccounts","TokenDataLayout","parseTokenLayoutWithIdl","getCompressedTokenAccounts","eventsWithParsedTokenTlvData","outputHashes","outputCompressedAccountsWithParsedTokenData","maybeTree","parsedData","parsed","parseEventWithTokenTlvData","allOutCompressedAccounts","flatMap","allInCompressedAccountHashes","getCompressedTokenAccountsByOwnerTest","mint","cursor","getCompressedTokenAccountsByDelegateTest","delegate","getCompressedTokenAccountByHashTest","filtered","StructError","failure","failures","cached","explanation","rest","cause","isNonArrayObject","print","toFailure","result","branch","refinement","toFailures","run","coerce","coercer","validator","ts","refiner","Struct","props","schema","validate","is","tuples","tuple","done","shiftIterator","define","any","Element","boolean","literal","constant","description","nullable","Structs","S","coerced","first","unknown","condition","PublicKeyFromString","ArrayFromString","BN254FromString","BNFromStringOrNumber","Base64EncodedCompressedAccountDataResult","createRpcResult","pick","jsonrpc","id","code","UnknownRpcResult","jsonRpcResult","jsonRpcResultAndContext","NextTreeInfoResultV2","TreeInfoResultV2","nextTreeContext","CompressedAccountResult","slotCreated","CompressedAccountResultV2","TokenDataResult","amount","CompressedTokenAccountResult","tokenData","CompressedTokenAccountResultV2","MultipleCompressedAccountsResult","MultipleCompressedAccountsResultV2","CompressedAccountsByOwnerResult","CompressedAccountsByOwnerResultV2","CompressedTokenAccountsByOwnerOrDelegateResult","CompressedTokenAccountsByOwnerOrDelegateResultV2","SlotResult","HealthResult","LatestNonVotingSignaturesResult","blockTime","LatestNonVotingSignaturesResultPaginated","MerkleProofResult","rootSeq","MerkleProofResultV2","treeContext","NewAddressProofResult","lowerRangeAddress","higherRangeAddress","lowElementLeafIndex","CompressedProofResult","RootIndexResultV2","ValidityProofResult","compressedProof","leafIndices","rootIndices","roots","merkleTrees","AccountProofInputsResult","AddressProofInputsResult","ValidityProofResultV2","MultipleMerkleProofsResult","MultipleMerkleProofsResultV2","BalanceResult","NativeBalanceResult","TokenBalanceResult","TokenBalanceListResult","tokenBalances","TokenBalanceListResultV2","CompressedMintTokenHoldersResult","AccountProofResult","SignatureListResult","SignatureListWithCursorResult","ClosedAccountResultV2","txHash","CompressedTransactionResult","compressionInfo","closedAccounts","optionalTokenData","openedAccounts","CompressedTransactionResultV2","parseAccountData","getCompressedTokenAccountsByOwnerOrDelegate","ownerOrDelegate","filterByDelegate","endpoint","propertyToCheck","unsafeRes","rpcRequest","compressionApiEndpoint","limit","SolanaJSONRPCError","activeStateTreeInfos","_account","_tokenData","stateTreeInfo","tlv","wrapBigNumbersAsStrings","text","p1","p2","p3","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","method","convertToCamelCase","debug","body","generateCurlSnippet","escapedBody","stack","response","fetch","headers","ok","wrappedJsonString","parse","proverRequest","proverEndpoint","logMsg","time","circuitType","stateTreeHeight","addressTreeHeight","newAddresses","statusText","timeEnd","convertMerkleProofsWithContextToHex","merkleProofsWithContext","inputs","pathIndex","merkleProof","hex","convertNonInclusionMerkleProofInputsToHex","nonInclusionMerkleProofInputs","indexHashedIndexedElementLeaf","merkleProofHashedIndexedElementLeaf","leafLowerRangeValue","leafHigherRangeValue","calculateTwoInputsHashChain","hashesFirst","hashesSecond","hashChain","poseidonHashBN","buildCompressedAccountWithMaybeTokenData","accountStructWithOptionalTokenData","compressedAccountResult","tokenDataResult","maybeTokenData","Rpc","Connection","config","allStateTreeInfos","lastStateTreeFetchTime","CACHE_TTL","fetchPromise","getCachedActiveStateTreeInfo","getCachedActiveStateTreeInfos","doFetch","mainnetError","devnetError","getCompressedAccount","activeStateTreeInfo","getCompressedBalance","getCompressedBalanceByOwner","getCompressedAccountProof","getMultipleCompressedAccounts","hashes","getMultipleCompressedAccountProofs","merkleProofs","getCompressedAccountsByOwner","filters","dataSlice","getCompressedTokenAccountsByOwner","getCompressedTokenAccountsByDelegate","getCompressedTokenAccountBalance","getCompressedTokenBalancesByOwner","tokenBalance","getCompressedTokenBalancesByOwnerV2","maybeFiltered","getCompressionSignaturesForAccount","getTransactionWithCompressionInfo","closedAccountResultV2","v1type","v2NullifierMetadata","maybeNullifierMetadata","buildCompressedAccountWithMaybeTokenDataFromClosedAccountResultV2","calculateTokenBalances","balances","preTokenBalances","postTokenBalances","getCompressionSignaturesForAddress","getCompressionSignaturesForOwner","getCompressionSignaturesForTokenOwner","getIndexerHealth","timeout","startTime","getIndexerSlot","setTimeout","getCompressedMintTokenHolders","getLatestCompressionSignatures","getLatestNonVotingSignatures","getMultipleNewAddressProofs","newAddressProofs","_proof","getValidityProof","accs","trees","queues","defaultAddressTreePublicKey","defaultAddressQueuePublicKey","formattedHashes","formattedNewAddresses","getValidityProofV0","getValidityProofAndRpcContext","newAddressesWithTrees","proveByIndices","allInfos","TestRpc","connectionConfig","testRpcConfig","depth","getMultipleCompressedAccountsByHashTest","_slot","then","leavesByTree","cachedStateTreeInfos","treeData","merkleProofsMap","treeKey","bnPathElements","computedHash","hashArr","_config","getCompressedAccountsByOwnerTest","_cursor","_limit","_signature","_address","_options","_owner","indexedArray","allAddresses","higherRangeValue","_mint","validityProof","treeInfosUsed","hasV1Accounts","newAddressInputs","ALICE","getTestKeypair","BOB","CHARLIE","DAVE","counter","Keypair","generate","fromSeed","UtxoErrorCode","SelectInUtxosErrorCode","CreateUtxoErrorCode","RpcErrorCode","LookupTableErrorCode","ProofErrorCode","MerkleTreeErrorCode","UtilsErrorCode","HashErrorCode","MetaError","functionName","codeMessage","constants","isMut","args","docs","isOptional","defined","kind","types","errors","recipientPublicKey","requestAirdrop","byteArray","fromSecretKey","targetLamports","computeUnits","ComputeBudgetProgram","setComputeUnitLimit","units","preflightCommitment","addressTreeInfo","inputAccounts","outputStateTreeIndex","endpointOrWeb3JsConnection","recentSlot","createInstruction1","lookupTableAddress1","AddressLookupTableProgram","createLookupTable","recipient","userCompressedAccountsWithMerkleContext","inputLamports","deepEqual","ref","refKeys","valKeys","nullifierQueue2","merkleTree2","tableAddress","newStateTreeAddresses","newQueueAddresses","newCpiContextAddresses","lutState","extendLookupTable","lookupTable","accountProofs","accountHashes","inclusionHashChain","newAddressHashes","nonInclusionHashChain","sig","fullStateTreeAddress","nullifyLookupTableAddress","stateTreeLookupTableAddress","accountProofInputs","newAddressProofInputs","stateTreeInfos","addressTreeInfos","outputTreeIndex","stateTrees","addressTrees","addressMerkleTreePubkeyIndex","addressQueuePubkeyIndex","packedTreeInfos","dataVec","foundSystemInstruction","appendInputsData","discriminatorStr","invokeDiscriminatorStr","invokeCpiDiscriminatorStr","invokeCpiWithReadOnlyDiscriminatorStr","insertIntoQueuesDiscriminatorStr","selectedIndex","initialFunction","functions","initialValue","currentValue","currentFunction","ms","getTime","batchConfig","batch","signedTx"],"mappings":"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xB,QAAS,8BAM7B73B,SAAU,CACN,CACIjvB,KAAM,oBACN4mD,KAAM,CACF,wEACA,mDACA,yFACA,wCACA,qFACA,kCAEJhxB,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,WACN41B,KAAM,aAEV,CACI51B,KAAM,uBACN41B,KAAM,aAEV,CACI51B,KAAM,UACN41B,KAAM,CACFlS,IAAK,CACDojC,QAAS,kCAQrCE,MAAO,CACH,CACIhnD,KAAM,wBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,QACN41B,KAAM,CACFhS,OAAQ,CACJkjC,QAAS,qBAIrB,CACI9mD,KAAM,2CACN41B,KAAM,CACFlS,IAAK,CACDojC,QACI,8CAIhB,CACI9mD,KAAM,2BACN41B,KAAM,CACFlS,IAAK,CACDojC,QACI,8CAIhB,CACI9mD,KAAM,WACN41B,KAAM,CACFhS,OAAQ,QAGhB,CACI5jB,KAAM,mBACN41B,KAAM,CACFlS,IAAK,CACDojC,QAAS,4BAIrB,CACI9mD,KAAM,+BACN41B,KAAM,CACFhS,OAAQ,QAGhB,CACI5jB,KAAM,aACN41B,KAAM,WAKtB,CACI51B,KAAM,yBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,OACN41B,KAAM,CACFtS,MAAO,CAAC,KAAM,MAGtB,CACItjB,KAAM,2BACN41B,KAAM,MAEV,CACI51B,KAAM,gCACN41B,KAAM,MAEV,CACI51B,KAAM,6BACN41B,KAAM,UAKtB,CACI51B,KAAM,2CACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,oBACN41B,KAAM,CACFkxB,QAAS,sBAGjB,CACI9mD,KAAM,kBACN41B,KAAM,SAKtB,CACI51B,KAAM,kBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,IACN41B,KAAM,CACFtS,MAAO,CAAC,KAAM,MAGtB,CACItjB,KAAM,IACN41B,KAAM,CACFtS,MAAO,CAAC,KAAM,MAGtB,CACItjB,KAAM,IACN41B,KAAM,CACFtS,MAAO,CAAC,KAAM,SAMlC,CACItjB,KAAM,2BACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,QACN41B,KAAM,CACFhS,OAAQ,CACJkjC,QAAS,qBAIrB,CACI9mD,KAAM,mBACN41B,KAAM,CACFlS,IAAK,CACDojC,QAAS,4BAIrB,CACI9mD,KAAM,2CACN41B,KAAM,CACFlS,IAAK,CACDojC,QACI,8CAIhB,CACI9mD,KAAM,2BACN41B,KAAM,CACFlS,IAAK,CACDojC,QACI,8CAIhB,CACI9mD,KAAM,WACN41B,KAAM,CACFhS,OAAQ,QAGhB,CACI5jB,KAAM,+BACN41B,KAAM,CACFhS,OAAQ,QAGhB,CACI5jB,KAAM,aACN41B,KAAM,QAEV,CACI51B,KAAM,aACN41B,KAAM,CACFhS,OAAQ,CACJkjC,QAAS,6BAOjC,CACI9mD,KAAM,uBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,aACN4mD,KAAM,CACF,0EACA,wBAEJhxB,KAAM,QAEV,CACI51B,KAAM,kBACN4mD,KAAM,CACF,wEACA,wBAEJhxB,KAAM,QAEV,CACI51B,KAAM,yBACN4mD,KAAM,CACF,uDAEJhxB,KAAM,SAKtB,CACI51B,KAAM,oBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,QACN41B,KAAM,aAEV,CACI51B,KAAM,WACN41B,KAAM,OAEV,CACI51B,KAAM,UACN41B,KAAM,CACFhS,OAAQ,CACJN,MAAO,CAAC,KAAM,OAI1B,CACItjB,KAAM,OACN41B,KAAM,CACFhS,OAAQ,CACJkjC,QAAS,8BAOjC,CACI9mD,KAAM,wBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,gBACN41B,KAAM,CACFtS,MAAO,CAAC,KAAM,KAGtB,CACItjB,KAAM,OACN41B,KAAM,SAEV,CACI51B,KAAM,WACN41B,KAAM,CACFtS,MAAO,CAAC,KAAM,SAMlC,CACItjB,KAAM,2CACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,oBACN41B,KAAM,CACFkxB,QAAS,sBAGjB,CACI9mD,KAAM,gBACN41B,KAAM,CACFkxB,QAAS,wBAGjB,CACI9mD,KAAM,YACN4mD,KAAM,CACF,mDAEJhxB,KAAM,OAEV,CACI51B,KAAM,WACN4mD,KAAM,CACF,sEAEJhxB,KAAM,WAKtB,CACI51B,KAAM,sBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,wBACN41B,KAAM,MAEV,CACI51B,KAAM,mBACN41B,KAAM,MAEV,CACI51B,KAAM,YACN41B,KAAM,OAEV,CACI51B,KAAM,eACN41B,KAAM,WAKtB,CACI51B,KAAM,2BACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,SACN41B,KAAM,aAEV,CACI51B,KAAM,MACN41B,KAAM,UAKtB,CACI51B,KAAM,yBACN41B,KAAM,CACFmxB,KAAM,SACNniD,OAAQ,CACJ,CACI5E,KAAM,+BACN41B,KAAM,CACFlS,IAAK,CACDJ,MAAO,CAAC,KAAM,OAI1B,CACItjB,KAAM,gCACN41B,KAAM,CACFlS,IAAK,CACDJ,MAAO,CAAC,KAAM,OAI1B,CACItjB,KAAM,2BACN41B,KAAM,CACFlS,IAAK,CACDojC,QACI,8CAIhB,CACI9mD,KAAM,oBACN41B,KAAM,CACFlS,IAAK,QAGb,CACI1jB,KAAM,kBACN41B,KAAM,CACFlS,IAAK,CACDojC,QAAS,8BAIrB,CACI9mD,KAAM,WACN41B,KAAM,CACFhS,OAAQ,QAGhB,CACI5jB,KAAM,aACN41B,KAAM,QAEV,CACI51B,KAAM,+BACN41B,KAAM,CACFhS,OAAQ,QAGhB,CACI5jB,KAAM,cACN41B,KAAM,CACFlS,IAAK,cAGb,CACI1jB,KAAM,UACN41B,KAAM,CACFhS,OAAQ,cAOhCqjC,OAAQ,CACJ,CACItQ,KAAM,IACN32C,KAAM,iBACNkM,IAAK,oBAET,CACIyqC,KAAM,KACN32C,KAAM,oBACNkM,IAAK,uBAET,CACIyqC,KAAM,KACN32C,KAAM,uBACNkM,IAAK,2BAET,CACIyqC,KAAM,KACN32C,KAAM,wBACNkM,IAAK,+BAET,CACIyqC,KAAM,KACN32C,KAAM,yBACNkM,IAAK,gCAET,CACIyqC,KAAM,KACN32C,KAAM,sBACNkM,IAAK,6BAET,CACIyqC,KAAM,KACN32C,KAAM,iBACNkM,IAAK,kBAET,CACIyqC,KAAM,KACN32C,KAAM,qBACNkM,IAAK,sBAET,CACIyqC,KAAM,KACN32C,KAAM,0CACNkM,IAAK,2CAET,CACIyqC,KAAM,KACN32C,KAAM,4CACNkM,IAAK,6CAET,CACIyqC,KAAM,KACN32C,KAAM,4CACNkM,IAAK,6CAET,CACIyqC,KAAM,KACN32C,KAAM,8CACNkM,IAAK,+CAET,CACIyqC,KAAM,KACN32C,KAAM,+CACNkM,IAAK,gDAET,CACIyqC,KAAM,KACN32C,KAAM,yBACNkM,IAAK,0BAET,CACIyqC,KAAM,KACN32C,KAAM,6BACNkM,IAAK,8BAET,CACIyqC,KAAM,KACN32C,KAAM,kBACNkM,IAAK,mBAET,CACIyqC,KAAM,KACN32C,KAAM,yBACNkM,IAAK,0BAET,CACIyqC,KAAM,KACN32C,KAAM,cACNkM,IAAK,eAET,CACIyqC,KAAM,KACN32C,KAAM,cACNkM,IAAK,6EAET,CACIyqC,KAAM,KACN32C,KAAM,cACNkM,IAAK,eAET,CACIyqC,KAAM,KACN32C,KAAM,6BACNkM,IAAK,8BAET,CACIyqC,KAAM,KACN32C,KAAM,kBACNkM,IAAK,mBAET,CACIyqC,KAAM,KACN32C,KAAM,oBACNkM,IAAK,qBAET,CACIyqC,KAAM,KACN32C,KAAM,gCACNkM,IAAK,iCAET,CACIyqC,KAAM,KACN32C,KAAM,oBACNkM,IAAK,qBAET,CACIyqC,KAAM,KACN32C,KAAM,oBACNkM,IAAK,qBAET,CACIyqC,KAAM,KACN32C,KAAM,yBACNkM,IAAK,mCAET,CACIyqC,KAAM,KACN32C,KAAM,6BACNkM,IAAK,8BAET,CACIyqC,KAAM,KACN32C,KAAM,yCACNkM,IAAK,0CAET,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","x_google_ignoreList":[0,1,4,5,6,13,14,15,16,17,18,19,20,35]}