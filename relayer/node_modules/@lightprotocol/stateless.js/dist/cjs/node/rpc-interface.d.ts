import { PublicKey, MemcmpFilter, DataSlice } from '@solana/web3.js';
import { Struct } from 'superstruct';
import { BN254, ValidityProof, CompressedAccountWithMerkleContext, MerkleContextWithMerkleProof, TokenData, TreeInfo, AddressTreeInfo, CompressedProof } from './state';
import BN from 'bn.js';
export interface LatestNonVotingSignatures {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
            error: string | null;
        }[];
    };
}
export interface GetCompressedAccountsByOwnerConfig {
    filters?: GetCompressedAccountsFilter[];
    dataSlice?: DataSlice;
    cursor?: string;
    limit?: BN;
}
export interface CompressedMintTokenHolders {
    balance: BN;
    owner: PublicKey;
}
export interface LatestNonVotingSignaturesPaginated {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
        }[];
        cursor: string | null;
    };
}
export interface SignatureWithMetadata {
    blockTime: number;
    signature: string;
    slot: number;
}
/**
 * Account hash and associated state tree info.
 */
export interface HashWithTreeInfo {
    /**
     * Account hash.
     */
    hash: BN254;
    /**
     * State tree info.
     */
    stateTreeInfo: TreeInfo;
}
/**
 * Address and associated address tree info.
 */
export interface AddressWithTreeInfo {
    /**
     * Address.
     */
    address: BN254;
    /**
     * Address tree info.
     */
    addressTreeInfo: AddressTreeInfo;
}
export interface HashWithTree {
    hash: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
export interface AddressWithTree {
    address: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
export interface AddressWithTreeInfo {
    address: BN254;
    treeInfo: AddressTreeInfo;
}
export interface CompressedTransaction {
    compressionInfo: {
        closedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData | null;
        }[];
        openedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData | null;
        }[];
        preTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
        postTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
    };
    transaction: any;
}
export interface HexBatchInputsForProver {
    'input-compressed-accounts': HexInputsForProver[];
}
export interface HexInputsForProver {
    root: string;
    pathIndex: number;
    pathElements: string[];
    leaf: string;
}
/**
 * Validity proof with context.
 *
 * You can request proofs via `rpc.getValidityProof` or
 * `rpc.getValidityProofV0`.
 */
export type ValidityProofWithContext = {
    /**
     * Validity proof.
     */
    compressedProof: ValidityProof | null;
    /**
     * Roots.
     */
    roots: BN[];
    /**
     * Root indices.
     */
    rootIndices: number[];
    /**
     * Leaf indices.
     */
    leafIndices: number[];
    /**
     * Leaves.
     */
    leaves: BN[];
    /**
     * Tree infos.
     */
    treeInfos: TreeInfo[];
    /**
     * Whether to prove by indices.
     */
    proveByIndices: boolean[];
};
/**
 * @deprecated use {@link ValidityProofWithContext} instead
 */
export type CompressedProofWithContext = {
    compressedProof: CompressedProof;
    roots: BN[];
    rootIndices: number[];
    leafIndices: number[];
    leaves: BN[];
    merkleTrees: PublicKey[];
    nullifierQueues: PublicKey[];
};
export interface GetCompressedTokenAccountsByOwnerOrDelegateOptions {
    mint?: PublicKey;
    cursor?: string;
    limit?: BN;
}
export type TokenBalance = {
    balance: BN;
    mint: PublicKey;
};
/**
 * **Cursor** is a unique identifier for a page of results by which the next page can be fetched.
 *
 * **Limit** is the maximum number of results to return per page.
 */
export interface PaginatedOptions {
    cursor?: string;
    limit?: BN;
}
/**
 * Note, DataSizeFilter is currently not available.
 */
export type GetCompressedAccountsFilter = MemcmpFilter;
export type GetCompressedAccountConfig = {
    encoding?: string;
};
export type GetCompressedAccountsConfig = {
    dataSlice: DataSlice;
    filters?: GetCompressedAccountsFilter[];
};
export interface ParsedTokenAccount {
    compressedAccount: CompressedAccountWithMerkleContext;
    parsed: TokenData;
}
export type WithContext<T> = {
    /** context */
    context: {
        slot: number;
    };
    /** response value */
    value: T;
};
export type WithCursor<T> = {
    /** context */
    cursor: string | null;
    /** response value */
    items: T;
};
/**
 * @internal
 */
export declare function createRpcResult<T, U>(result: Struct<T, U>): Struct<RpcResult<T>, null>;
/**
 * @internal
 */
export declare function jsonRpcResult<T, U>(schema: Struct<T, U>): Struct<RpcResult<T>, null>;
export type WithRpcContext<T> = {
    context: {
        slot: number;
    };
    value: T;
};
/**
 * @internal
 */
export declare function jsonRpcResultAndContext<T, U>(value: Struct<T, U>): Struct<RpcResult<WithRpcContext<T>>, null>;
/**
 * @internal
 */
export declare const CompressedAccountResult: Struct<{
    data: {
        data: string;
        dataHash: BN;
        discriminator: BN;
    } | null;
    lamports: BN;
    tree: PublicKey;
    address: number[] | null;
    hash: BN;
    owner: PublicKey;
    leafIndex: number;
    seq: BN | null;
    slotCreated: BN;
}, {
    address: Struct<number[] | null, null>;
    hash: Struct<BN, null>;
    data: Struct<{
        data: string;
        dataHash: BN;
        discriminator: BN;
    } | null, {
        data: Struct<string, null>;
        dataHash: Struct<BN, null>;
        discriminator: Struct<BN, null>;
    }>;
    lamports: Struct<BN, null>;
    owner: Struct<PublicKey, null>;
    leafIndex: Struct<number, null>;
    tree: Struct<PublicKey, null>;
    seq: Struct<BN | null, null>;
    slotCreated: Struct<BN, null>;
}>;
export declare const CompressedAccountResultV2: Struct<{
    data: {
        data: string;
        dataHash: BN;
        discriminator: BN;
    } | null;
    lamports: BN;
    address: number[] | null;
    hash: BN;
    owner: PublicKey;
    leafIndex: number;
    seq: BN | null;
    slotCreated: BN;
    merkleContext: {
        cpiContext: PublicKey | null;
        tree: PublicKey;
        queue: PublicKey;
        treeType: number;
        nextTreeContext?: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined;
    };
    proveByIndex: boolean;
}, {
    address: Struct<number[] | null, null>;
    hash: Struct<BN, null>;
    data: Struct<{
        data: string;
        dataHash: BN;
        discriminator: BN;
    } | null, {
        data: Struct<string, null>;
        dataHash: Struct<BN, null>;
        discriminator: Struct<BN, null>;
    }>;
    lamports: Struct<BN, null>;
    owner: Struct<PublicKey, null>;
    leafIndex: Struct<number, null>;
    seq: Struct<BN | null, null>;
    slotCreated: Struct<BN, null>;
    merkleContext: Struct<{
        cpiContext: PublicKey | null;
        tree: PublicKey;
        queue: PublicKey;
        treeType: number;
        nextTreeContext?: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined;
    }, {
        treeType: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        queue: Struct<PublicKey, null>;
        cpiContext: Struct<PublicKey | null, null>;
        nextTreeContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
        }>;
    }>;
    proveByIndex: Struct<boolean, null>;
}>;
export declare const TokenDataResult: Struct<{
    owner: PublicKey;
    mint: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: string;
}, {
    mint: Struct<PublicKey, null>;
    owner: Struct<PublicKey, null>;
    amount: Struct<BN, null>;
    delegate: Struct<PublicKey | null, null>;
    state: Struct<string, null>;
}>;
/**
 * @internal
 */
export declare const CompressedTokenAccountResult: Struct<{
    tokenData: {
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    };
    account: {
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    };
}, {
    tokenData: Struct<{
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    }, {
        mint: Struct<PublicKey, null>;
        owner: Struct<PublicKey, null>;
        amount: Struct<BN, null>;
        delegate: Struct<PublicKey | null, null>;
        state: Struct<string, null>;
    }>;
    account: Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>;
}>;
/**
 * @internal
 */
export declare const CompressedTokenAccountResultV2: Struct<{
    tokenData: {
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    };
    account: {
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    };
}, {
    tokenData: Struct<{
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    }, {
        mint: Struct<PublicKey, null>;
        owner: Struct<PublicKey, null>;
        amount: Struct<BN, null>;
        delegate: Struct<PublicKey | null, null>;
        state: Struct<string, null>;
    }>;
    account: Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
        merkleContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        }, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
            nextTreeContext: Struct<{
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined, {
                treeType: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                queue: Struct<PublicKey, null>;
                cpiContext: Struct<PublicKey | null, null>;
            }>;
        }>;
        proveByIndex: Struct<boolean, null>;
    }>;
}>;
/**
 * @internal
 */
export declare const MultipleCompressedAccountsResult: Struct<{
    items: {
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    }[];
}, {
    items: Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    }[], Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
}>;
/**
 * @internal
 */
export declare const MultipleCompressedAccountsResultV2: Struct<{
    items: {
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    }[];
}, {
    items: Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    }[], Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
        merkleContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        }, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
            nextTreeContext: Struct<{
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined, {
                treeType: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                queue: Struct<PublicKey, null>;
                cpiContext: Struct<PublicKey | null, null>;
            }>;
        }>;
        proveByIndex: Struct<boolean, null>;
    }>>;
}>;
/**
 * @internal
 */
export declare const CompressedAccountsByOwnerResult: Struct<{
    items: {
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    }[], Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        tree: PublicKey;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const CompressedAccountsByOwnerResultV2: Struct<{
    items: {
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    }[], Struct<{
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        lamports: BN;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        seq: BN | null;
        slotCreated: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        proveByIndex: boolean;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
        merkleContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        }, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
            nextTreeContext: Struct<{
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined, {
                treeType: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                queue: Struct<PublicKey, null>;
                cpiContext: Struct<PublicKey | null, null>;
            }>;
        }>;
        proveByIndex: Struct<boolean, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const CompressedTokenAccountsByOwnerOrDelegateResult: Struct<{
    items: {
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            tree: PublicKey;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
        };
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            tree: PublicKey;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
        };
    }[], Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            tree: PublicKey;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
        };
    }, {
        tokenData: Struct<{
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        }, {
            mint: Struct<PublicKey, null>;
            owner: Struct<PublicKey, null>;
            amount: Struct<BN, null>;
            delegate: Struct<PublicKey | null, null>;
            state: Struct<string, null>;
        }>;
        account: Struct<{
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            tree: PublicKey;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
        }, {
            address: Struct<number[] | null, null>;
            hash: Struct<BN, null>;
            data: Struct<{
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null, {
                data: Struct<string, null>;
                dataHash: Struct<BN, null>;
                discriminator: Struct<BN, null>;
            }>;
            lamports: Struct<BN, null>;
            owner: Struct<PublicKey, null>;
            leafIndex: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            seq: Struct<BN | null, null>;
            slotCreated: Struct<BN, null>;
        }>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const CompressedTokenAccountsByOwnerOrDelegateResultV2: Struct<{
    items: {
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
            merkleContext: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
                nextTreeContext?: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                } | null | undefined;
            };
            proveByIndex: boolean;
        };
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
            merkleContext: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
                nextTreeContext?: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                } | null | undefined;
            };
            proveByIndex: boolean;
        };
    }[], Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
            merkleContext: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
                nextTreeContext?: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                } | null | undefined;
            };
            proveByIndex: boolean;
        };
    }, {
        tokenData: Struct<{
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        }, {
            mint: Struct<PublicKey, null>;
            owner: Struct<PublicKey, null>;
            amount: Struct<BN, null>;
            delegate: Struct<PublicKey | null, null>;
            state: Struct<string, null>;
        }>;
        account: Struct<{
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            lamports: BN;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            seq: BN | null;
            slotCreated: BN;
            merkleContext: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
                nextTreeContext?: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                } | null | undefined;
            };
            proveByIndex: boolean;
        }, {
            address: Struct<number[] | null, null>;
            hash: Struct<BN, null>;
            data: Struct<{
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null, {
                data: Struct<string, null>;
                dataHash: Struct<BN, null>;
                discriminator: Struct<BN, null>;
            }>;
            lamports: Struct<BN, null>;
            owner: Struct<PublicKey, null>;
            leafIndex: Struct<number, null>;
            seq: Struct<BN | null, null>;
            slotCreated: Struct<BN, null>;
            merkleContext: Struct<{
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
                nextTreeContext?: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                } | null | undefined;
            }, {
                treeType: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                queue: Struct<PublicKey, null>;
                cpiContext: Struct<PublicKey | null, null>;
                nextTreeContext: Struct<{
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                } | null | undefined, {
                    treeType: Struct<number, null>;
                    tree: Struct<PublicKey, null>;
                    queue: Struct<PublicKey, null>;
                    cpiContext: Struct<PublicKey | null, null>;
                }>;
            }>;
            proveByIndex: Struct<boolean, null>;
        }>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const SlotResult: Struct<number, null>;
/**
 * @internal
 */
export declare const HealthResult: Struct<string, null>;
/**
 * @internal
 */
export declare const LatestNonVotingSignaturesResult: Struct<{
    items: {
        error: string | null;
        blockTime: number;
        signature: string;
        slot: number;
    }[];
}, {
    items: Struct<{
        error: string | null;
        blockTime: number;
        signature: string;
        slot: number;
    }[], Struct<{
        error: string | null;
        blockTime: number;
        signature: string;
        slot: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
        error: Struct<string | null, null>;
    }>>;
}>;
/**
 * @internal
 */
export declare const LatestNonVotingSignaturesResultPaginated: Struct<{
    items: {
        blockTime: number;
        signature: string;
        slot: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }[], Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const MerkleProofResult: Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>;
/**
 * @internal
 */
export declare const MerkleProofResultV2: Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    proveByIndex: boolean;
    proof: BN[];
    rootSeq: number;
    treeContext: {
        cpiContext: PublicKey | null;
        tree: PublicKey;
        queue: PublicKey;
        treeType: number;
        nextTreeContext?: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined;
    };
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    root: Struct<BN, null>;
    rootSeq: Struct<number, null>;
    proveByIndex: Struct<boolean, null>;
    treeContext: Struct<{
        cpiContext: PublicKey | null;
        tree: PublicKey;
        queue: PublicKey;
        treeType: number;
        nextTreeContext?: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined;
    }, {
        treeType: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        queue: Struct<PublicKey, null>;
        cpiContext: Struct<PublicKey | null, null>;
        nextTreeContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
        }>;
    }>;
}>;
/**
 * @internal
 */
export declare const NewAddressProofResult: Struct<{
    root: BN;
    address: BN;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
    nextIndex: number;
    lowerRangeAddress: BN;
    higherRangeAddress: BN;
    lowElementLeafIndex: number;
}, {
    address: Struct<BN, null>;
    nextIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
    lowerRangeAddress: Struct<BN, null>;
    higherRangeAddress: Struct<BN, null>;
    lowElementLeafIndex: Struct<number, null>;
}>;
/**
 * @internal
 */
export declare const RootIndexResultV2: Struct<{
    proveByIndex: boolean;
    rootIndex: number;
}, {
    rootIndex: Struct<number, null>;
    proveByIndex: Struct<boolean, null>;
}>;
/**
 * @internal
 */
export declare const ValidityProofResult: Struct<{
    compressedProof: {
        a: number[];
        c: number[];
        b: number[];
    };
    leafIndices: number[];
    leaves: BN[];
    rootIndices: number[];
    roots: BN[];
    merkleTrees: PublicKey[];
}, {
    compressedProof: Struct<{
        a: number[];
        c: number[];
        b: number[];
    }, {
        a: Struct<number[], Struct<number, null>>;
        b: Struct<number[], Struct<number, null>>;
        c: Struct<number[], Struct<number, null>>;
    }>;
    leafIndices: Struct<number[], Struct<number, null>>;
    leaves: Struct<BN[], Struct<BN, null>>;
    rootIndices: Struct<number[], Struct<number, null>>;
    roots: Struct<BN[], Struct<BN, null>>;
    merkleTrees: Struct<PublicKey[], Struct<PublicKey, null>>;
}>;
export declare const ValidityProofResultV2: Struct<{
    accounts: {
        root: BN;
        hash: BN;
        leafIndex: number;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        rootIndex: {
            proveByIndex: boolean;
            rootIndex: number;
        };
    }[];
    compressedProof: {
        a: number[];
        c: number[];
        b: number[];
    } | null;
    addresses: {
        root: BN;
        address: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        rootIndex: number;
    }[];
}, {
    compressedProof: Struct<{
        a: number[];
        c: number[];
        b: number[];
    } | null, {
        a: Struct<number[], Struct<number, null>>;
        b: Struct<number[], Struct<number, null>>;
        c: Struct<number[], Struct<number, null>>;
    }>;
    accounts: Struct<{
        root: BN;
        hash: BN;
        leafIndex: number;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        rootIndex: {
            proveByIndex: boolean;
            rootIndex: number;
        };
    }[], Struct<{
        root: BN;
        hash: BN;
        leafIndex: number;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        rootIndex: {
            proveByIndex: boolean;
            rootIndex: number;
        };
    }, {
        hash: Struct<BN, null>;
        root: Struct<BN, null>;
        rootIndex: Struct<{
            proveByIndex: boolean;
            rootIndex: number;
        }, {
            rootIndex: Struct<number, null>;
            proveByIndex: Struct<boolean, null>;
        }>;
        merkleContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        }, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
            nextTreeContext: Struct<{
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined, {
                treeType: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                queue: Struct<PublicKey, null>;
                cpiContext: Struct<PublicKey | null, null>;
            }>;
        }>;
        leafIndex: Struct<number, null>;
    }>>;
    addresses: Struct<{
        root: BN;
        address: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        rootIndex: number;
    }[], Struct<{
        root: BN;
        address: BN;
        merkleContext: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        };
        rootIndex: number;
    }, {
        address: Struct<BN, null>;
        root: Struct<BN, null>;
        rootIndex: Struct<number, null>;
        merkleContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
            nextTreeContext?: {
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined;
        }, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
            nextTreeContext: Struct<{
                cpiContext: PublicKey | null;
                tree: PublicKey;
                queue: PublicKey;
                treeType: number;
            } | null | undefined, {
                treeType: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                queue: Struct<PublicKey, null>;
                cpiContext: Struct<PublicKey | null, null>;
            }>;
        }>;
    }>>;
}>;
/**
 * @internal
 */
export declare const MultipleMerkleProofsResult: Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
}[], Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>>;
/**
 * @internal
 */
export declare const MultipleMerkleProofsResultV2: Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    proveByIndex: boolean;
    proof: BN[];
    rootSeq: number;
    treeContext: {
        cpiContext: PublicKey | null;
        tree: PublicKey;
        queue: PublicKey;
        treeType: number;
        nextTreeContext?: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined;
    };
}[], Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    proveByIndex: boolean;
    proof: BN[];
    rootSeq: number;
    treeContext: {
        cpiContext: PublicKey | null;
        tree: PublicKey;
        queue: PublicKey;
        treeType: number;
        nextTreeContext?: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined;
    };
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    root: Struct<BN, null>;
    rootSeq: Struct<number, null>;
    proveByIndex: Struct<boolean, null>;
    treeContext: Struct<{
        cpiContext: PublicKey | null;
        tree: PublicKey;
        queue: PublicKey;
        treeType: number;
        nextTreeContext?: {
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined;
    }, {
        treeType: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        queue: Struct<PublicKey, null>;
        cpiContext: Struct<PublicKey | null, null>;
        nextTreeContext: Struct<{
            cpiContext: PublicKey | null;
            tree: PublicKey;
            queue: PublicKey;
            treeType: number;
        } | null | undefined, {
            treeType: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            queue: Struct<PublicKey, null>;
            cpiContext: Struct<PublicKey | null, null>;
        }>;
    }>;
}>>;
/**
 * @internal
 */
export declare const BalanceResult: Struct<{
    amount: BN;
}, {
    amount: Struct<BN, null>;
}>;
export declare const NativeBalanceResult: Struct<BN, null>;
export declare const TokenBalanceResult: Struct<{
    mint: PublicKey;
    balance: BN;
}, {
    balance: Struct<BN, null>;
    mint: Struct<PublicKey, null>;
}>;
export declare const TokenBalanceListResult: Struct<{
    cursor: string | null;
    tokenBalances: {
        mint: PublicKey;
        balance: BN;
    }[];
}, {
    tokenBalances: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
export declare const TokenBalanceListResultV2: Struct<{
    items: {
        mint: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
export declare const CompressedMintTokenHoldersResult: Struct<{
    items: {
        owner: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    cursor: Struct<string | null, null>;
    items: Struct<{
        owner: PublicKey;
        balance: BN;
    }[], Struct<{
        owner: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
    }>>;
}>;
export declare const AccountProofResult: Struct<{
    root: number[];
    hash: number[];
    proof: number[][];
}, {
    hash: Struct<number[], Struct<number, null>>;
    root: Struct<number[], Struct<number, null>>;
    proof: Struct<number[][], Struct<number[], Struct<number, null>>>;
}>;
export declare const toUnixTimestamp: (blockTime: string) => number;
export declare const SignatureListResult: Struct<{
    items: {
        blockTime: number;
        signature: string;
        slot: number;
    }[];
}, {
    items: Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }[], Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
}>;
export declare const SignatureListWithCursorResult: Struct<{
    items: {
        blockTime: number;
        signature: string;
        slot: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }[], Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const CompressedTransactionResult: Struct<{
    compressionInfo: {
        closedAccounts: {
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    };
    transaction?: any;
}, {
    compressionInfo: Struct<{
        closedAccounts: {
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    }, {
        closedAccounts: Struct<{
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
        openedAccounts: Struct<{
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                tree: PublicKey;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
    }>;
    transaction: Struct<any, null>;
}>;
/**
 * @internal
 */
export declare const CompressedTransactionResultV2: Struct<{
    compressionInfo: {
        closedAccounts: {
            account: {
                account: {
                    data: {
                        data: string;
                        dataHash: BN;
                        discriminator: BN;
                    } | null;
                    lamports: BN;
                    address: number[] | null;
                    hash: BN;
                    owner: PublicKey;
                    leafIndex: number;
                    seq: BN | null;
                    slotCreated: BN;
                    merkleContext: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                        nextTreeContext?: {
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined;
                    };
                    proveByIndex: boolean;
                };
                txHash: BN;
                nullifier: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
                merkleContext: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                    nextTreeContext?: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                    } | null | undefined;
                };
                proveByIndex: boolean;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    };
    transaction?: any;
}, {
    compressionInfo: Struct<{
        closedAccounts: {
            account: {
                account: {
                    data: {
                        data: string;
                        dataHash: BN;
                        discriminator: BN;
                    } | null;
                    lamports: BN;
                    address: number[] | null;
                    hash: BN;
                    owner: PublicKey;
                    leafIndex: number;
                    seq: BN | null;
                    slotCreated: BN;
                    merkleContext: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                        nextTreeContext?: {
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined;
                    };
                    proveByIndex: boolean;
                };
                txHash: BN;
                nullifier: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
                merkleContext: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                    nextTreeContext?: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                    } | null | undefined;
                };
                proveByIndex: boolean;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    }, {
        closedAccounts: Struct<{
            account: {
                account: {
                    data: {
                        data: string;
                        dataHash: BN;
                        discriminator: BN;
                    } | null;
                    lamports: BN;
                    address: number[] | null;
                    hash: BN;
                    owner: PublicKey;
                    leafIndex: number;
                    seq: BN | null;
                    slotCreated: BN;
                    merkleContext: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                        nextTreeContext?: {
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined;
                    };
                    proveByIndex: boolean;
                };
                txHash: BN;
                nullifier: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                account: {
                    data: {
                        data: string;
                        dataHash: BN;
                        discriminator: BN;
                    } | null;
                    lamports: BN;
                    address: number[] | null;
                    hash: BN;
                    owner: PublicKey;
                    leafIndex: number;
                    seq: BN | null;
                    slotCreated: BN;
                    merkleContext: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                        nextTreeContext?: {
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined;
                    };
                    proveByIndex: boolean;
                };
                txHash: BN;
                nullifier: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                account: {
                    data: {
                        data: string;
                        dataHash: BN;
                        discriminator: BN;
                    } | null;
                    lamports: BN;
                    address: number[] | null;
                    hash: BN;
                    owner: PublicKey;
                    leafIndex: number;
                    seq: BN | null;
                    slotCreated: BN;
                    merkleContext: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                        nextTreeContext?: {
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined;
                    };
                    proveByIndex: boolean;
                };
                txHash: BN;
                nullifier: BN;
            }, {
                account: Struct<{
                    data: {
                        data: string;
                        dataHash: BN;
                        discriminator: BN;
                    } | null;
                    lamports: BN;
                    address: number[] | null;
                    hash: BN;
                    owner: PublicKey;
                    leafIndex: number;
                    seq: BN | null;
                    slotCreated: BN;
                    merkleContext: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                        nextTreeContext?: {
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined;
                    };
                    proveByIndex: boolean;
                }, {
                    address: Struct<number[] | null, null>;
                    hash: Struct<BN, null>;
                    data: Struct<{
                        data: string;
                        dataHash: BN;
                        discriminator: BN;
                    } | null, {
                        data: Struct<string, null>;
                        dataHash: Struct<BN, null>;
                        discriminator: Struct<BN, null>;
                    }>;
                    lamports: Struct<BN, null>;
                    owner: Struct<PublicKey, null>;
                    leafIndex: Struct<number, null>;
                    seq: Struct<BN | null, null>;
                    slotCreated: Struct<BN, null>;
                    merkleContext: Struct<{
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                        nextTreeContext?: {
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined;
                    }, {
                        treeType: Struct<number, null>;
                        tree: Struct<PublicKey, null>;
                        queue: Struct<PublicKey, null>;
                        cpiContext: Struct<PublicKey | null, null>;
                        nextTreeContext: Struct<{
                            cpiContext: PublicKey | null;
                            tree: PublicKey;
                            queue: PublicKey;
                            treeType: number;
                        } | null | undefined, {
                            treeType: Struct<number, null>;
                            tree: Struct<PublicKey, null>;
                            queue: Struct<PublicKey, null>;
                            cpiContext: Struct<PublicKey | null, null>;
                        }>;
                    }>;
                    proveByIndex: Struct<boolean, null>;
                }>;
                txHash: Struct<BN, null>;
                nullifier: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
        openedAccounts: Struct<{
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
                merkleContext: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                    nextTreeContext?: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                    } | null | undefined;
                };
                proveByIndex: boolean;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
                merkleContext: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                    nextTreeContext?: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                    } | null | undefined;
                };
                proveByIndex: boolean;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                lamports: BN;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                seq: BN | null;
                slotCreated: BN;
                merkleContext: {
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                    nextTreeContext?: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                    } | null | undefined;
                };
                proveByIndex: boolean;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
                merkleContext: Struct<{
                    cpiContext: PublicKey | null;
                    tree: PublicKey;
                    queue: PublicKey;
                    treeType: number;
                    nextTreeContext?: {
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                    } | null | undefined;
                }, {
                    treeType: Struct<number, null>;
                    tree: Struct<PublicKey, null>;
                    queue: Struct<PublicKey, null>;
                    cpiContext: Struct<PublicKey | null, null>;
                    nextTreeContext: Struct<{
                        cpiContext: PublicKey | null;
                        tree: PublicKey;
                        queue: PublicKey;
                        treeType: number;
                    } | null | undefined, {
                        treeType: Struct<number, null>;
                        tree: Struct<PublicKey, null>;
                        queue: Struct<PublicKey, null>;
                        cpiContext: Struct<PublicKey | null, null>;
                    }>;
                }>;
                proveByIndex: Struct<boolean, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
    }>;
    transaction: Struct<any, null>;
}>;
export interface CompressionApiInterface {
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN | null>;
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    getValidityProof(hashes: BN254[], newAddresses: BN254[]): Promise<ValidityProofWithContext>;
    getValidityProofV0(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<ValidityProofWithContext>;
    getValidityProofAndRpcContext(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<WithContext<ValidityProofWithContext>>;
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    getCompressedTokenAccountsByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    getIndexerHealth(): Promise<string>;
    getIndexerSlot(): Promise<number>;
}
export type RpcResultSuccess<T> = {
    jsonrpc: '2.0';
    id: string;
    result: T;
};
export type RpcResultError = {
    jsonrpc: '2.0';
    id: string;
    error: {
        code: unknown;
        message: string;
        data?: any;
    };
};
export type RpcResult<T> = RpcResultSuccess<T> | RpcResultError;
