import { Connection, ConnectionConfig, PublicKey } from '@solana/web3.js';
import BN from 'bn.js';
import { AddressWithTree, CompressedMintTokenHolders, CompressedTransaction, GetCompressedAccountsByOwnerConfig, PaginatedOptions, HashWithTree, LatestNonVotingSignatures, LatestNonVotingSignaturesPaginated, SignatureWithMetadata, WithContext, WithCursor } from '../../rpc-interface';
import { ValidityProofWithContext, CompressionApiInterface, GetCompressedTokenAccountsByOwnerOrDelegateOptions, ParsedTokenAccount, TokenBalance } from '../../rpc-interface';
import { BN254, CompressedAccountWithMerkleContext, MerkleContextWithMerkleProof } from '../../state';
import { MerkleContextWithNewAddressProof } from '../../rpc';
import { TreeInfo } from '../../state/types';
export interface TestRpcConfig {
    /**
     * Depth of state tree. Defaults to the public default test state tree depth
     */
    depth?: number;
    /**
     * Log proof generation time
     */
    log?: boolean;
}
export type ClientSubscriptionId = number;
export interface LightWasm {
    blakeHash(input: string | Uint8Array, hashLength: number): Uint8Array;
    poseidonHash(input: string[] | BN[]): Uint8Array;
    poseidonHashString(input: string[] | BN[]): string;
    poseidonHashBN(input: string[] | BN[]): BN;
}
/**
 * Returns a mock RPC instance for use in unit tests.
 *
 * @param lightWasm               Wasm hasher instance.
 * @param endpoint                RPC endpoint URL. Defaults to
 *                                'http://127.0.0.1:8899'.
 * @param proverEndpoint          Prover server endpoint URL. Defaults to
 *                                'http://localhost:3001'.
 * @param merkleTreeAddress       Address of the merkle tree to index. Defaults
 *                                to the public default test state tree.
 * @param nullifierQueueAddress   Optional address of the associated nullifier
 *                                queue.
 * @param depth                   Depth of the merkle tree.
 * @param log                     Log proof generation time.
 */
export declare function getTestRpc(lightWasm: LightWasm, endpoint?: string, compressionApiEndpoint?: string, proverEndpoint?: string, depth?: number, log?: boolean): Promise<TestRpc>;
/**
 * Mock RPC for unit tests that simulates the ZK Compression RPC interface.
 * Parses events and builds merkletree on-demand. It does not persist state.
 * Constraints:
 * - Can only index up to 1000 transactions
 *
 * For advanced testing use `Rpc` class which uses photon:
 * https://github.com/helius-labs/photon
 */
export declare class TestRpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    lightWasm: LightWasm;
    depth: number;
    log: boolean;
    allStateTreeInfos: TreeInfo[] | null;
    lastStateTreeFetchTime: number | null;
    fetchPromise: Promise<TreeInfo[]> | null;
    CACHE_TTL: number;
    /**
     * Establish a Compression-compatible JSON RPC mock-connection
     *
     * @param endpoint                  endpoint to the solana cluster (use for
     *                                  localnet only)
     * @param hasher                    light wasm hasher instance
     * @param compressionApiEndpoint    Endpoint to the compression server.
     * @param proverEndpoint            Endpoint to the prover server. defaults
     *                                  to endpoint
     * @param connectionConfig          Optional connection config
     * @param testRpcConfig             Config for the mock rpc
     */
    constructor(endpoint: string, hasher: LightWasm, compressionApiEndpoint: string, proverEndpoint: string, connectionConfig?: ConnectionConfig, testRpcConfig?: TestRpcConfig);
    /**
     * @deprecated Use {@link getStateTreeInfos} instead
     */
    getCachedActiveStateTreeInfo(): Promise<void>;
    /**
     * @deprecated Use {@link getStateTreeInfos} instead
     */
    getCachedActiveStateTreeInfos(): Promise<void>;
    /**
     * Returns local test state trees.
     */
    getStateTreeInfos(): Promise<TreeInfo[]>;
    doFetch(): Promise<TreeInfo[]>;
    /**
     * Fetch the compressed account for the specified account hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(_slot: number): Promise<boolean>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, _config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(_cursor?: string, _limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch the latest non-voting signatures on the cluster. Results are
     * not paginated.
     */
    getLatestNonVotingSignatures(_limit?: number): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2}.
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint.
     */
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<{
        balance: BN;
        mint: PublicKey;
    }[]>>;
    /**
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Uses context.
     */
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(_hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(_signature: string): Promise<CompressedTransaction>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed
     * block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(_address: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    getCompressedMintTokenHolders(_mint: PublicKey, _options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * @deprecated This method is not available for TestRpc. Please use
     * {@link getValidityProof} instead.
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<ValidityProofWithContext>>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<ValidityProofWithContext>;
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<ValidityProofWithContext>;
}
